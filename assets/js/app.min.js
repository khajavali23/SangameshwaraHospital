! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).THREE = {})
}(this, (function(e) {
    function t() {}

    function i(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function n(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function r(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }

    function o() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function a(e, t, n, r, s, l, c, h, u, d) {
        Object.defineProperty(this, "id", {
            value: vo++
        }), this.uuid = fo.generateUUID(), this.name = "", this.image = void 0 !== e ? e : a.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : a.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== s ? s : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null
    }

    function s(e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function l(e, t, i) {
        this.width = e, this.height = t, this.scissor = new s(0, 0, e, t), this.scissorTest = !1, this.viewport = new s(0, 0, e, t), i = i || {}, this.texture = new a(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function c(e, t, i) {
        l.call(this, e, t, i), this.samples = 4
    }

    function h(e, t, i) {
        l.call(this, e, t, i)
    }

    function u(e, t, i, n, r, o, s, l, c, h, u, d) {
        a.call(this, null, o, s, l, c, h, n, r, u, d), this.image = {
            data: e,
            width: t,
            height: i
        }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
    }

    function d(e, t) {
        this.min = void 0 !== e ? e : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new r(-1 / 0, -1 / 0, -1 / 0)
    }

    function p(e, t) {
        this.center = void 0 !== e ? e : new r, this.radius = void 0 !== t ? t : 0
    }

    function f(e, t) {
        this.normal = void 0 !== e ? e : new r(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function m(e, t, i, n, r, o) {
        this.planes = [void 0 !== e ? e : new f, void 0 !== t ? t : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== o ? o : new f]
    }

    function g() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function v(e) {
        var t, i = {};
        for (t in e)
            for (var n in i[t] = {}, e[t]) {
                var r = e[t][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[t][n] = r.clone() : Array.isArray(r) ? i[t][n] = r.slice() : i[t][n] = r
            }
        return i
    }

    function y(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n, r = v(e[i]);
            for (n in r) t[n] = r[n]
        }
        return t
    }

    function b(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }

    function x() {
        function e(r, o) {
            !1 !== i && (n(r, o), t.requestAnimationFrame(e))
        }
        var t = null,
            i = !1,
            n = null;
        return {
            start: function() {
                !0 !== i && null !== n && (t.requestAnimationFrame(e), i = !0)
            },
            stop: function() {
                i = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(e) {
                t = e
            }
        }
    }

    function w(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
            },
            remove: function(i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = t.get(i);
                n && (e.deleteBuffer(n.buffer), t.delete(i))
            },
            update: function(i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = t.get(i);
                if (void 0 === r) t.set(i, function(t, i) {
                    var n = t.array,
                        r = t.dynamic ? 35048 : 35044,
                        o = e.createBuffer();
                    return e.bindBuffer(i, o), e.bufferData(i, n, r), t.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
                        buffer: o,
                        type: i,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(i, n));
                else if (r.version < i.version) {
                    var o = i,
                        a = o.array,
                        s = o.updateRange;
                    e.bindBuffer(n, r.buffer), !1 === o.dynamic ? e.bufferData(n, a, 35044) : -1 === s.count ? e.bufferSubData(n, 0, a) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1), r.version = i.version
                }
            }
        }
    }

    function _(e, t, i, n, o, a) {
        this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new b, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== a ? a : 0
    }

    function E(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || E.DefaultOrder
    }

    function M() {
        this.mask = 1
    }

    function T() {
        Object.defineProperty(this, "id", {
            value: Eo++
        }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = T.DefaultUp.clone();
        var e = new r,
            t = new E,
            i = new n,
            a = new r(1, 1, 1);
        t.onChange((function() {
            i.setFromEuler(t, !1)
        })), i.onChange((function() {
            t.setFromQuaternion(i, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: a
            },
            modelViewMatrix: {
                value: new g
            },
            normalMatrix: {
                value: new o
            }
        }), this.matrix = new g, this.matrixWorld = new g, this.matrixAutoUpdate = T.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new M, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function S() {
        Object.defineProperty(this, "id", {
            value: Mo += 2
        }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function A(e, t, i) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function C(e, t, i) {
        A.call(this, new Int8Array(e), t, i)
    }

    function L(e, t, i) {
        A.call(this, new Uint8Array(e), t, i)
    }

    function D(e, t, i) {
        A.call(this, new Uint8ClampedArray(e), t, i)
    }

    function P(e, t, i) {
        A.call(this, new Int16Array(e), t, i)
    }

    function R(e, t, i) {
        A.call(this, new Uint16Array(e), t, i)
    }

    function O(e, t, i) {
        A.call(this, new Int32Array(e), t, i)
    }

    function I(e, t, i) {
        A.call(this, new Uint32Array(e), t, i)
    }

    function z(e, t, i) {
        A.call(this, new Float32Array(e), t, i)
    }

    function N(e, t, i) {
        A.call(this, new Float64Array(e), t, i)
    }

    function B() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function F(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]);
        return t
    }

    function k() {
        Object.defineProperty(this, "id", {
            value: To += 2
        }), this.uuid = fo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    function U(e, t, i, n, r, o) {
        S.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        }, this.fromBufferGeometry(new H(e, t, i, n, r, o)), this.mergeVertices()
    }

    function H(e, t, i, n, o, a) {
        function s(e, t, i, n, o, a, s, m, g, v, y) {
            var b = a / g,
                x = s / v,
                w = a / 2,
                _ = s / 2,
                E = m / 2;
            s = g + 1;
            var M, T, S = v + 1,
                A = a = 0,
                C = new r;
            for (T = 0; T < S; T++) {
                var L = T * x - _;
                for (M = 0; M < s; M++) C[e] = (M * b - w) * n, C[t] = L * o, C[i] = E, h.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[i] = 0 < m ? 1 : -1, u.push(C.x, C.y, C.z), d.push(M / g), d.push(1 - T / v), a += 1
            }
            for (T = 0; T < v; T++)
                for (M = 0; M < g; M++) e = p + M + s * (T + 1), t = p + (M + 1) + s * (T + 1), i = p + (M + 1) + s * T, c.push(p + M + s * T, e, i), c.push(e, t, i), A += 6;
            l.addGroup(f, A, y), f += A, p += a
        }
        k.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: o,
            depthSegments: a
        };
        var l = this;
        e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, a = Math.floor(a) || 1;
        var c = [],
            h = [],
            u = [],
            d = [],
            p = 0,
            f = 0;
        s("z", "y", "x", -1, -1, i, t, e, a, o, 0), s("z", "y", "x", 1, -1, i, t, -e, a, o, 1), s("x", "z", "y", 1, 1, e, i, t, n, a, 2), s("x", "z", "y", 1, -1, e, i, -t, n, a, 3), s("x", "y", "z", 1, -1, e, t, i, n, o, 4), s("x", "y", "z", -1, -1, e, t, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
    }

    function G(e, t, i, n) {
        S.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new j(e, t, i, n)), this.mergeVertices()
    }

    function j(e, t, i, n) {
        k.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r = (e = e || 1) / 2,
            o = (t = t || 1) / 2,
            a = (i = Math.floor(i) || 1) + 1,
            s = (n = Math.floor(n) || 1) + 1,
            l = e / i,
            c = t / n,
            h = [],
            u = [],
            d = [],
            p = [];
        for (e = 0; e < s; e++) {
            var f = e * c - o;
            for (t = 0; t < a; t++) u.push(t * l - r, -f, 0), d.push(0, 0, 1), p.push(t / i), p.push(1 - e / n)
        }
        for (e = 0; e < n; e++)
            for (t = 0; t < i; t++) r = t + a * (e + 1), o = t + 1 + a * (e + 1), s = t + 1 + a * e, h.push(t + a * e, r, s), h.push(r, o, s);
        this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
    }

    function V() {
        Object.defineProperty(this, "id", {
            value: So++
        }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function W(e) {
        V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function q(e, t) {
        this.origin = void 0 !== e ? e : new r, this.direction = void 0 !== t ? t : new r
    }

    function X(e, t, i) {
        this.a = void 0 !== e ? e : new r, this.b = void 0 !== t ? t : new r, this.c = void 0 !== i ? i : new r
    }

    function Y(e) {
        V.call(this), this.type = "MeshBasicMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Z(e, t) {
        T.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Y({
            color: 16777215 * Math.random()
        }), this.drawMode = 0, this.updateMorphTargets()
    }

    function J(e, t, i, n) {
        function r(e, i) {
            t.buffers.color.setClear(e.r, e.g, e.b, i, n)
        }
        var o, a, s = new b(0),
            l = 0,
            c = null,
            h = 0;
        return {
            getClearColor: function() {
                return s
            },
            setClearColor: function(e, t) {
                s.set(e), r(s, l = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(e) {
                r(s, l = e)
            },
            render: function(t, n, u, d) {
                n = n.background, (u = (u = e.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null), null === n ? (r(s, l), c = null, h = 0) : n && n.isColor && (r(n, 1), d = !0, c = null, h = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === a && ((a = new Z(new H(1, 1, 1), new W({
                    type: "BackgroundCubeMaterial",
                    uniforms: v(_o.cube.uniforms),
                    vertexShader: _o.cube.vertexShader,
                    fragmentShader: _o.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function(e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, Object.defineProperty(a.material, "map", {
                    get: function() {
                        return this.uniforms.tCube.value
                    }
                }), i.update(a)), d = n.isWebGLRenderTargetCube ? n.texture : n, a.material.uniforms.tCube.value = d, a.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && h === d.version || (a.material.needsUpdate = !0, c = n, h = d.version), t.unshift(a, a.geometry, a.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new Z(new j(2, 2), new W({
                    type: "BackgroundMaterial",
                    uniforms: v(_o.background.uniforms),
                    vertexShader: _o.background.vertexShader,
                    fragmentShader: _o.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), c === n && h === n.version || (o.material.needsUpdate = !0, c = n, h = n.version), t.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }

    function Q(e, t, i, n) {
        var r;
        this.setMode = function(e) {
            r = e
        }, this.render = function(t, n) {
            e.drawArrays(r, t, n), i.update(n, r)
        }, this.renderInstances = function(o, a, s) {
            if (n.isWebGL2) var l = e;
            else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), i.update(s, r, o.maxInstancedCount)
        }
    }

    function $(e, t, i) {
        function n(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var r, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
            a = void 0 !== i.precision ? i.precision : "highp",
            s = n(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s), i = !0 === i.logarithmicDepthBuffer, s = e.getParameter(34930);
        var l = e.getParameter(35660),
            c = e.getParameter(3379),
            h = e.getParameter(34076),
            u = e.getParameter(34921),
            d = e.getParameter(36347),
            p = e.getParameter(36348),
            f = e.getParameter(36349),
            m = 0 < l,
            g = o || !!t.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== r) return r;
                var i = t.get("EXT_texture_filter_anisotropic");
                return r = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: a,
            logarithmicDepthBuffer: i,
            maxTextures: s,
            maxVertexTextures: l,
            maxTextureSize: c,
            maxCubemapSize: h,
            maxAttributes: u,
            maxVertexUniforms: d,
            maxVaryings: p,
            maxFragmentUniforms: f,
            vertexTextures: m,
            floatFragmentTextures: g,
            floatVertexTextures: m && g,
            maxSamples: o ? e.getParameter(36183) : 0
        }
    }

    function K() {
        function e() {
            h.value !== n && (h.value = n, h.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
        }

        function t(e, t, n, r) {
            var o = null !== e ? e.length : 0,
                a = null;
            if (0 !== o) {
                if (a = h.value, !0 !== r || null === a)
                    for (r = n + 4 * o, t = t.matrixWorldInverse, c.getNormalMatrix(t), (null === a || a.length < r) && (a = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) l.copy(e[r]).applyMatrix4(t, c), l.normal.toArray(a, n), a[n + 3] = l.constant;
                h.value = a, h.needsUpdate = !0
            }
            return i.numPlanes = o, a
        }
        var i = this,
            n = null,
            r = 0,
            a = !1,
            s = !1,
            l = new f,
            c = new o,
            h = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function(e, i, o) {
            var s = 0 !== e.length || i || 0 !== r || a;
            return a = i, n = t(e, o, 0), r = e.length, s
        }, this.beginShadows = function() {
            s = !0, t(null)
        }, this.endShadows = function() {
            s = !1, e()
        }, this.setState = function(i, o, l, c, u, d) {
            if (!a || null === i || 0 === i.length || s && !l) s ? t(null) : e();
            else {
                var p = 4 * (l = s ? 0 : r),
                    f = u.clippingState || null;
                for (h.value = f, f = t(i, c, p, d), i = 0; i !== p; ++i) f[i] = n[i];
                u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
            }
        }
    }

    function ee(e) {
        var t = {};
        return {
            get: function(i) {
                if (void 0 !== t[i]) return t[i];
                switch (i) {
                    case "WEBGL_depth_texture":
                        var n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        n = e.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n
            }
        }
    }

    function te(e, t, i) {
        function n(e) {
            var a = e.target;
            for (var s in null !== (e = r[a.id]).index && t.remove(e.index), e.attributes) t.remove(e.attributes[s]);
            a.removeEventListener("dispose", n), delete r[a.id], (s = o[e.id]) && (t.remove(s), delete o[e.id]), i.memory.geometries--
        }
        var r = {},
            o = {};
        return {
            get: function(e, t) {
                var o = r[t.id];
                return o || (t.addEventListener("dispose", n), t.isBufferGeometry ? o = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new k).setFromObject(e)), o = t._bufferGeometry), r[t.id] = o, i.memory.geometries++, o)
            },
            update: function(e) {
                var i = e.index,
                    n = e.attributes;
                for (var r in null !== i && t.update(i, 34963), n) t.update(n[r], 34962);
                for (r in e = e.morphAttributes) {
                    n = 0;
                    for (var o = (i = e[r]).length; n < o; n++) t.update(i[n], 34962)
                }
            },
            getWireframeAttribute: function(e) {
                var i = o[e.id];
                if (i) return i;
                i = [];
                var n = e.index,
                    r = e.attributes;
                if (null !== n) {
                    r = 0;
                    for (var a = (n = n.array).length; r < a; r += 3) {
                        var s = n[r + 0],
                            l = n[r + 1],
                            c = n[r + 2];
                        i.push(s, l, l, c, c, s)
                    }
                } else
                    for (n = r.position.array, r = 0, a = n.length / 3 - 1; r < a; r += 3) s = r + 0, l = r + 1, c = r + 2, i.push(s, l, l, c, c, s);
                return i = new(65535 < F(i) ? I : R)(i, 1), t.update(i, 34963), o[e.id] = i
            }
        }
    }

    function ie(e, t, i, n) {
        var r, o, a;
        this.setMode = function(e) {
            r = e
        }, this.setIndex = function(e) {
            o = e.type, a = e.bytesPerElement
        }, this.render = function(t, n) {
            e.drawElements(r, n, o, t * a), i.update(n, r)
        }, this.renderInstances = function(s, l, c) {
            if (n.isWebGL2) var h = e;
            else if (null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, o, l * a, s.maxInstancedCount), i.update(c, r, s.maxInstancedCount)
        }
    }

    function ne(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function(e, i, n) {
                switch (n = n || 1, t.calls++, i) {
                    case 4:
                        t.triangles += e / 3 * n;
                        break;
                    case 5:
                    case 6:
                        t.triangles += n * (e - 2);
                        break;
                    case 1:
                        t.lines += e / 2 * n;
                        break;
                    case 3:
                        t.lines += n * (e - 1);
                        break;
                    case 2:
                        t.lines += n * e;
                        break;
                    case 0:
                        t.points += n * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function re(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function oe(e) {
        var t = {},
            i = new Float32Array(8);
        return {
            update: function(n, r, o, a) {
                var s = n.morphTargetInfluences,
                    l = s.length;
                if (void 0 === (n = t[r.id])) {
                    n = [];
                    for (var c = 0; c < l; c++) n[c] = [c, 0];
                    t[r.id] = n
                }
                var h = o.morphTargets && r.morphAttributes.position;
                for (o = o.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
                    var u = n[c];
                    0 !== u[1] && (h && r.removeAttribute("morphTarget" + c), o && r.removeAttribute("morphNormal" + c))
                }
                for (c = 0; c < l; c++)(u = n[c])[0] = c, u[1] = s[c];
                for (n.sort(re), c = 0; 8 > c; c++)(u = n[c]) && (s = u[0], l = u[1]) ? (h && r.addAttribute("morphTarget" + c, h[s]), o && r.addAttribute("morphNormal" + c, o[s]), i[c] = l) : i[c] = 0;
                a.getUniforms().setValue(e, "morphTargetInfluences", i)
            }
        }
    }

    function ae(e, t) {
        var i = {};
        return {
            update: function(n) {
                var r = t.render.frame,
                    o = n.geometry,
                    a = e.get(n, o);
                return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), e.update(a), i[a.id] = r), a
            },
            dispose: function() {
                i = {}
            }
        }
    }

    function se(e, t, i, n, r, o, s, l, c, h) {
        e = void 0 !== e ? e : [], a.call(this, e, void 0 !== t ? t : 301, i, n, r, o, void 0 !== s ? s : 1022, l, c, h), this.flipY = !1
    }

    function le(e, t, i, n) {
        a.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function ce(e, t, i, n) {
        a.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function he(e, t, i) {
        var n = e[0];
        if (0 >= n || 0 < n) return e;
        var r = t * i,
            o = Po[r];
        if (void 0 === o && (o = new Float32Array(r), Po[r] = o), 0 !== t)
            for (n.toArray(o, 0), n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(o, r);
        return o
    }

    function ue(e, t) {
        if (e.length !== t.length) return !1;
        for (var i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i]) return !1;
        return !0
    }

    function de(e, t) {
        for (var i = 0, n = t.length; i < n; i++) e[i] = t[i]
    }

    function pe(e, t) {
        var i = Ro[t];
        void 0 === i && (i = new Int32Array(t), Ro[t] = i);
        for (var n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
        return i
    }

    function fe(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
    }

    function me(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y) : ue(i, t) || (e.uniform2fv(this.addr, t), de(i, t))
    }

    function ge(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b) : ue(i, t) || (e.uniform3fv(this.addr, t), de(i, t))
    }

    function ve(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w) : ue(i, t) || (e.uniform4fv(this.addr, t), de(i, t))
    }

    function ye(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix2fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (zo.set(n), e.uniformMatrix2fv(this.addr, !1, zo), de(i, n))
    }

    function be(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix3fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Io.set(n), e.uniformMatrix3fv(this.addr, !1, Io), de(i, n))
    }

    function xe(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix4fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Oo.set(n), e.uniformMatrix4fv(this.addr, !1, Oo), de(i, n))
    }

    function we(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || Ao, r)
    }

    function _e(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || Co, r)
    }

    function Ee(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || Lo, r)
    }

    function Me(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || Do, r)
    }

    function Te(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
    }

    function Se(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform2iv(this.addr, t), de(i, t))
    }

    function Ae(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform3iv(this.addr, t), de(i, t))
    }

    function Ce(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform4iv(this.addr, t), de(i, t))
    }

    function Le(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function De(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function Pe(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function Re(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function Oe(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function Ie(e, t) {
        t = he(t, this.size, 2), e.uniform2fv(this.addr, t)
    }

    function ze(e, t) {
        t = he(t, this.size, 3), e.uniform3fv(this.addr, t)
    }

    function Ne(e, t) {
        t = he(t, this.size, 4), e.uniform4fv(this.addr, t)
    }

    function Be(e, t) {
        t = he(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t)
    }

    function Fe(e, t) {
        t = he(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t)
    }

    function ke(e, t) {
        t = he(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t)
    }

    function Ue(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTexture2D(t[e] || Ao, r[e])
    }

    function He(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTextureCube(t[e] || Do, r[e])
    }

    function Ge(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return fe;
                case 35664:
                    return me;
                case 35665:
                    return ge;
                case 35666:
                    return ve;
                case 35674:
                    return ye;
                case 35675:
                    return be;
                case 35676:
                    return xe;
                case 35678:
                case 36198:
                    return we;
                case 35679:
                    return Ee;
                case 35680:
                    return Me;
                case 36289:
                    return _e;
                case 5124:
                case 35670:
                    return Te;
                case 35667:
                case 35671:
                    return Se;
                case 35668:
                case 35672:
                    return Ae;
                case 35669:
                case 35673:
                    return Ce
            }
        }(t.type)
    }

    function je(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return Le;
                case 35664:
                    return Ie;
                case 35665:
                    return ze;
                case 35666:
                    return Ne;
                case 35674:
                    return Be;
                case 35675:
                    return Fe;
                case 35676:
                    return ke;
                case 35678:
                    return Ue;
                case 35680:
                    return He;
                case 5124:
                case 35670:
                    return De;
                case 35667:
                case 35671:
                    return Pe;
                case 35668:
                case 35672:
                    return Re;
                case 35669:
                case 35673:
                    return Oe
            }
        }(t.type)
    }

    function Ve(e) {
        this.id = e, this.seq = [], this.map = {}
    }

    function We(e, t) {
        this.seq = [], this.map = {};
        for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) {
            var r = e.getActiveUniform(t, n),
                o = e.getUniformLocation(t, r.name),
                a = this,
                s = r.name,
                l = s.length;
            for (No.lastIndex = 0;;) {
                var c = No.exec(s),
                    h = No.lastIndex,
                    u = c[1],
                    d = c[3];
                if ("]" === c[2] && (u |= 0), void 0 === d || "[" === d && h + 2 === l) {
                    s = a, r = void 0 === d ? new Ge(u, r, o) : new je(u, r, o), s.seq.push(r), s.map[r.id] = r;
                    break
                }
                void 0 === (d = a.map[u]) && (d = new Ve(u), u = a, a = d, u.seq.push(a), u.map[a.id] = a), a = d
            }
        }
    }

    function qe(e, t, i, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, i), e.compileShader(r), !0 === n && (!1 === e.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(r), function(e) {
            e = e.split("\n");
            for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(i))), r
    }

    function Xe(e) {
        switch (e) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + e)
        }
    }

    function Ye(e, t) {
        return "vec4 " + e + "( vec4 value ) { return " + (t = Xe(t))[0] + "ToLinear" + t[1] + "; }"
    }

    function Ze(e, t) {
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = Xe(t))[0] + t[1] + "; }"
    }

    function Je(e, t) {
        switch (t) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Uncharted2";
                break;
            case 4:
                t = "OptimizedCineon";
                break;
            case 5:
                t = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }

    function Qe(e) {
        return "" !== e
    }

    function $e(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function Ke(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function et(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function(e, t) {
            if (void 0 === (e = yo[t])) throw Error("Can not resolve #include <" + t + ">");
            return et(e)
        }))
    }

    function tt(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function(e, t, i, n) {
            for (e = "", t = parseInt(t); t < parseInt(i); t++) e += n.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        }))
    }

    function it(e, t, i, n, r, o, a, s) {
        var l = e.context,
            c = n.defines,
            h = r.vertexShader,
            u = r.fragmentShader,
            d = "SHADOWMAP_TYPE_BASIC";
        1 === o.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT");
        var p = "ENVMAP_TYPE_CUBE",
            f = "ENVMAP_MODE_REFLECTION",
            m = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (n.envMap.mapping) {
                case 301:
                case 302:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case 302:
                case 304:
                    f = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case 0:
                    m = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    m = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    m = "ENVMAP_BLENDING_ADD"
            }
        }
        var g, v, y = 0 < e.gammaFactor ? e.gammaFactor : 1,
            b = a.isWebGL2 ? "" : function(e, t, i) {
                return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qe).join("\n")
            }(n.extensions, o, t),
            x = function(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    !1 !== n && i.push("#define " + t + " " + n)
                }
                return i.join("\n")
            }(c),
            w = l.createProgram();
        return n.isRawShaderMaterial ? (0 < (c = [x].filter(Qe).join("\n")).length && (c += "\n"), 0 < (t = [b, x].filter(Qe).join("\n")).length && (t += "\n")) : (c = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qe).join("\n"), t = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? yo.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? Je("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? yo.encodings_pars_fragment : "", o.mapEncoding ? Ye("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ye("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ye("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ye("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? Ze("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qe).join("\n")), h = Ke(h = $e(h = et(h), o), o), u = Ke(u = $e(u = et(u), o), o), h = tt(h), u = tt(u), a.isWebGL2 && !n.isRawShaderMaterial && (a = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== h.match(d) && null !== u.match(d) && (a = !0, h = h.replace(d, ""), u = u.replace(d, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, t = ["#version 300 es\n\n#define varying in", a ? "" : "out highp vec4 pc_fragColor;", a ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t), u = t + u, h = qe(l, 35633, c + h, e.debug.checkShaderErrors), u = qe(l, 35632, u, e.debug.checkShaderErrors), l.attachShader(w, h), l.attachShader(w, u), void 0 !== n.index0AttributeName ? l.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(w, 0, "position"), l.linkProgram(w), e.debug.checkShaderErrors && (e = l.getProgramInfoLog(w).trim(), o = l.getShaderInfoLog(h).trim(), a = l.getShaderInfoLog(u).trim(), p = d = !0, !1 === l.getProgramParameter(w, 35714) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(w, 35715), "gl.getProgramInfoLog", e, o, a)) : "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== o && "" !== a || (p = !1), p && (this.diagnostics = {
            runnable: d,
            material: n,
            programLog: e,
            vertexShader: {
                log: o,
                prefix: c
            },
            fragmentShader: {
                log: a,
                prefix: t
            }
        })), l.deleteShader(h), l.deleteShader(u), this.getUniforms = function() {
            return void 0 === g && (g = new We(l, w, s)), g
        }, this.getAttributes = function() {
            if (void 0 === v) {
                for (var e = {}, t = l.getProgramParameter(w, 35721), i = 0; i < t; i++) {
                    var n = l.getActiveAttrib(w, i).name;
                    e[n] = l.getAttribLocation(w, n)
                }
                v = e
            }
            return v
        }, this.destroy = function() {
            l.deleteProgram(w), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = r.name, this.id = Bo++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = h, this.fragmentShader = u, this
    }

    function nt(e, t, i, n) {
        function r(e, t) {
            if (e) e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding);
            else var i = 3e3;
            return 3e3 === i && t && (i = 3007), i
        }
        var o = [],
            a = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            s = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(t, n, o, s, l, c, h) {
            var u = a[t.type];
            if (h.isSkinnedMesh) {
                var d = h.skeleton.bones;
                if (i.floatVertexTextures) d = 1024;
                else {
                    var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length);
                    p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p
                }
            } else d = 0;
            p = i.precision, null !== t.precision && ((p = i.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", p, "instead."));
            var f = e.getRenderTarget();
            return {
                shaderID: u,
                precision: p,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: r(f ? f.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: r(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: r(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: r(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: 1 === t.normalMapType,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                fog: !!s,
                useFog: t.fog,
                fogExp: s && s.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: t.skinning && 0 < d,
                maxBones: d,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && 0 < o.length,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: 2 === t.side,
                flipSided: 1 === t.side,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }, this.getProgramCode = function(t, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            for (r = 0; r < s.length; r++) n.push(i[s[r]]);
            return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.push(e.gammaFactor), n.join()
        }, this.acquireProgram = function(r, a, s, l) {
            for (var c, h = 0, u = o.length; h < u; h++) {
                var d = o[h];
                if (d.code === l) {
                    ++(c = d).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new it(e, t, l, r, a, s, i, n), o.push(c)), c
        }, this.releaseProgram = function(e) {
            if (0 === --e.usedTimes) {
                var t = o.indexOf(e);
                o[t] = o[o.length - 1], o.pop(), e.destroy()
            }
        }, this.programs = o
    }

    function rt() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var i = e.get(t);
                return void 0 === i && (i = {}, e.set(t, i)), i
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, i, n) {
                e.get(t)[i] = n
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function ot(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function at(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function st() {
        function e(e, n, r, a, s, l) {
            var c = t[i];
            return void 0 === c ? (c = {
                id: e.id,
                object: e,
                geometry: n,
                material: r,
                program: r.program || o,
                groupOrder: a,
                renderOrder: e.renderOrder,
                z: s,
                group: l
            }, t[i] = c) : (c.id = e.id, c.object = e, c.geometry = n, c.material = r, c.program = r.program || o, c.groupOrder = a, c.renderOrder = e.renderOrder, c.z = s, c.group = l), i++, c
        }
        var t = [],
            i = 0,
            n = [],
            r = [],
            o = {
                id: -1
            };
        return {
            opaque: n,
            transparent: r,
            init: function() {
                i = 0, n.length = 0, r.length = 0
            },
            push: function(t, i, o, a, s, l) {
                t = e(t, i, o, a, s, l), (!0 === o.transparent ? r : n).push(t)
            },
            unshift: function(t, i, o, a, s, l) {
                t = e(t, i, o, a, s, l), (!0 === o.transparent ? r : n).unshift(t)
            },
            sort: function() {
                1 < n.length && n.sort(ot), 1 < r.length && r.sort(at)
            }
        }
    }

    function lt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function(i, n) {
                var r = t[i.id];
                if (void 0 === r) {
                    var o = new st;
                    t[i.id] = {}, t[i.id][n.id] = o, i.addEventListener("dispose", e)
                } else void 0 === (o = r[n.id]) && (o = new st, r[n.id] = o);
                return o
            },
            dispose: function() {
                t = {}
            }
        }
    }

    function ct() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                switch (t.type) {
                    case "DirectionalLight":
                        var n = {
                            direction: new r,
                            color: new b,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new r,
                            direction: new r,
                            color: new b,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new r,
                            color: new b,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new r,
                            skyColor: new b,
                            groundColor: new b
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new b,
                            position: new r,
                            halfWidth: new r,
                            halfHeight: new r
                        }
                }
                return e[t.id] = n
            }
        }
    }

    function ht() {
        for (var e = new ct, t = {
                id: Fo++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, i = 0; 9 > i; i++) t.probe.push(new r);
        var n = new r,
            o = new g,
            a = new g;
        return {
            setup: function(i, r, s) {
                for (var l = 0, c = 0, h = 0, u = 0; 9 > u; u++) t.probe[u].set(0, 0, 0);
                var d = 0,
                    p = 0,
                    f = 0,
                    m = 0,
                    g = 0;
                s = s.matrixWorldInverse, u = 0;
                for (var v = i.length; u < v; u++) {
                    var y = i[u],
                        b = y.color,
                        x = y.intensity,
                        w = y.distance,
                        _ = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight) l += b.r * x, c += b.g * x, h += b.b * x;
                    else if (y.isLightProbe)
                        for (_ = 0; 9 > _; _++) t.probe[_].addScaledVector(y.sh.coefficients[_], x);
                    else if (y.isDirectionalLight) {
                        var E = e.get(y);
                        E.color.copy(y.color).multiplyScalar(y.intensity), E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(s), (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.directionalShadowMap[d] = _, t.directionalShadowMatrix[d] = y.shadow.matrix, t.directional[d] = E, d++
                    } else y.isSpotLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), E.color.copy(b).multiplyScalar(x), E.distance = w, E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(s), E.coneCos = Math.cos(y.angle), E.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.spotShadowMap[f] = _, t.spotShadowMatrix[f] = y.shadow.matrix, t.spot[f] = E, f++) : y.isRectAreaLight ? ((E = e.get(y)).color.copy(b).multiplyScalar(x), E.position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), a.identity(), o.copy(y.matrixWorld), o.premultiply(s), a.extractRotation(o), E.halfWidth.set(.5 * y.width, 0, 0), E.halfHeight.set(0, .5 * y.height, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), t.rectArea[m] = E, m++) : y.isPointLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), E.color.copy(y.color).multiplyScalar(y.intensity), E.distance = y.distance, E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize, E.shadowCameraNear = x.camera.near, E.shadowCameraFar = x.camera.far), t.pointShadowMap[p] = _, t.pointShadowMatrix[p] = y.shadow.matrix, t.point[p] = E, p++) : y.isHemisphereLight && ((E = e.get(y)).direction.setFromMatrixPosition(y.matrixWorld), E.direction.transformDirection(s), E.direction.normalize(), E.skyColor.copy(y.color).multiplyScalar(x), E.groundColor.copy(y.groundColor).multiplyScalar(x), t.hemi[g] = E, g++)
                }
                t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = d, t.spot.length = f, t.rectArea.length = m, t.point.length = p, t.hemi.length = g, t.hash.stateID = t.id, t.hash.directionalLength = d, t.hash.pointLength = p, t.hash.spotLength = f, t.hash.rectAreaLength = m, t.hash.hemiLength = g, t.hash.shadowsLength = r.length
            },
            state: t
        }
    }

    function ut() {
        var e = new ht,
            t = [],
            i = [];
        return {
            init: function() {
                t.length = 0, i.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: i,
                lights: e
            },
            setupLights: function(n) {
                e.setup(t, i, n)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }

    function dt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function(i, n) {
                if (void 0 === t[i.id]) {
                    var r = new ut;
                    t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)
                } else void 0 === t[i.id][n.id] ? (r = new ut, t[i.id][n.id] = r) : r = t[i.id][n.id];
                return r
            },
            dispose: function() {
                t = {}
            }
        }
    }

    function pt(e) {
        V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(e)
    }

    function ft(e) {
        V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(e)
    }

    function mt(e, t, n) {
        function o(t, i, n, r, o, a) {
            var s = t.geometry,
                l = v,
                c = t.customDepthMaterial;
            return n && (l = y, c = t.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (s && s.isBufferGeometry ? c = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (c = s.morphTargets && 0 < s.morphTargets.length)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), s = 0, c && (s |= 1), (t = t.isSkinnedMesh && i.skinning) && (s |= 2), l = l[s]), e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (s = l.uuid, c = i.uuid, void 0 === (t = b[s]) && (t = {}, b[s] = t), void 0 === (s = t[c]) && (s = l.clone(), t[c] = s), l = s), l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : x[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = a), l
        }

        function a(i, n, r, s) {
            if (!1 !== i.visible) {
                if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || c.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                    var l = t.update(i),
                        h = i.material;
                    if (Array.isArray(h))
                        for (var u = l.groups, d = 0, p = u.length; d < p; d++) {
                            var m = u[d],
                                g = h[m.materialIndex];
                            g && g.visible && (g = o(i, g, s, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, m))
                        } else h.visible && (g = o(i, h, s, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, null))
                }
                for (l = 0, h = (i = i.children).length; l < h; l++) a(i[l], n, r, s)
            }
        }
        var c = new m,
            h = new g,
            u = new i,
            d = new i(n, n),
            p = new r,
            f = new r,
            v = Array(4),
            y = Array(4),
            b = {},
            x = {
                0: 1,
                1: 0,
                2: 2
            },
            w = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)],
            _ = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)],
            E = [new s, new s, new s, new s, new s, new s];
        for (n = 0; 4 !== n; ++n) {
            var M = !!(1 & n),
                T = !!(2 & n),
                S = new pt({
                    depthPacking: 3201,
                    morphTargets: M,
                    skinning: T
                });
            v[n] = S, M = new ft({
                morphTargets: M,
                skinning: T
            }), y[n] = M
        }
        var A = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, i, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== t.length) {
                var r = e.getRenderTarget(),
                    o = e.getActiveCubeFace(),
                    s = e.getActiveMipMapLevel(),
                    m = e.state;
                m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
                for (var g, v = 0, y = t.length; v < y; v++) {
                    var b = t[v];
                    g = b.shadow;
                    var x = b && b.isPointLight;
                    if (void 0 === g) console.warn("THREE.WebGLShadowMap:", b, "has no shadow.");
                    else {
                        var M = g.camera;
                        if (u.copy(g.mapSize), u.min(d), x) {
                            var T = u.x,
                                S = u.y;
                            E[0].set(2 * T, S, T, S), E[1].set(0, S, T, S), E[2].set(3 * T, S, T, S), E[3].set(T, S, T, S), E[4].set(3 * T, 0, T, S), E[5].set(T, 0, T, S), u.x *= 4, u.y *= 2
                        }
                        for (null === g.map && (g.map = new l(u.x, u.y, {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            }), g.map.texture.name = b.name + ".shadowMap", M.updateProjectionMatrix()), g.isSpotLightShadow && g.update(b), T = g.map, S = g.matrix, f.setFromMatrixPosition(b.matrixWorld), M.position.copy(f), x ? (g = 6, S.makeTranslation(-f.x, -f.y, -f.z)) : (g = 1, p.setFromMatrixPosition(b.target.matrixWorld), M.lookAt(p), M.updateMatrixWorld(), S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), S.multiply(M.projectionMatrix), S.multiply(M.matrixWorldInverse)), e.setRenderTarget(T), e.clear(), b = 0; b < g; b++) x && (p.copy(M.position), p.add(w[b]), M.up.copy(_[b]), M.lookAt(p), M.updateMatrixWorld(), m.viewport(E[b])), h.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), c.setFromMatrix(h), a(i, n, M, x)
                    }
                }
                A.needsUpdate = !1, e.setRenderTarget(r, o, s)
            }
        }
    }

    function gt(e, t, i, n) {
        function r(t, i, n) {
            var r = new Uint8Array(4),
                o = e.createTexture();
            for (e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }

        function o(i, r) {
            y[i] = 1, 0 === b[i] && (e.enableVertexAttribArray(i), b[i] = 1), x[i] !== r && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), x[i] = r)
        }

        function a(t) {
            !0 !== w[t] && (e.enable(t), w[t] = !0)
        }

        function l(t) {
            !1 !== w[t] && (e.disable(t), w[t] = !1)
        }

        function c(t, n, r, o, s, c, h, u) {
            if (0 === t) M && (l(3042), M = !1);
            else if (M || (a(3042), M = !0), 5 !== t) {
                if (t !== T || u !== R) {
                    if (100 === S && 100 === L || (e.blendEquation(32774), L = S = 100), u) switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    P = D = C = A = null, T = t, R = u
                }
            } else s = s || n, c = c || r, h = h || o, n === S && s === L || (e.blendEquationSeparate(i.convert(n), i.convert(s)), S = n, L = s), r === A && o === C && c === D && h === P || (e.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(c), i.convert(h)), A = r, C = o, D = c, P = h), T = t, R = null
        }

        function h(t) {
            O !== t && (t ? e.frontFace(2304) : e.frontFace(2305), O = t)
        }

        function u(t) {
            0 !== t ? (a(2884), t !== I && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : l(2884), I = t
        }

        function d(t, i, n) {
            t ? (a(32823), (N !== i || B !== n) && (e.polygonOffset(i, n), N = i, B = n)) : l(32823)
        }

        function p(t) {
            void 0 === t && (t = 33984 + F - 1), U !== t && (e.activeTexture(t), U = t)
        }
        var f = new function() {
                var t = !1,
                    i = new s,
                    n = null,
                    r = new s(0, 0, 0, 0);
                return {
                    setMask: function(i) {
                        n === i || t || (e.colorMask(i, i, i, i), n = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, n, o, a, s) {
                        !0 === s && (t *= a, n *= a, o *= a), i.set(t, n, o, a), !1 === r.equals(i) && (e.clearColor(t, n, o, a), r.copy(i))
                    },
                    reset: function() {
                        t = !1, n = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            m = new function() {
                var t = !1,
                    i = null,
                    n = null,
                    r = null;
                return {
                    setTest: function(e) {
                        e ? a(2929) : l(2929)
                    },
                    setMask: function(n) {
                        i === n || t || (e.depthMask(n), i = n)
                    },
                    setFunc: function(t) {
                        if (n !== t) {
                            if (t) switch (t) {
                                case 0:
                                    e.depthFunc(512);
                                    break;
                                case 1:
                                    e.depthFunc(519);
                                    break;
                                case 2:
                                    e.depthFunc(513);
                                    break;
                                case 3:
                                default:
                                    e.depthFunc(515);
                                    break;
                                case 4:
                                    e.depthFunc(514);
                                    break;
                                case 5:
                                    e.depthFunc(518);
                                    break;
                                case 6:
                                    e.depthFunc(516);
                                    break;
                                case 7:
                                    e.depthFunc(517)
                            } else e.depthFunc(515);
                            n = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        r !== t && (e.clearDepth(t), r = t)
                    },
                    reset: function() {
                        t = !1, r = n = i = null
                    }
                }
            },
            g = new function() {
                var t = !1,
                    i = null,
                    n = null,
                    r = null,
                    o = null,
                    s = null,
                    c = null,
                    h = null,
                    u = null;
                return {
                    setTest: function(e) {
                        e ? a(2960) : l(2960)
                    },
                    setMask: function(n) {
                        i === n || t || (e.stencilMask(n), i = n)
                    },
                    setFunc: function(t, i, a) {
                        n === t && r === i && o === a || (e.stencilFunc(t, i, a), n = t, r = i, o = a)
                    },
                    setOp: function(t, i, n) {
                        s === t && c === i && h === n || (e.stencilOp(t, i, n), s = t, c = i, h = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        u !== t && (e.clearStencil(t), u = t)
                    },
                    reset: function() {
                        t = !1, u = h = c = s = o = r = n = i = null
                    }
                }
            },
            v = e.getParameter(34921),
            y = new Uint8Array(v),
            b = new Uint8Array(v),
            x = new Uint8Array(v),
            w = {},
            _ = null,
            E = null,
            M = null,
            T = null,
            S = null,
            A = null,
            C = null,
            L = null,
            D = null,
            P = null,
            R = !1,
            O = null,
            I = null,
            z = null,
            N = null,
            B = null,
            F = e.getParameter(35661),
            k = !1;
        v = 0, -1 !== (v = e.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), k = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), k = 2 <= v);
        var U = null,
            H = {},
            G = new s,
            j = new s,
            V = {};
        return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), a(2929), m.setFunc(3), h(!1), u(1), a(2884), c(0), {
            buffers: {
                color: f,
                depth: m,
                stencil: g
            },
            initAttributes: function() {
                for (var e = 0, t = y.length; e < t; e++) y[e] = 0
            },
            enableAttribute: function(e) {
                o(e, 0)
            },
            enableAttributeAndDivisor: o,
            disableUnusedAttributes: function() {
                for (var t = 0, i = b.length; t !== i; ++t) b[t] !== y[t] && (e.disableVertexAttribArray(t), b[t] = 0)
            },
            enable: a,
            disable: l,
            getCompressedTextureFormats: function() {
                if (null === _ && (_ = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var i = e.getParameter(34467), n = 0; n < i.length; n++) _.push(i[n]);
                return _
            },
            useProgram: function(t) {
                return E !== t && (e.useProgram(t), E = t, !0)
            },
            setBlending: c,
            setMaterial: function(e, t) {
                2 === e.side ? l(2884) : a(2884);
                var i = 1 === e.side;
                t && (i = !i), h(i), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), d(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: h,
            setCullFace: u,
            setLineWidth: function(t) {
                t !== z && (k && e.lineWidth(t), z = t)
            },
            setPolygonOffset: d,
            setScissorTest: function(e) {
                e ? a(3089) : l(3089)
            },
            activeTexture: p,
            bindTexture: function(t, i) {
                null === U && p();
                var n = H[U];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, H[U] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || V[t]), n.type = t, n.texture = i)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === G.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), G.copy(t))
            },
            viewport: function(t) {
                !1 === j.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), j.copy(t))
            },
            reset: function() {
                for (var t = 0; t < b.length; t++) 1 === b[t] && (e.disableVertexAttribArray(t), b[t] = 0);
                w = {}, U = _ = null, H = {}, I = O = T = E = null, f.reset(), m.reset(), g.reset()
            }
        }
    }

    function vt(e, t, i, n, r, o, a) {
        function s(e, t) {
            return A ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function l(e, t, i, n) {
            var r = 1;
            if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), 1 > r || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (n = t ? fo.floorPowerOfTwo : Math.floor)(r * e.width), r = n(r * e.height), void 0 === T && (T = s(t, r)), (i = i ? s(t, r) : T).width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + r + ")."), i;
                "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
            }
            return e
        }

        function c(e) {
            return fo.isPowerOfTwo(e.width) && fo.isPowerOfTwo(e.height)
        }

        function h(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }

        function u(t, i, r, o) {
            e.generateMipmap(t), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }

        function d(e, i) {
            if (!r.isWebGL2) return e;
            var n = e;
            return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
        }

        function p(e) {
            return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
        }

        function f(t) {
            (t = t.target).removeEventListener("dispose", f);
            var i = n.get(t);
            void 0 !== i.__webglInit && (e.deleteTexture(i.__webglTexture), n.remove(t)), t.isVideoTexture && delete S[t.id], a.memory.textures--
        }

        function m(t) {
            (t = t.target).removeEventListener("dispose", m);
            var i = n.get(t),
                r = n.get(t.texture);
            if (t) {
                if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                    for (r = 0; 6 > r; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(t.texture), n.remove(t)
            }
            a.memory.textures--
        }

        function g(e, t) {
            var r = n.get(e);
            if (e.isVideoTexture) {
                var o = e.id,
                    s = a.render.frame;
                S[o] !== s && (S[o] = s, e.update())
            }
            if (0 < e.version && r.__version !== e.version)
                if (void 0 === (o = e.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void w(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                } i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture)
        }

        function v(t, a) {
            var s = n.get(t);
            if (6 === t.image.length)
                if (0 < t.version && s.__version !== t.version) {
                    x(s, t), i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture), e.pixelStorei(37440, t.flipY), a = t && t.isCompressedTexture;
                    for (var p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; 6 > m; m++) f[m] = a || p ? p ? t.image[m].image : t.image[m] : l(t.image[m], !1, !0, r.maxCubemapSize);
                    var g = f[0],
                        v = c(g) || r.isWebGL2,
                        y = o.convert(t.format),
                        w = o.convert(t.type),
                        _ = d(y, w);
                    for (b(34067, t, v), m = 0; 6 > m; m++)
                        if (a)
                            for (var E, M = f[m].mipmaps, T = 0, S = M.length; T < S; T++) E = M[T], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, T, _, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, T, _, E.width, E.height, 0, y, w, E.data);
                        else p ? i.texImage2D(34069 + m, 0, _, f[m].width, f[m].height, 0, y, w, f[m].data) : i.texImage2D(34069 + m, 0, _, y, w, f[m]);
                    s.__maxMipLevel = a ? M.length - 1 : 0, h(t, v) && u(34067, t, g.width, g.height), s.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture)
        }

        function y(e, t) {
            i.activeTexture(33984 + t), i.bindTexture(34067, n.get(e).__webglTexture)
        }

        function b(i, a, s) {
            s ? (e.texParameteri(i, 10242, o.convert(a.wrapS)), e.texParameteri(i, 10243, o.convert(a.wrapT)), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, o.convert(a.wrapR)), e.texParameteri(i, 10240, o.convert(a.magFilter)), e.texParameteri(i, 10241, o.convert(a.minFilter))) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, p(a.magFilter)), e.texParameteri(i, 10241, p(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(s = t.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === t.get("OES_texture_float_linear") || 1016 === a.type && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear")) || !(1 < a.anisotropy || n.get(a).__currentAnisotropy) || (e.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
        }

        function x(t, i) {
            void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), a.memory.textures++)
        }

        function w(t, n, a) {
            var s = 3553;
            n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), x(t, n), i.activeTexture(33984 + a), i.bindTexture(s, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), a = (a = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === c(n.image);
            var p = c(a = l(n.image, a, !1, r.maxTextureSize)) || r.isWebGL2,
                f = o.convert(n.format),
                m = o.convert(n.type),
                g = d(f, m);
            b(s, n, p);
            var v = n.mipmaps;
            if (n.isDepthTexture) {
                if (g = 6402, 1015 === n.type) {
                    if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                    g = 36012
                } else r.isWebGL2 && (g = 33189);
                1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, null)
            } else if (n.isDataTexture)
                if (0 < v.length && p) {
                    for (var y = 0, w = v.length; y < w; y++) s = v[y], i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                    n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
                } else i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (y = 0, w = v.length; y < w; y++) s = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                t.__maxMipLevel = v.length - 1
            } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (0 < v.length && p) {
                for (y = 0, w = v.length; y < w; y++) s = v[y], i.texImage2D(3553, y, g, f, m, s);
                n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
            } else i.texImage2D(3553, 0, g, f, m, a), t.__maxMipLevel = 0;
            h(n, p) && u(3553, n, a.width, a.height), t.__version = n.version, n.onUpdate && n.onUpdate(n)
        }

        function _(t, r, a, s) {
            var l = o.convert(r.texture.format),
                c = o.convert(r.texture.type),
                h = d(l, c);
            i.texImage2D(s, 0, h, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, s, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
        }

        function E(t, i, n) {
            if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : e.renderbufferStorage(36161, 33189, i.width, i.height), e.framebufferRenderbuffer(36160, 36096, 36161, t);
            else if (i.depthBuffer && i.stencilBuffer) n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t);
            else {
                t = d(t = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, t, i.width, i.height)) : e.renderbufferStorage(36161, t, i.width, i.height)
            }
            e.bindRenderbuffer(36161, null)
        }

        function M(e) {
            return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
        }
        var T, S = {},
            A = "undefined" != typeof OffscreenCanvas,
            C = 0,
            L = !1,
            D = !1;
        this.allocateTextureUnit = function() {
            var e = C;
            return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), C += 1, e
        }, this.resetTextureUnits = function() {
            C = 0
        }, this.setTexture2D = g, this.setTexture2DArray = function(e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function(e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(t) {
            var s = n.get(t),
                l = n.get(t.texture);
            t.addEventListener("dispose", m), l.__webglTexture = e.createTexture(), a.memory.textures++;
            var p = !0 === t.isWebGLRenderTargetCube,
                f = !0 === t.isWebGLMultisampleRenderTarget,
                v = c(t) || r.isWebGL2;
            if (p)
                for (s.__webglFramebuffer = [], f = 0; 6 > f; f++) s.__webglFramebuffer[f] = e.createFramebuffer();
            else if (s.__webglFramebuffer = e.createFramebuffer(), f)
                if (r.isWebGL2) {
                    s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, s.__webglColorRenderbuffer), f = o.convert(t.texture.format);
                    var y = o.convert(t.texture.type);
                    f = d(f, y), y = M(t), e.renderbufferStorageMultisample(36161, y, f, t.width, t.height), e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), E(s.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (p) {
                for (i.bindTexture(34067, l.__webglTexture), b(34067, t.texture, v), f = 0; 6 > f; f++) _(s.__webglFramebuffer[f], t, 36064, 34069 + f);
                h(t.texture, v) && u(34067, t.texture, t.width, t.height), i.bindTexture(34067, null)
            } else i.bindTexture(3553, l.__webglTexture), b(3553, t.texture, v), _(s.__webglFramebuffer, t, 36064, 3553), h(t.texture, v) && u(3553, t.texture, t.width, t.height), i.bindTexture(3553, null);
            if (t.depthBuffer) {
                if (s = n.get(t), l = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
                    if (l) throw Error("target.depthTexture not supported in Cube render targets");
                    if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, s.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (n.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), s = n.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                    else {
                        if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                } else if (l)
                    for (s.__webglDepthbuffer = [], l = 0; 6 > l; l++) e.bindFramebuffer(36160, s.__webglFramebuffer[l]), s.__webglDepthbuffer[l] = e.createRenderbuffer(), E(s.__webglDepthbuffer[l], t);
                else e.bindFramebuffer(36160, s.__webglFramebuffer), s.__webglDepthbuffer = e.createRenderbuffer(), E(s.__webglDepthbuffer, t);
                e.bindFramebuffer(36160, null)
            }
        }, this.updateRenderTargetMipmap = function(e) {
            var t = e.texture,
                o = c(e) || r.isWebGL2;
            if (h(t, o)) {
                o = e.isWebGLRenderTargetCube ? 34067 : 3553;
                var a = n.get(t).__webglTexture;
                i.bindTexture(o, a), u(o, t, e.width, e.height), i.bindTexture(o, null)
            }
        }, this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (r.isWebGL2) {
                    var i = n.get(t);
                    e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer), i = t.width;
                    var o = t.height,
                        a = 16384;
                    t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024), e.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === L && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), L = !0), e = e.texture), g(e, t)
        }, this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === D && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), D = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t)
        }
    }

    function yt(e, t, i) {
        return {
            convert: function(e) {
                if (1e3 === e) return 10497;
                if (1001 === e) return 33071;
                if (1002 === e) return 33648;
                if (1003 === e) return 9728;
                if (1004 === e) return 9984;
                if (1005 === e) return 9986;
                if (1006 === e) return 9729;
                if (1007 === e) return 9985;
                if (1008 === e) return 9987;
                if (1009 === e) return 5121;
                if (1017 === e) return 32819;
                if (1018 === e) return 32820;
                if (1019 === e) return 33635;
                if (1010 === e) return 5120;
                if (1011 === e) return 5122;
                if (1012 === e) return 5123;
                if (1013 === e) return 5124;
                if (1014 === e) return 5125;
                if (1015 === e) return 5126;
                if (1016 === e) {
                    if (i.isWebGL2) return 5131;
                    var n = t.get("OES_texture_half_float");
                    if (null !== n) return n.HALF_FLOAT_OES
                }
                if (1021 === e) return 6406;
                if (1022 === e) return 6407;
                if (1023 === e) return 6408;
                if (1024 === e) return 6409;
                if (1025 === e) return 6410;
                if (1026 === e) return 6402;
                if (1027 === e) return 34041;
                if (1028 === e) return 6403;
                if (100 === e) return 32774;
                if (101 === e) return 32778;
                if (102 === e) return 32779;
                if (200 === e) return 0;
                if (201 === e) return 1;
                if (202 === e) return 768;
                if (203 === e) return 769;
                if (204 === e) return 770;
                if (205 === e) return 771;
                if (206 === e) return 772;
                if (207 === e) return 773;
                if (208 === e) return 774;
                if (209 === e) return 775;
                if (210 === e) return 776;
                if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e && null !== (n = t.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (n = t.get("WEBGL_compressed_texture_astc"))) return e;
                if (103 === e || 104 === e) {
                    if (i.isWebGL2) {
                        if (103 === e) return 32775;
                        if (104 === e) return 32776
                    }
                    if (null !== (n = t.get("EXT_blend_minmax"))) {
                        if (103 === e) return n.MIN_EXT;
                        if (104 === e) return n.MAX_EXT
                    }
                }
                if (1020 === e) {
                    if (i.isWebGL2) return 34042;
                    if (null !== (n = t.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function bt() {
        T.call(this), this.type = "Group"
    }

    function xt() {
        T.call(this), this.type = "Camera", this.matrixWorldInverse = new g, this.projectionMatrix = new g, this.projectionMatrixInverse = new g
    }

    function wt(e, t, i, n) {
        xt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function _t(e) {
        wt.call(this), this.cameras = e || []
    }

    function Et(e, t, i) {
        Uo.setFromMatrixPosition(t.matrixWorld), Ho.setFromMatrixPosition(i.matrixWorld);
        var n = Uo.distanceTo(Ho),
            r = t.projectionMatrix.elements,
            o = i.projectionMatrix.elements,
            a = r[14] / (r[10] - 1);
        i = r[14] / (r[10] + 1);
        var s = (r[9] + 1) / r[5],
            l = (r[9] - 1) / r[5],
            c = (r[8] - 1) / r[0],
            h = (o[8] + 1) / o[0];
        r = a * c, o = a * h, c = (h = n / (-c + h)) * -c, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(c), e.translateZ(h), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld), t = a + h, a = i + h, e.projectionMatrix.makePerspective(r - c, o + (n - c), s * i / a * t, l * i / a * t, t, a)
    }

    function Mt(e) {
        function t() {
            return null !== u && !0 === u.isPresenting
        }

        function o() {
            if (t()) {
                var i = u.getEyeParameters("left");
                l = 2 * i.renderWidth * y, c = i.renderHeight * y, A = e.getPixelRatio(), e.getSize(C), e.setDrawingBufferSize(l, c, 1), M.viewport.set(0, 0, l / 2, c), T.viewport.set(l / 2, 0, l / 2, c), D.start()
            } else h.enabled && e.setDrawingBufferSize(C.width, C.height, A), D.stop()
        }

        function a(e, t) {
            null !== t && 4 === t.length && e.set(t[0] * l, t[1] * c, t[2] * l, t[3] * c)
        }
        var l, c, h = this,
            u = null,
            d = null,
            p = null,
            f = [],
            m = new g,
            v = new g,
            y = 1,
            b = "local-floor";
        "undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
        var w = new g,
            _ = new n,
            E = new r,
            M = new wt;
        M.viewport = new s, M.layers.enable(1);
        var T = new wt;
        T.viewport = new s, T.layers.enable(2);
        var S = new _t([M, T]);
        S.layers.enable(1), S.layers.enable(2);
        var A, C = new i,
            L = [];
        this.enabled = !1, this.getController = function(e) {
            var t = f[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
        }, this.getDevice = function() {
            return u
        }, this.setDevice = function(e) {
            void 0 !== e && (u = e), D.setContext(e)
        }, this.setFramebufferScaleFactor = function(e) {
            y = e
        }, this.setReferenceSpaceType = function(e) {
            b = e
        }, this.setPoseTarget = function(e) {
            void 0 !== e && (p = e)
        }, this.getCamera = function(e) {
            var i = "local-floor" === b ? 1.6 : 0;
            if (!1 === t()) return e.position.set(0, i, 0), e.rotation.set(0, 0, 0), e;
            if (u.depthNear = e.near, u.depthFar = e.far, u.getFrameData(d), "local-floor" === b) {
                var n = u.stageParameters;
                n ? m.fromArray(n.sittingToStandingTransform) : m.makeTranslation(0, i, 0)
            }
            i = d.pose, (n = null !== p ? p : e).matrix.copy(m), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (_.fromArray(i.orientation), n.quaternion.multiply(_)), null !== i.position && (_.setFromRotationMatrix(m), E.fromArray(i.position), E.applyQuaternion(_), n.position.add(E)), n.updateMatrixWorld(), M.near = e.near, T.near = e.near, M.far = e.far, T.far = e.far, M.matrixWorldInverse.fromArray(d.leftViewMatrix), T.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "local-floor" === b && (M.matrixWorldInverse.multiply(v), T.matrixWorldInverse.multiply(v)), null !== (e = n.parent) && (w.getInverse(e.matrixWorld), M.matrixWorldInverse.multiply(w), T.matrixWorldInverse.multiply(w)), M.matrixWorld.getInverse(M.matrixWorldInverse), T.matrixWorld.getInverse(T.matrixWorldInverse), M.projectionMatrix.fromArray(d.leftProjectionMatrix), T.projectionMatrix.fromArray(d.rightProjectionMatrix), Et(S, M, T), (e = u.getLayers()).length && (e = e[0], a(M.viewport, e.leftBounds), a(T.viewport, e.rightBounds));
            e: for (e = 0; e < f.length; e++) {
                i = f[e];
                t: {
                    n = e;
                    for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, s = 0, l = r.length; o < l; o++) {
                        var c = r[o];
                        if (c && ("Daydream Controller" === c.id || "Gear VR Controller" === c.id || "Oculus Go Controller" === c.id || "OpenVR Gamepad" === c.id || c.id.startsWith("Oculus Touch") || c.id.startsWith("Spatial Controller"))) {
                            if (s === n) {
                                n = c;
                                break t
                            }
                            s++
                        }
                    }
                    n = void 0
                }
                if (void 0 !== n && void 0 !== n.pose) {
                    if (null === n.pose) break e;
                    !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(m), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === L[e] && (L[e] = !1), L[e] !== n.buttons[r].pressed && (L[e] = n.buttons[r].pressed, !0 === L[e] ? i.dispatchEvent({
                        type: "selectstart"
                    }) : (i.dispatchEvent({
                        type: "selectend"
                    }), i.dispatchEvent({
                        type: "select"
                    })))
                } else i.visible = !1
            }
            return S
        }, this.getStandingMatrix = function() {
            return m
        }, this.isPresenting = t;
        var D = new x;
        this.setAnimationLoop = function(e) {
            D.setAnimationLoop(e), t() && D.start()
        }, this.submitFrame = function() {
            t() && u.submitFrame()
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
        }
    }

    function Tt(e) {
        function t() {
            return null !== l && null !== c
        }

        function i(e) {
            for (var t = 0; t < d.length; t++) p[t] === e.inputSource && d[t].dispatchEvent({
                type: e.type
            })
        }

        function n() {
            e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), b.stop()
        }

        function r(e) {
            c = e, b.setContext(l), b.start()
        }

        function o(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        var a = e.context,
            l = null,
            c = null,
            h = "local-floor",
            u = null,
            d = [],
            p = [],
            f = new wt;
        f.layers.enable(1), f.viewport = new s;
        var m = new wt;
        m.layers.enable(2), m.viewport = new s;
        var v = new _t([f, m]);
        v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function(e) {
            var t = d[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, d[e] = t), t
        }, this.setFramebufferScaleFactor = function(e) {}, this.setReferenceSpaceType = function(e) {
            h = e
        }, this.setSession = function(e) {
            null !== (l = e) && (l.addEventListener("select", i), l.addEventListener("selectstart", i), l.addEventListener("selectend", i), l.addEventListener("end", n), l.updateRenderState({
                baseLayer: new XRWebGLLayer(l, a)
            }), l.requestReferenceSpace(h).then(r), p = l.inputSources, l.addEventListener("inputsourceschange", (function() {
                p = l.inputSources, console.log(p);
                for (var e = 0; e < d.length; e++) d[e].userData.inputSource = p[e]
            })))
        }, this.getCamera = function(e) {
            if (t()) {
                var i = e.parent,
                    n = v.cameras;
                o(v, i);
                for (var r = 0; r < n.length; r++) o(n[r], i);
                for (e.matrixWorld.copy(v.matrixWorld), r = 0, i = (e = e.children).length; r < i; r++) e[r].updateMatrixWorld(!0);
                return Et(v, f, m), v
            }
            return e
        }, this.isPresenting = t;
        var y = null,
            b = new x;
        b.setAnimationLoop((function(t, i) {
            if (null !== (u = i.getViewerPose(c))) {
                var n = u.views,
                    r = l.renderState.baseLayer;
                e.setFramebuffer(r.framebuffer);
                for (var o = 0; o < n.length; o++) {
                    var a = n[o],
                        s = r.getViewport(a),
                        h = v.cameras[o];
                    h.matrix.fromArray(a.transform.inverse.matrix).getInverse(h.matrix), h.projectionMatrix.fromArray(a.projectionMatrix), h.viewport.set(s.x, s.y, s.width, s.height), 0 === o && v.matrix.copy(h.matrix)
                }
            }
            for (o = 0; o < d.length; o++) n = d[o], (r = p[o]) && null !== (r = i.getPose(r.targetRaySpace, c)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
            y && y(t)
        })), this.setAnimationLoop = function(e) {
            y = e
        }, this.dispose = function() {}, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new g
        }, this.getDevice = function() {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
        }, this.setDevice = function() {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
        }, this.submitFrame = function() {}
    }

    function St(e) {
        var t;

        function n() {
            N = new ee(Ne), (B = new $(Ne, N, e)).isWebGL2 || (N.get("WEBGL_depth_texture"), N.get("OES_texture_float"), N.get("OES_texture_half_float"), N.get("OES_texture_half_float_linear"), N.get("OES_standard_derivatives"), N.get("OES_element_index_uint"), N.get("ANGLE_instanced_arrays")), N.get("OES_texture_float_linear"), le = new yt(Ne, N, B), (F = new gt(Ne, N, le, B)).scissor(_e.copy(Ce).multiplyScalar(Se)), F.viewport(we.copy(Ae).multiplyScalar(Se)), k = new ne(Ne), U = new rt, H = new vt(Ne, N, F, U, B, le, k), G = new w(Ne), j = new te(Ne, G, k), V = new ae(j, k), Z = new oe(Ne), W = new nt(ce, N, B, H), q = new lt, X = new dt, Y = new J(ce, F, V, D), re = new Q(Ne, N, k, B), se = new ie(Ne, N, k, B), k.programs = W.programs, ce.context = Ne, ce.capabilities = B, ce.extensions = N, ce.properties = U, ce.renderLists = q, ce.state = F, ce.info = k
        }

        function o(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), he = !0
        }

        function a() {
            console.log("THREE.WebGLRenderer: Context Restored."), he = !1, n()
        }

        function l(e) {
            (e = e.target).removeEventListener("dispose", l), c(e), U.remove(e)
        }

        function c(e) {
            var t = U.get(e).program;
            e.program = void 0, void 0 !== t && W.releaseProgram(t)
        }

        function h(e, t, i, n) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isGroup) i = e.renderOrder;
                    else if (e.isLight) z.pushLight(e), e.castShadow && z.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || De.intersectsSprite(e)) {
                        n && ze.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Ie);
                        var r = V.update(e),
                            o = e.material;
                        o.visible && I.push(e, r, o, i, ze.z, null)
                    }
                } else if (e.isImmediateRenderObject) n && ze.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Ie), I.push(e, null, e.material, i, ze.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || De.intersectsObject(e)))
                    if (n && ze.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Ie), r = V.update(e), o = e.material, Array.isArray(o))
                        for (var a = r.groups, s = 0, l = a.length; s < l; s++) {
                            var c = a[s],
                                u = o[c.materialIndex];
                            u && u.visible && I.push(e, r, u, i, ze.z, c)
                        } else o.visible && I.push(e, r, o, i, ze.z, null);
                for (s = 0, l = (e = e.children).length; s < l; s++) h(e[s], t, i, n)
            }
        }

        function d(e, t, i, n) {
            for (var r = 0, o = e.length; r < o; r++) {
                var a = e[r],
                    s = a.object,
                    l = a.geometry,
                    c = void 0 === n ? a.material : n;
                if (a = a.group, i.isArrayCamera) {
                    xe = i;
                    for (var h = i.cameras, u = 0, d = h.length; u < d; u++) {
                        var f = h[u];
                        s.layers.test(f.layers) && (F.viewport(we.copy(f.viewport)), z.setupLights(f), p(s, t, f, l, c, a))
                    }
                } else xe = null, p(s, t, i, l, c, a)
            }
        }

        function p(e, i, n, r, o, a) {
            if (e.onBeforeRender(ce, i, n, r, o, a), z = X.get(i, xe || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                F.setMaterial(o);
                var s = y(n, i.fog, o, e);
                ve = t = null, ye = !1,
                    function(e, t) {
                        e.render((function(e) {
                            ce.renderBufferImmediate(e, t)
                        }))
                    }(e, s)
            } else ce.renderBufferDirect(n, i.fog, r, o, e, a);
            e.onAfterRender(ce, i, n, r, o, a), z = X.get(i, xe || n)
        }

        function f(e, t, i) {
            var n = U.get(e),
                r = z.state.lights,
                o = n.lightsHash,
                a = r.state.hash;
            i = W.getParameters(e, r.state, z.state.shadowsArray, t, Pe.numPlanes, Pe.numIntersection, i);
            var s = W.getProgramCode(e, i),
                h = n.program,
                u = !0;
            if (void 0 === h) e.addEventListener("dispose", l);
            else if (h.code !== s) c(e);
            else {
                if (o.stateID !== a.stateID || o.directionalLength !== a.directionalLength || o.pointLength !== a.pointLength || o.spotLength !== a.spotLength || o.rectAreaLength !== a.rectAreaLength || o.hemiLength !== a.hemiLength || o.shadowsLength !== a.shadowsLength) o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength;
                else if (void 0 !== i.shaderID) return;
                u = !1
            }
            if (u && (i.shaderID ? (s = _o[i.shaderID], n.shader = {
                    name: e.type,
                    uniforms: v(s.uniforms),
                    vertexShader: s.vertexShader,
                    fragmentShader: s.fragmentShader
                }) : n.shader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                }, e.onBeforeCompile(n.shader, ce), s = W.getProgramCode(e, i), h = W.acquireProgram(e, n.shader, i, s), n.program = h, e.program = h), i = h.getAttributes(), e.morphTargets)
                for (s = e.numSupportedMorphTargets = 0; s < ce.maxMorphTargets; s++) 0 <= i["morphTarget" + s] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (s = e.numSupportedMorphNormals = 0; s < ce.maxMorphNormals; s++) 0 <= i["morphNormal" + s] && e.numSupportedMorphNormals++;
            i = n.shader.uniforms, (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = Pe.numPlanes, n.numIntersection = Pe.numIntersection, i.clippingPlanes = Pe.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength, e.lights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), e = n.program.getUniforms(), e = We.seqWithValue(e.seq, i), n.uniformsList = e
        }

        function y(e, t, i, n) {
            H.resetTextureUnits();
            var r = U.get(i),
                o = r.lightsHash,
                a = z.state.lights.state.hash;
            Re && (Oe || e !== be) && Pe.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, e === be && i.id === ge), !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === a.stateID && o.directionalLength === a.directionalLength && o.pointLength === a.pointLength && o.spotLength === a.spotLength && o.rectAreaLength === a.rectAreaLength && o.hemiLength === a.hemiLength && o.shadowsLength === a.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Pe.numPlanes && r.numIntersection === Pe.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (f(i, t, n), i.needsUpdate = !1);
            var s = !1,
                l = !1,
                c = !1;
            a = (o = r.program).getUniforms();
            var h = r.shader.uniforms;
            if (F.useProgram(o.program) && (c = l = s = !0), i.id !== ge && (ge = i.id, l = !0), (s || be !== e) && (a.setValue(Ne, "projectionMatrix", e.projectionMatrix), B.logarithmicDepthBuffer && a.setValue(Ne, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), be !== e && (be = e, c = l = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (void 0 !== (s = a.map.cameraPosition) && s.setValue(Ne, ze.setFromMatrixPosition(e.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && a.setValue(Ne, "viewMatrix", e.matrixWorldInverse)), i.skinning && (a.setOptional(Ne, n, "bindMatrix"), a.setOptional(Ne, n, "bindMatrixInverse"), e = n.skeleton))
                if (s = e.bones, B.floatVertexTextures) {
                    if (void 0 === e.boneTexture) {
                        s = Math.sqrt(4 * s.length), s = fo.ceilPowerOfTwo(s), s = Math.max(s, 4);
                        var d = new Float32Array(s * s * 4);
                        d.set(e.boneMatrices);
                        var p = new u(d, s, s, 1023, 1015);
                        p.needsUpdate = !0, e.boneMatrices = d, e.boneTexture = p, e.boneTextureSize = s
                    }
                    a.setValue(Ne, "boneTexture", e.boneTexture, H), a.setValue(Ne, "boneTextureSize", e.boneTextureSize)
                } else a.setOptional(Ne, e, "boneMatrices");
            return l && (a.setValue(Ne, "toneMappingExposure", ce.toneMappingExposure), a.setValue(Ne, "toneMappingWhitePoint", ce.toneMappingWhitePoint), i.lights && (l = c, h.ambientLightColor.needsUpdate = l, h.lightProbe.needsUpdate = l, h.directionalLights.needsUpdate = l, h.pointLights.needsUpdate = l, h.spotLights.needsUpdate = l, h.rectAreaLights.needsUpdate = l, h.hemisphereLights.needsUpdate = l), t && i.fog && (h.fogColor.value.copy(t.color), t.isFog ? (h.fogNear.value = t.near, h.fogFar.value = t.far) : t.isFogExp2 && (h.fogDensity.value = t.density)), i.isMeshBasicMaterial ? b(h, i) : i.isMeshLambertMaterial ? (b(h, i), i.emissiveMap && (h.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (b(h, i), i.isMeshToonMaterial ? (_(h, i), i.gradientMap && (h.gradientMap.value = i.gradientMap)) : _(h, i)) : i.isMeshStandardMaterial ? (b(h, i), i.isMeshPhysicalMaterial ? (E(h, i), h.reflectivity.value = i.reflectivity, h.clearCoat.value = i.clearCoat, h.clearCoatRoughness.value = i.clearCoatRoughness) : E(h, i)) : i.isMeshMatcapMaterial ? (b(h, i), i.matcap && (h.matcap.value = i.matcap), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (b(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (b(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias), h.referencePosition.value.copy(i.referencePosition), h.nearDistance.value = i.nearDistance, h.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (b(h, i), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, i.isLineDashedMaterial && (h.dashSize.value = i.dashSize, h.totalSize.value = i.dashSize + i.gapSize, h.scale.value = i.scale)) : i.isPointsMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.size.value = i.size * Se, h.scale.value = .5 * Te, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.rotation.value = i.rotation, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (h.color.value.copy(i.color), h.opacity.value = i.opacity), void 0 !== h.ltc_1 && (h.ltc_1.value = wo.LTC_1), void 0 !== h.ltc_2 && (h.ltc_2.value = wo.LTC_2), We.upload(Ne, r.uniformsList, h, H)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (We.upload(Ne, r.uniformsList, h, H), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && a.setValue(Ne, "center", n.center), a.setValue(Ne, "modelViewMatrix", n.modelViewMatrix), a.setValue(Ne, "normalMatrix", n.normalMatrix), a.setValue(Ne, "modelMatrix", n.matrixWorld), o
        }

        function b(e, t) {
            if (e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = U.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map) var i = t.map;
            else t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap);
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
        }

        function _(e, t) {
            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function E(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        console.log("THREE.WebGLRenderer", "105");
        var M = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            T = void 0 !== e.context ? e.context : null,
            S = void 0 !== e.alpha && e.alpha,
            A = void 0 === e.depth || e.depth,
            C = void 0 === e.stencil || e.stencil,
            L = void 0 !== e.antialias && e.antialias,
            D = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            P = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            R = void 0 !== e.powerPreference ? e.powerPreference : "default",
            O = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            I = null,
            z = null;
        this.domElement = M, this.context = null, this.debug = {
            checkShaderErrors: !0
        }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var N, B, F, k, U, H, G, j, V, W, q, X, Y, Z, re, se, le, ce = this,
            he = !1,
            ue = null,
            de = 0,
            pe = 0,
            fe = null,
            me = null,
            ge = -1,
            ve = t = null,
            ye = !1,
            be = null,
            xe = null,
            we = new s,
            _e = new s,
            Ee = null,
            Me = M.width,
            Te = M.height,
            Se = 1,
            Ae = new s(0, 0, Me, Te),
            Ce = new s(0, 0, Me, Te),
            Le = !1,
            De = new m,
            Pe = new K,
            Re = !1,
            Oe = !1,
            Ie = new g,
            ze = new r;
        try {
            S = {
                alpha: S,
                depth: A,
                stencil: C,
                antialias: L,
                premultipliedAlpha: D,
                preserveDrawingBuffer: P,
                powerPreference: R,
                failIfMajorPerformanceCaveat: O,
                xrCompatible: !0
            }, M.addEventListener("webglcontextlost", o, !1), M.addEventListener("webglcontextrestored", a, !1);
            var Ne = T || M.getContext("webgl", S) || M.getContext("experimental-webgl", S);
            if (null === Ne) {
                if (null !== M.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === Ne.getShaderPrecisionFormat && (Ne.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }
        n();
        var Be = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Tt(ce) : new Mt(ce);
        this.vr = Be;
        var Fe = new mt(ce, V, B.maxTextureSize);
        this.shadowMap = Fe, this.getContext = function() {
            return Ne
        }, this.getContextAttributes = function() {
            return Ne.getContextAttributes()
        }, this.forceContextLoss = function() {
            var e = N.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function() {
            var e = N.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function() {
            return Se
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (Se = e, this.setSize(Me, Te, !1))
        }, this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new i), e.set(Me, Te)
        }, this.setSize = function(e, t, i) {
            Be.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Me = e, Te = t, M.width = e * Se, M.height = t * Se, !1 !== i && (M.style.width = e + "px", M.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new i), e.set(Me * Se, Te * Se)
        }, this.setDrawingBufferSize = function(e, t, i) {
            Me = e, Te = t, Se = i, M.width = e * i, M.height = t * i, this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new s), e.copy(we)
        }, this.getViewport = function(e) {
            return e.copy(Ae)
        }, this.setViewport = function(e, t, i, n) {
            e.isVector4 ? Ae.set(e.x, e.y, e.z, e.w) : Ae.set(e, t, i, n), F.viewport(we.copy(Ae).multiplyScalar(Se))
        }, this.getScissor = function(e) {
            return e.copy(Ce)
        }, this.setScissor = function(e, t, i, n) {
            e.isVector4 ? Ce.set(e.x, e.y, e.z, e.w) : Ce.set(e, t, i, n), F.scissor(_e.copy(Ce).multiplyScalar(Se))
        }, this.getScissorTest = function() {
            return Le
        }, this.setScissorTest = function(e) {
            F.setScissorTest(Le = e)
        }, this.getClearColor = function() {
            return Y.getClearColor()
        }, this.setClearColor = function() {
            Y.setClearColor.apply(Y, arguments)
        }, this.getClearAlpha = function() {
            return Y.getClearAlpha()
        }, this.setClearAlpha = function() {
            Y.setClearAlpha.apply(Y, arguments)
        }, this.clear = function(e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), Ne.clear(n)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            M.removeEventListener("webglcontextlost", o, !1), M.removeEventListener("webglcontextrestored", a, !1), q.dispose(), X.dispose(), U.dispose(), V.dispose(), Be.dispose(), Ue.stop()
        }, this.renderBufferImmediate = function(e, t) {
            F.initAttributes();
            var i = U.get(e);
            e.hasPositions && !i.position && (i.position = Ne.createBuffer()), e.hasNormals && !i.normal && (i.normal = Ne.createBuffer()), e.hasUvs && !i.uv && (i.uv = Ne.createBuffer()), e.hasColors && !i.color && (i.color = Ne.createBuffer()), t = t.getAttributes(), e.hasPositions && (Ne.bindBuffer(34962, i.position), Ne.bufferData(34962, e.positionArray, 35048), F.enableAttribute(t.position), Ne.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (Ne.bindBuffer(34962, i.normal), Ne.bufferData(34962, e.normalArray, 35048), F.enableAttribute(t.normal), Ne.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (Ne.bindBuffer(34962, i.uv), Ne.bufferData(34962, e.uvArray, 35048), F.enableAttribute(t.uv), Ne.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (Ne.bindBuffer(34962, i.color), Ne.bufferData(34962, e.colorArray, 35048), F.enableAttribute(t.color), Ne.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), F.disableUnusedAttributes(), Ne.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, i, n, r, o, a) {
            var s = o.isMesh && 0 > o.matrixWorld.determinant();
            F.setMaterial(r, s);
            var l = y(e, i, r, o),
                c = !1;
            t === n.id && ve === l.id && ye === (!0 === r.wireframe) || (t = n.id, ve = l.id, ye = !0 === r.wireframe, c = !0), o.morphTargetInfluences && (Z.update(o, n, r, l), c = !0), s = n.index;
            var h = n.attributes.position;
            if (i = 1, !0 === r.wireframe && (s = j.getWireframeAttribute(n), i = 2), e = re, null !== s) {
                var u = G.get(s);
                (e = se).setIndex(u)
            }
            if (c) {
                if (n && n.isInstancedBufferGeometry && !B.isWebGL2 && null === N.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    F.initAttributes(), c = n.attributes, l = l.getAttributes();
                    var d = r.defaultAttributeValues;
                    for (E in l) {
                        var p = l[E];
                        if (0 <= p) {
                            var f = c[E];
                            if (void 0 !== f) {
                                var m = f.normalized,
                                    g = f.itemSize,
                                    v = G.get(f);
                                if (void 0 !== v) {
                                    var b = v.buffer,
                                        x = v.type;
                                    if (v = v.bytesPerElement, f.isInterleavedBufferAttribute) {
                                        var w = f.data,
                                            _ = w.stride;
                                        f = f.offset, w && w.isInstancedInterleavedBuffer ? (F.enableAttributeAndDivisor(p, w.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : F.enableAttribute(p), Ne.bindBuffer(34962, b), Ne.vertexAttribPointer(p, g, x, m, _ * v, f * v)
                                    } else f.isInstancedBufferAttribute ? (F.enableAttributeAndDivisor(p, f.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = f.meshPerAttribute * f.count)) : F.enableAttribute(p), Ne.bindBuffer(34962, b), Ne.vertexAttribPointer(p, g, x, m, 0, 0)
                                }
                            } else if (void 0 !== d && void 0 !== (m = d[E])) switch (m.length) {
                                case 2:
                                    Ne.vertexAttrib2fv(p, m);
                                    break;
                                case 3:
                                    Ne.vertexAttrib3fv(p, m);
                                    break;
                                case 4:
                                    Ne.vertexAttrib4fv(p, m);
                                    break;
                                default:
                                    Ne.vertexAttrib1fv(p, m)
                            }
                        }
                    }
                    F.disableUnusedAttributes()
                }
                null !== s && Ne.bindBuffer(34963, u.buffer)
            }
            u = 1 / 0, null !== s ? u = s.count : void 0 !== h && (u = h.count), s = n.drawRange.start * i, h = null !== a ? a.start * i : 0;
            var E = Math.max(s, h);
            if (0 !== (a = Math.max(0, Math.min(u, s + n.drawRange.count * i, h + (null !== a ? a.count * i : 1 / 0)) - 1 - E + 1))) {
                if (o.isMesh)
                    if (!0 === r.wireframe) F.setLineWidth(r.wireframeLinewidth * (null === fe ? Se : 1)), e.setMode(1);
                    else switch (o.drawMode) {
                        case 0:
                            e.setMode(4);
                            break;
                        case 1:
                            e.setMode(5);
                            break;
                        case 2:
                            e.setMode(6)
                    } else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), F.setLineWidth(r * (null === fe ? Se : 1)), o.isLineSegments ? e.setMode(1) : o.isLineLoop ? e.setMode(2) : e.setMode(3)) : o.isPoints ? e.setMode(0) : o.isSprite && e.setMode(4);
                n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && e.renderInstances(n, E, a) : e.render(E, a)
            }
        }, this.compile = function(e, t) {
            (z = X.get(e, t)).init(), e.traverse((function(e) {
                e.isLight && (z.pushLight(e), e.castShadow && z.pushShadow(e))
            })), z.setupLights(t), e.traverse((function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var i = 0; i < t.material.length; i++) f(t.material[i], e.fog, t);
                    else f(t.material, e.fog, t)
            }))
        };
        var ke = null,
            Ue = new x;
        Ue.setAnimationLoop((function(e) {
            Be.isPresenting() || ke && ke(e)
        })), "undefined" != typeof window && Ue.setContext(window), this.setAnimationLoop = function(e) {
            ke = e, Be.setAnimationLoop(e), Ue.start()
        }, this.render = function(e, i, n, r) {
            if (void 0 !== n) {
                console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                var o = n
            }
            if (void 0 !== r) {
                console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                var a = r
            }
            i && i.isCamera ? he || (ve = t = null, ye = !1, ge = -1, be = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), Be.enabled && (i = Be.getCamera(i)), (z = X.get(e, i)).init(), e.onBeforeRender(ce, e, i, o || fe), Ie.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), De.setFromMatrix(Ie), Oe = this.localClippingEnabled, Re = Pe.init(this.clippingPlanes, Oe, i), (I = q.get(e, i)).init(), h(e, i, 0, ce.sortObjects), !0 === ce.sortObjects && I.sort(), Re && Pe.beginShadows(), Fe.render(z.state.shadowsArray, e, i), z.setupLights(i), Re && Pe.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), Y.render(I, e, i, a), n = I.opaque, r = I.transparent, e.overrideMaterial ? (o = e.overrideMaterial, n.length && d(n, e, i, o), r.length && d(r, e, i, o)) : (n.length && d(n, e, i), r.length && d(r, e, i)), e.onAfterRender(ce, e, i), null !== fe && (H.updateRenderTargetMipmap(fe), H.updateMultisampleRenderTarget(fe)), F.buffers.depth.setTest(!0), F.buffers.depth.setMask(!0), F.buffers.color.setMask(!0), F.setPolygonOffset(!1), Be.enabled && Be.submitFrame(), z = I = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function(e) {
            ue !== e && Ne.bindFramebuffer(36160, e), ue = e
        }, this.getActiveCubeFace = function() {
            return de
        }, this.getActiveMipMapLevel = function() {
            return pe
        }, this.getRenderTarget = function() {
            return fe
        }, this.setRenderTarget = function(e, t, i) {
            fe = e, de = t, pe = i, e && void 0 === U.get(e).__webglFramebuffer && H.setupRenderTarget(e);
            var n = ue,
                r = !1;
            e ? (n = U.get(e).__webglFramebuffer, e.isWebGLRenderTargetCube ? (n = n[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? U.get(e).__webglMultisampledFramebuffer : n, we.copy(e.viewport), _e.copy(e.scissor), Ee = e.scissorTest) : (we.copy(Ae).multiplyScalar(Se), _e.copy(Ce).multiplyScalar(Se), Ee = Le), me !== n && (Ne.bindFramebuffer(36160, n), me = n), F.viewport(we), F.scissor(_e), F.setScissorTest(Ee), r && (e = U.get(e.texture), Ne.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, i || 0))
        }, this.readRenderTargetPixels = function(e, t, i, n, r, o, a) {
            if (e && e.isWebGLRenderTarget) {
                var s = U.get(e).__webglFramebuffer;
                if (e.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                    a = !1, s !== me && (Ne.bindFramebuffer(36160, s), a = !0);
                    try {
                        var l = e.texture,
                            c = l.format,
                            h = l.type;
                        1023 !== c && le.convert(c) !== Ne.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || le.convert(h) === Ne.getParameter(35738) || 1015 === h && (B.isWebGL2 || N.get("OES_texture_float") || N.get("WEBGL_color_buffer_float")) || 1016 === h && (B.isWebGL2 ? N.get("EXT_color_buffer_float") : N.get("EXT_color_buffer_half_float")) ? 36053 === Ne.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && Ne.readPixels(t, i, n, r, le.convert(c), le.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        a && Ne.bindFramebuffer(36160, me)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(e, t, i) {
            var n = t.image.width,
                r = t.image.height,
                o = le.convert(t.format);
            H.setTexture2D(t, 0), Ne.copyTexImage2D(3553, i || 0, o, e.x, e.y, n, r, 0)
        }, this.copyTextureToTexture = function(e, t, i, n) {
            var r = t.image.width,
                o = t.image.height,
                a = le.convert(i.format),
                s = le.convert(i.type);
            H.setTexture2D(i, 0), t.isDataTexture ? Ne.texSubImage2D(3553, n || 0, e.x, e.y, r, o, a, s, t.image.data) : Ne.texSubImage2D(3553, n || 0, e.x, e.y, a, s, t.image)
        }
    }

    function At(e, t) {
        this.name = "", this.color = new b(e), this.density = void 0 !== t ? t : 25e-5
    }

    function Ct(e, t, i) {
        this.name = "", this.color = new b(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Lt() {
        T.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
    }

    function Dt(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Pt(e, t, i, n) {
        this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
    }

    function Rt(e) {
        V.call(this), this.type = "SpriteMaterial", this.color = new b(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
    }

    function Ot(e) {
        if (T.call(this), this.type = "Sprite", void 0 === ko) {
            ko = new k;
            var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            t = new Dt(t, 5), ko.setIndex([0, 1, 2, 0, 2, 3]), ko.addAttribute("position", new Pt(t, 3, 0, !1)), ko.addAttribute("uv", new Pt(t, 2, 3, !1))
        }
        this.geometry = ko, this.material = void 0 !== e ? e : new Rt, this.center = new i(.5, .5)
    }

    function It() {
        T.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function zt(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new g, this.bindMatrixInverse = new g
    }

    function Nt(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new g)
    }

    function Bt() {
        T.call(this), this.type = "Bone"
    }

    function Ft(e) {
        V.call(this), this.type = "LineBasicMaterial", this.color = new b(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(e)
    }

    function kt(e, t, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), T.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Ft({
            color: 16777215 * Math.random()
        })
    }

    function Ut(e, t) {
        kt.call(this, e, t), this.type = "LineSegments"
    }

    function Ht(e, t) {
        kt.call(this, e, t), this.type = "LineLoop"
    }

    function Gt(e) {
        V.call(this), this.type = "PointsMaterial", this.color = new b(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(e)
    }

    function jt(e, t) {
        T.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Gt({
            color: 16777215 * Math.random()
        })
    }

    function Vt(e, t, i, n, r, o, s, l, c) {
        a.call(this, e, t, i, n, r, o, s, l, c), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function Wt(e, t, i, n, r, o, s, l, c, h, u, d) {
        a.call(this, null, o, s, l, c, h, n, r, u, d), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
    }

    function qt(e, t, i, n, r, o, s, l, c) {
        a.call(this, e, t, i, n, r, o, s, l, c), this.needsUpdate = !0
    }

    function Xt(e, t, i, n, r, o, s, l, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), a.call(this, null, n, r, o, s, l, h, i, c), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
    }

    function Yt(e) {
        k.call(this), this.type = "WireframeGeometry";
        var t, i, n, o = [],
            a = [0, 0],
            s = {},
            l = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var c = e.faces,
                h = 0;
            for (i = c.length; h < i; h++) {
                var u = c[h];
                for (t = 0; 3 > t; t++) {
                    var d = u[l[t]],
                        p = u[l[(t + 1) % 3]];
                    a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = {
                        index1: a[0],
                        index2: a[1]
                    })
                }
            }
            for (d in s) h = s[d], l = e.vertices[h.index1], o.push(l.x, l.y, l.z), l = e.vertices[h.index2], o.push(l.x, l.y, l.z)
        } else if (e && e.isBufferGeometry)
            if (l = new r, null !== e.index) {
                c = e.attributes.position, u = e.index;
                var f = e.groups;
                for (0 === f.length && (f = [{
                        start: 0,
                        count: u.count,
                        materialIndex: 0
                    }]), e = 0, n = f.length; e < n; ++e)
                    for (t = (h = f[e]).start, i = h.count, h = t, i = t + i; h < i; h += 3)
                        for (t = 0; 3 > t; t++) d = u.getX(h + t), p = u.getX(h + (t + 1) % 3), a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = {
                            index1: a[0],
                            index2: a[1]
                        });
                for (d in s) h = s[d], l.fromBufferAttribute(c, h.index1), o.push(l.x, l.y, l.z), l.fromBufferAttribute(c, h.index2), o.push(l.x, l.y, l.z)
            } else
                for (h = 0, i = (c = e.attributes.position).count / 3; h < i; h++)
                    for (t = 0; 3 > t; t++) s = 3 * h + t, l.fromBufferAttribute(c, s), o.push(l.x, l.y, l.z), s = 3 * h + (t + 1) % 3, l.fromBufferAttribute(c, s), o.push(l.x, l.y, l.z);
        this.addAttribute("position", new z(o, 3))
    }

    function Zt(e, t, i) {
        S.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        }, this.fromBufferGeometry(new Jt(e, t, i)), this.mergeVertices()
    }

    function Jt(e, t, i) {
        k.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var n, o, a = [],
            s = [],
            l = [],
            c = [],
            h = new r,
            u = new r,
            d = new r,
            p = new r,
            f = new r;
        3 > e.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = t + 1;
        for (n = 0; n <= i; n++) {
            var g = n / i;
            for (o = 0; o <= t; o++) {
                var v = o / t;
                e(v, g, u), s.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, g, d), p.subVectors(u, d)) : (e(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (e(v, g - 1e-5, d), f.subVectors(u, d)) : (e(v, g + 1e-5, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), l.push(h.x, h.y, h.z), c.push(v, g)
            }
        }
        for (n = 0; n < i; n++)
            for (o = 0; o < t; o++) e = n * m + o + 1, h = (n + 1) * m + o + 1, u = (n + 1) * m + o, a.push(n * m + o, e, u), a.push(e, h, u);
        this.setIndex(a), this.addAttribute("position", new z(s, 3)), this.addAttribute("normal", new z(l, 3)), this.addAttribute("uv", new z(c, 2))
    }

    function Qt(e, t, i, n) {
        S.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new $t(e, t, i, n)), this.mergeVertices()
    }

    function $t(e, t, n, o) {
        function a(e) {
            c.push(e.x, e.y, e.z)
        }

        function s(t, i) {
            t *= 3, i.x = e[t + 0], i.y = e[t + 1], i.z = e[t + 2]
        }

        function l(e, t, i, n) {
            0 > n && 1 === e.x && (h[t] = e.x - 1), 0 === i.x && 0 === i.z && (h[t] = n / 2 / Math.PI + .5)
        }
        k.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: o
        }, n = n || 1;
        var c = [],
            h = [];
        ! function(e) {
            for (var i = new r, n = new r, o = new r, l = 0; l < t.length; l += 3) {
                s(t[l + 0], i), s(t[l + 1], n), s(t[l + 2], o);
                var c, h, u = i,
                    d = n,
                    p = o,
                    f = Math.pow(2, e),
                    m = [];
                for (h = 0; h <= f; h++) {
                    m[h] = [];
                    var g = u.clone().lerp(p, h / f),
                        v = d.clone().lerp(p, h / f),
                        y = f - h;
                    for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y)
                }
                for (h = 0; h < f; h++)
                    for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (a(m[h][u + 1]), a(m[h + 1][u]), a(m[h][u])) : (a(m[h][u + 1]), a(m[h + 1][u + 1]), a(m[h + 1][u]))
            }
        }(o = o || 0),
        function(e) {
            for (var t = new r, i = 0; i < c.length; i += 3) t.x = c[i + 0], t.y = c[i + 1], t.z = c[i + 2], t.normalize().multiplyScalar(e), c[i + 0] = t.x, c[i + 1] = t.y, c[i + 2] = t.z
        }(n),
        function() {
            for (var e = new r, t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2], h.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
            e = new r, t = new r;
            for (var n = new r, o = new r, a = new i, s = new i, u = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
                e.set(c[d + 0], c[d + 1], c[d + 2]), t.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), a.set(h[p + 0], h[p + 1]), s.set(h[p + 2], h[p + 3]), u.set(h[p + 4], h[p + 5]), o.copy(e).add(t).add(n).divideScalar(3);
                var f = Math.atan2(o.z, -o.x);
                l(a, p + 0, e, f), l(s, p + 2, t, f), l(u, p + 4, n, f)
            }
            for (e = 0; e < h.length; e += 6) t = h[e + 0], n = h[e + 2], o = h[e + 4], a = Math.min(t, n, o), .9 < Math.max(t, n, o) && .1 > a && (.2 > t && (h[e + 0] += 1), .2 > n && (h[e + 2] += 1), .2 > o && (h[e + 4] += 1))
        }(), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(c.slice(), 3)), this.addAttribute("uv", new z(h, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function Kt(e, t) {
        S.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ei(e, t)), this.mergeVertices()
    }

    function ei(e, t) {
        $t.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ti(e, t) {
        S.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ii(e, t)), this.mergeVertices()
    }

    function ii(e, t) {
        $t.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ni(e, t) {
        S.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ri(e, t)), this.mergeVertices()
    }

    function ri(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        $t.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function oi(e, t) {
        S.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ai(e, t)), this.mergeVertices()
    }

    function ai(e, t) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i;
        $t.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function si(e, t, i, n, r, o) {
        S.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), e = new li(e, t, i, n, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices()
    }

    function li(e, t, n, o, a) {
        function s(i) {
            f = e.getPointAt(i / t, f);
            var r = l.normals[i];
            for (i = l.binormals[i], h = 0; h <= o; h++) {
                var a = h / o * Math.PI * 2,
                    s = Math.sin(a);
                a = -Math.cos(a), d.x = a * r.x + s * i.x, d.y = a * r.y + s * i.y, d.z = a * r.z + s * i.z, d.normalize(), g.push(d.x, d.y, d.z), u.x = f.x + n * d.x, u.y = f.y + n * d.y, u.z = f.z + n * d.z, m.push(u.x, u.y, u.z)
            }
        }
        k.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: o,
            closed: a
        }, t = t || 64, n = n || 1, o = o || 8, a = a || !1;
        var l = e.computeFrenetFrames(t, a);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var c, h, u = new r,
            d = new r,
            p = new i,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c < t; c++) s(c);
        for (s(!1 === a ? t : 0), c = 0; c <= t; c++)
            for (h = 0; h <= o; h++) p.x = c / t, p.y = h / o, v.push(p.x, p.y);
        ! function() {
            for (h = 1; h <= t; h++)
                for (c = 1; c <= o; c++) {
                    var e = (o + 1) * h + (c - 1),
                        i = (o + 1) * h + c,
                        n = (o + 1) * (h - 1) + c;
                    y.push((o + 1) * (h - 1) + (c - 1), e, n), y.push(e, i, n)
                }
        }(), this.setIndex(y), this.addAttribute("position", new z(m, 3)), this.addAttribute("normal", new z(g, 3)), this.addAttribute("uv", new z(v, 2))
    }

    function ci(e, t, i, n, r, o, a) {
        S.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new hi(e, t, i, n, r, o)), this.mergeVertices()
    }

    function hi(e, t, i, n, o, a) {
        function s(e, t, i, n, r) {
            var o = Math.sin(e);
            t = i / t * e, i = Math.cos(t), r.x = n * (2 + i) * .5 * Math.cos(e), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(t) * .5
        }
        k.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: o,
            q: a
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, a = a || 3;
        var l, c = [],
            h = [],
            u = [],
            d = [],
            p = new r,
            f = new r,
            m = new r,
            g = new r,
            v = new r,
            y = new r,
            b = new r;
        for (l = 0; l <= i; ++l) {
            var x = l / i * o * Math.PI * 2;
            for (s(x, o, a, e, m), s(x + .01, o, a, e, g), y.subVectors(g, m), b.addVectors(g, m), v.crossVectors(y, b), b.crossVectors(v, y), v.normalize(), b.normalize(), x = 0; x <= n; ++x) {
                var w = x / n * Math.PI * 2,
                    _ = -t * Math.cos(w);
                w = t * Math.sin(w), p.x = m.x + (_ * b.x + w * v.x), p.y = m.y + (_ * b.y + w * v.y), p.z = m.z + (_ * b.z + w * v.z), h.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(l / i), d.push(x / n)
            }
        }
        for (x = 1; x <= i; x++)
            for (l = 1; l <= n; l++) e = (n + 1) * x + (l - 1), t = (n + 1) * x + l, o = (n + 1) * (x - 1) + l, c.push((n + 1) * (x - 1) + (l - 1), e, o), c.push(e, t, o);
        this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
    }

    function ui(e, t, i, n, r) {
        S.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new di(e, t, i, n, r)), this.mergeVertices()
    }

    function di(e, t, i, n, o) {
        k.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: o
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
        var a, s, l = [],
            c = [],
            h = [],
            u = [],
            d = new r,
            p = new r,
            f = new r;
        for (a = 0; a <= i; a++)
            for (s = 0; s <= n; s++) {
                var m = s / n * o,
                    g = a / i * Math.PI * 2;
                p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), h.push(f.x, f.y, f.z), u.push(s / n), u.push(a / i)
            }
        for (a = 1; a <= i; a++)
            for (s = 1; s <= n; s++) e = (n + 1) * (a - 1) + s - 1, t = (n + 1) * (a - 1) + s, o = (n + 1) * a + s, l.push((n + 1) * a + s - 1, e, o), l.push(e, t, o);
        this.setIndex(l), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(h, 3)), this.addAttribute("uv", new z(u, 2))
    }

    function pi(e, t, i, n, r) {
        for (var o, a = 0, s = t, l = i - n; s < i; s += n) a += (e[l] - e[s]) * (e[s + 1] + e[l + 1]), l = s;
        if (r === 0 < a)
            for (r = t; r < i; r += n) o = Si(r, e[r], e[r + 1], o);
        else
            for (r = i - n; r >= t; r -= n) o = Si(r, e[r], e[r + 1], o);
        return o && _i(o, o.next) && (Ai(o), o = o.next), o
    }

    function fi(e, t) {
        if (!e) return e;
        t || (t = e);
        do {
            var i = !1;
            if (e.steiner || !_i(e, e.next) && 0 !== wi(e.prev, e, e.next)) e = e.next;
            else {
                if (Ai(e), (e = t = e.prev) === e.next) break;
                i = !0
            }
        } while (i || e !== t);
        return t
    }

    function mi(e, t, i, n, r, o, a) {
        if (e) {
            if (!a && o) {
                var s = e,
                    l = s;
                do {
                    null === l.z && (l.z = yi(l.x, l.y, n, r, o)), l.prevZ = l.prev, l = l.nextZ = l.next
                } while (l !== s);
                l.prevZ.nextZ = null, l.prevZ = null, s = l;
                var c, h, u, d, p = 1;
                do {
                    l = s;
                    var f = s = null;
                    for (h = 0; l;) {
                        h++;
                        var m = l;
                        for (c = u = 0; c < p && (u++, m = m.nextZ); c++);
                        for (d = p; 0 < u || 0 < d && m;) 0 !== u && (0 === d || !m || l.z <= m.z) ? (c = l, l = l.nextZ, u--) : (c = m, m = m.nextZ, d--), f ? f.nextZ = c : s = c, c.prevZ = f, f = c;
                        l = m
                    }
                    f.nextZ = null, p *= 2
                } while (1 < h)
            }
            for (s = e; e.prev !== e.next;) {
                if (l = e.prev, m = e.next, o) e: {
                    d = n;
                    var g = r,
                        v = o;
                    if (0 <= wi(h = (f = e).prev, u = f, p = f.next)) f = !1;
                    else {
                        var y = h.x > u.x ? h.x > p.x ? h.x : p.x : u.x > p.x ? u.x : p.x,
                            b = h.y > u.y ? h.y > p.y ? h.y : p.y : u.y > p.y ? u.y : p.y;
                        for (c = yi(h.x < u.x ? h.x < p.x ? h.x : p.x : u.x < p.x ? u.x : p.x, h.y < u.y ? h.y < p.y ? h.y : p.y : u.y < p.y ? u.y : p.y, d, g, v), d = yi(y, b, d, g, v), g = f.nextZ; g && g.z <= d;) {
                            if (g !== f.prev && g !== f.next && xi(h.x, h.y, u.x, u.y, p.x, p.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) {
                                f = !1;
                                break e
                            }
                            g = g.nextZ
                        }
                        for (g = f.prevZ; g && g.z >= c;) {
                            if (g !== f.prev && g !== f.next && xi(h.x, h.y, u.x, u.y, p.x, p.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) {
                                f = !1;
                                break e
                            }
                            g = g.prevZ
                        }
                        f = !0
                    }
                }
                else e: if (f = e, h = f.prev, u = f, p = f.next, 0 <= wi(h, u, p)) f = !1;
                    else {
                        for (c = f.next.next; c !== f.prev;) {
                            if (xi(h.x, h.y, u.x, u.y, p.x, p.y, c.x, c.y) && 0 <= wi(c.prev, c, c.next)) {
                                f = !1;
                                break e
                            }
                            c = c.next
                        }
                        f = !0
                    } if (f) t.push(l.i / i), t.push(e.i / i), t.push(m.i / i), Ai(e), s = e = m.next;
                else if ((e = m) === s) {
                    if (a) {
                        if (1 === a) {
                            a = t, s = i, l = e;
                            do {
                                !_i(m = l.prev, f = l.next.next) && Ei(m, l, l.next, f) && Mi(m, f) && Mi(f, m) && (a.push(m.i / s), a.push(l.i / s), a.push(f.i / s), Ai(l), Ai(l.next), l = e = f), l = l.next
                            } while (l !== e);
                            mi(e = l, t, i, n, r, o, 2)
                        } else if (2 === a) e: {
                            a = e;do {
                                for (s = a.next.next; s !== a.prev;) {
                                    if (l = a.i !== s.i) {
                                        if (m = s, f = (l = a).next.i !== m.i && l.prev.i !== m.i) {
                                            t: {
                                                f = l;do {
                                                    if (f.i !== l.i && f.next.i !== l.i && f.i !== m.i && f.next.i !== m.i && Ei(f, f.next, l, m)) {
                                                        f = !0;
                                                        break t
                                                    }
                                                    f = f.next
                                                } while (f !== l);f = !1
                                            }
                                            f = !f
                                        }
                                        if (f = f && Mi(l, m) && Mi(m, l)) {
                                            f = l, h = !1, u = (l.x + m.x) / 2, m = (l.y + m.y) / 2;
                                            do {
                                                f.y > m != f.next.y > m && f.next.y !== f.y && u < (f.next.x - f.x) * (m - f.y) / (f.next.y - f.y) + f.x && (h = !h), f = f.next
                                            } while (f !== l);
                                            f = h
                                        }
                                        l = f
                                    }
                                    if (l) {
                                        e = Ti(a, s), a = fi(a, a.next), e = fi(e, e.next), mi(a, t, i, n, r, o), mi(e, t, i, n, r, o);
                                        break e
                                    }
                                    s = s.next
                                }
                                a = a.next
                            } while (a !== e)
                        }
                    } else mi(fi(e), t, i, n, r, o, 1);
                    break
                }
            }
        }
    }

    function gi(e, t) {
        return e.x - t.x
    }

    function vi(e, t) {
        var i = t,
            n = e.x,
            r = e.y,
            o = -1 / 0;
        do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                var a = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (a <= n && a > o) {
                    if (o = a, a === n) {
                        if (r === i.y) return i;
                        if (r === i.next.y) return i.next
                    }
                    var s = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== t);
        if (!s) return null;
        if (n === o) return s.prev;
        t = s, a = s.x;
        var l = s.y,
            c = 1 / 0;
        for (i = s.next; i !== t;) {
            if (n >= i.x && i.x >= a && n !== i.x && xi(r < l ? n : o, r, a, l, r < l ? o : n, r, i.x, i.y)) {
                var h = Math.abs(r - i.y) / (n - i.x);
                (h < c || h === c && i.x > s.x) && Mi(i, e) && (s = i, c = h)
            }
            i = i.next
        }
        return s
    }

    function yi(e, t, i, n, r) {
        return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function bi(e) {
        var t = e,
            i = e;
        do {
            t.x < i.x && (i = t), t = t.next
        } while (t !== e);
        return i
    }

    function xi(e, t, i, n, r, o, a, s) {
        return 0 <= (r - a) * (t - s) - (e - a) * (o - s) && 0 <= (e - a) * (n - s) - (i - a) * (t - s) && 0 <= (i - a) * (o - s) - (r - a) * (n - s)
    }

    function wi(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }

    function _i(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function Ei(e, t, i, n) {
        return !!(_i(e, t) && _i(i, n) || _i(e, n) && _i(i, t)) || 0 < wi(e, t, i) != 0 < wi(e, t, n) && 0 < wi(i, n, e) != 0 < wi(i, n, t)
    }

    function Mi(e, t) {
        return 0 > wi(e.prev, e, e.next) ? 0 <= wi(e, t, e.next) && 0 <= wi(e, e.prev, t) : 0 > wi(e, t, e.prev) || 0 > wi(e, e.next, t)
    }

    function Ti(e, t) {
        var i = new Ci(e.i, e.x, e.y),
            n = new Ci(t.i, t.x, t.y),
            r = e.next,
            o = t.prev;
        return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
    }

    function Si(e, t, i, n) {
        return e = new Ci(e, t, i), n ? (e.next = n.next, e.prev = n, n.next.prev = e, n.next = e) : (e.prev = e, e.next = e), e
    }

    function Ai(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Ci(e, t, i) {
        this.i = e, this.x = t, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
    }

    function Li(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function Di(e, t) {
        for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
    }

    function Pi(e, t) {
        S.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new Ri(e, t)), this.mergeVertices()
    }

    function Ri(e, t) {
        function n(e) {
            function n(e, t, i) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
            }

            function l(e, t, n) {
                var r = e.x - t.x,
                    o = e.y - t.y,
                    a = n.x - e.x,
                    s = n.y - e.y,
                    l = r * r + o * o;
                if (Math.abs(r * s - o * a) > Number.EPSILON) {
                    var c = Math.sqrt(l),
                        h = Math.sqrt(a * a + s * s);
                    if (l = t.x - o / c, t = t.y + r / c, 2 >= (o = (a = l + r * (s = ((n.x - s / h - l) * s - (n.y + a / h - t) * a) / (r * s - o * a)) - e.x) * a + (r = t + o * s - e.y) * r)) return new i(a, r);
                    o = Math.sqrt(o / 2)
                } else e = !1, r > Number.EPSILON ? a > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? a < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(s) && (e = !0), e ? (a = -o, o = Math.sqrt(l)) : (a = r, r = o, o = Math.sqrt(l / 2));
                return new i(a / o, r / o)
            }

            function c(e, t) {
                for (H = e.length; 0 <= --H;) {
                    var i = H,
                        n = H - 1;
                    0 > n && (n = e.length - 1);
                    var r, s = g + 2 * _;
                    for (r = 0; r < s; r++) {
                        var l = k * r,
                            c = k * (r + 1),
                            h = t + n + l,
                            u = t + n + c;
                        c = t + i + c, d(t + i + l), d(h), d(c), d(h), d(u), d(c), l = a.length / 3, p((l = M.generateSideWallUV(o, a, l - 6, l - 3, l - 2, l - 1))[0]), p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3])
                    }
                }
            }

            function h(e, t, i) {
                f.push(e), f.push(t), f.push(i)
            }

            function u(e, t, i) {
                d(e), d(t), d(i), e = a.length / 3, p((e = M.generateTopUV(o, a, e - 3, e - 2, e - 1))[0]), p(e[1]), p(e[2])
            }

            function d(e) {
                a.push(f[3 * e]), a.push(f[3 * e + 1]), a.push(f[3 * e + 2])
            }

            function p(e) {
                s.push(e.x), s.push(e.y)
            }
            var f = [],
                m = void 0 !== t.curveSegments ? t.curveSegments : 12,
                g = void 0 !== t.steps ? t.steps : 1,
                v = void 0 !== t.depth ? t.depth : 100,
                y = void 0 === t.bevelEnabled || t.bevelEnabled,
                b = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                x = void 0 !== t.bevelSize ? t.bevelSize : b - 2,
                w = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                _ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                E = t.extrudePath,
                M = void 0 !== t.UVGenerator ? t.UVGenerator : Vo;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = t.amount);
            var T, S = !1;
            if (E) {
                var A = E.getSpacedPoints(g);
                S = !0, y = !1;
                var C = E.computeFrenetFrames(g, !1),
                    L = new r,
                    D = new r,
                    P = new r
            }
            y || (w = x = b = _ = 0), m = e.extractPoints(m), e = m.shape;
            var R = m.holes;
            if (!jo.isClockWise(e)) {
                e = e.reverse();
                var O = 0;
                for (T = R.length; O < T; O++) {
                    var I = R[O];
                    jo.isClockWise(I) && (R[O] = I.reverse())
                }
            }
            var z = jo.triangulateShape(e, R),
                N = e;
            for (O = 0, T = R.length; O < T; O++) I = R[O], e = e.concat(I);
            var B, F, k = e.length,
                U = z.length;
            m = [];
            var H = 0,
                G = N.length,
                j = G - 1;
            for (B = H + 1; H < G; H++, j++, B++) j === G && (j = 0), B === G && (B = 0), m[H] = l(N[H], N[j], N[B]);
            E = [];
            var V = m.concat();
            for (O = 0, T = R.length; O < T; O++) {
                I = R[O];
                var W = [];
                for (H = 0, j = (G = I.length) - 1, B = H + 1; H < G; H++, j++, B++) j === G && (j = 0), B === G && (B = 0), W[H] = l(I[H], I[j], I[B]);
                E.push(W), V = V.concat(W)
            }
            for (j = 0; j < _; j++) {
                G = j / _;
                var q = b * Math.cos(G * Math.PI / 2);
                for (B = x * Math.sin(G * Math.PI / 2) + w, H = 0, G = N.length; H < G; H++) {
                    var X = n(N[H], m[H], B);
                    h(X.x, X.y, -q)
                }
                for (O = 0, T = R.length; O < T; O++)
                    for (I = R[O], W = E[O], H = 0, G = I.length; H < G; H++) h((X = n(I[H], W[H], B)).x, X.y, -q)
            }
            for (B = x + w, H = 0; H < k; H++) X = y ? n(e[H], V[H], B) : e[H], S ? (D.copy(C.normals[0]).multiplyScalar(X.x), L.copy(C.binormals[0]).multiplyScalar(X.y), P.copy(A[0]).add(D).add(L), h(P.x, P.y, P.z)) : h(X.x, X.y, 0);
            for (G = 1; G <= g; G++)
                for (H = 0; H < k; H++) X = y ? n(e[H], V[H], B) : e[H], S ? (D.copy(C.normals[G]).multiplyScalar(X.x), L.copy(C.binormals[G]).multiplyScalar(X.y), P.copy(A[G]).add(D).add(L), h(P.x, P.y, P.z)) : h(X.x, X.y, v / g * G);
            for (j = _ - 1; 0 <= j; j--) {
                for (G = j / _, q = b * Math.cos(G * Math.PI / 2), B = x * Math.sin(G * Math.PI / 2) + w, H = 0, G = N.length; H < G; H++) h((X = n(N[H], m[H], B)).x, X.y, v + q);
                for (O = 0, T = R.length; O < T; O++)
                    for (I = R[O], W = E[O], H = 0, G = I.length; H < G; H++) X = n(I[H], W[H], B), S ? h(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : h(X.x, X.y, v + q)
            }! function() {
                var e = a.length / 3;
                if (y) {
                    var t = 0 * k;
                    for (H = 0; H < U; H++) u((F = z[H])[2] + t, F[1] + t, F[0] + t);
                    for (t = k * (g + 2 * _), H = 0; H < U; H++) u((F = z[H])[0] + t, F[1] + t, F[2] + t)
                } else {
                    for (H = 0; H < U; H++) u((F = z[H])[2], F[1], F[0]);
                    for (H = 0; H < U; H++) u((F = z[H])[0] + k * g, F[1] + k * g, F[2] + k * g)
                }
                o.addGroup(e, a.length / 3 - e, 0)
            }(),
            function() {
                var e = a.length / 3,
                    t = 0;
                for (c(N, t), t += N.length, O = 0, T = R.length; O < T; O++) c(I = R[O], t), t += I.length;
                o.addGroup(e, a.length / 3 - e, 1)
            }()
        }
        k.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        for (var o = this, a = [], s = [], l = 0, c = e.length; l < c; l++) n(e[l]);
        this.addAttribute("position", new z(a, 3)), this.addAttribute("uv", new z(s, 2)), this.computeVertexNormals()
    }

    function Oi(e, t, i) {
        if (i.shapes = [], Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) i.shapes.push(e[n].uuid);
        else i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
    }

    function Ii(e, t) {
        S.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new zi(e, t)), this.mergeVertices()
    }

    function zi(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new S;
        e = i.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ri.call(this, e, t), this.type = "TextBufferGeometry"
    }

    function Ni(e, t, i, n, r, o, a) {
        S.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new Bi(e, t, i, n, r, o, a)), this.mergeVertices()
    }

    function Bi(e, t, i, n, o, a, s) {
        k.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: o,
            thetaStart: a,
            thetaLength: s
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
        var l, c, h = Math.min(a + s, Math.PI),
            u = 0,
            d = [],
            p = new r,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c <= i; c++) {
            var b = [],
                x = c / i,
                w = 0;
            for (0 == c && 0 == a ? w = .5 / t : c == i && h == Math.PI && (w = -.5 / t), l = 0; l <= t; l++) {
                var _ = l / t;
                p.x = -e * Math.cos(n + _ * o) * Math.sin(a + x * s), p.y = e * Math.cos(a + x * s), p.z = e * Math.sin(n + _ * o) * Math.sin(a + x * s), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(_ + w, 1 - x), b.push(u++)
            }
            d.push(b)
        }
        for (c = 0; c < i; c++)
            for (l = 0; l < t; l++) e = d[c][l + 1], n = d[c][l], o = d[c + 1][l], s = d[c + 1][l + 1], (0 !== c || 0 < a) && m.push(e, n, s), (c !== i - 1 || h < Math.PI) && m.push(n, o, s);
        this.setIndex(m), this.addAttribute("position", new z(g, 3)), this.addAttribute("normal", new z(v, 3)), this.addAttribute("uv", new z(y, 2))
    }

    function Fi(e, t, i, n, r, o) {
        S.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new ki(e, t, i, n, r, o)), this.mergeVertices()
    }

    function ki(e, t, n, o, a, s) {
        k.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: o,
            thetaStart: a,
            thetaLength: s
        }, e = e || .5, t = t || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var l, c, h = [],
            u = [],
            d = [],
            p = [],
            f = e,
            m = (t - e) / (o = void 0 !== o ? Math.max(1, o) : 1),
            g = new r,
            v = new i;
        for (l = 0; l <= o; l++) {
            for (c = 0; c <= n; c++) e = a + c / n * s, g.x = f * Math.cos(e), g.y = f * Math.sin(e), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, p.push(v.x, v.y);
            f += m
        }
        for (l = 0; l < o; l++)
            for (t = l * (n + 1), c = 0; c < n; c++) a = (e = c + t) + n + 1, s = e + n + 2, f = e + 1, h.push(e, a, f), h.push(a, s, f);
        this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
    }

    function Ui(e, t, i, n) {
        S.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new Hi(e, t, i, n)), this.mergeVertices()
    }

    function Hi(e, t, n, o) {
        k.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: o
        }, t = Math.floor(t) || 12, n = n || 0, o = o || 2 * Math.PI, o = fo.clamp(o, 0, 2 * Math.PI);
        var a, s = [],
            l = [],
            c = [],
            h = 1 / t,
            u = new r,
            d = new i;
        for (a = 0; a <= t; a++) {
            var p = n + a * h * o,
                f = Math.sin(p),
                m = Math.cos(p);
            for (p = 0; p <= e.length - 1; p++) u.x = e[p].x * f, u.y = e[p].y, u.z = e[p].x * m, l.push(u.x, u.y, u.z), d.x = a / t, d.y = p / (e.length - 1), c.push(d.x, d.y)
        }
        for (a = 0; a < t; a++)
            for (p = 0; p < e.length - 1; p++) h = (n = p + a * e.length) + e.length, u = n + e.length + 1, d = n + 1, s.push(n, h, d), s.push(h, u, d);
        if (this.setIndex(s), this.addAttribute("position", new z(l, 3)), this.addAttribute("uv", new z(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI)
            for (o = this.attributes.normal.array, s = new r, l = new r, c = new r, n = t * e.length * 3, p = a = 0; a < e.length; a++, p += 3) s.x = o[p + 0], s.y = o[p + 1], s.z = o[p + 2], l.x = o[n + p + 0], l.y = o[n + p + 1], l.z = o[n + p + 2], c.addVectors(s, l).normalize(), o[p + 0] = o[n + p + 0] = c.x, o[p + 1] = o[n + p + 1] = c.y, o[p + 2] = o[n + p + 2] = c.z
    }

    function Gi(e, t) {
        S.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new ji(e, t)), this.mergeVertices()
    }

    function ji(e, t) {
        function i(e) {
            var i, s = r.length / 3,
                c = (e = e.extractPoints(t)).shape,
                h = e.holes;
            for (!1 === jo.isClockWise(c) && (c = c.reverse()), e = 0, i = h.length; e < i; e++) {
                var u = h[e];
                !0 === jo.isClockWise(u) && (h[e] = u.reverse())
            }
            var d = jo.triangulateShape(c, h);
            for (e = 0, i = h.length; e < i; e++) u = h[e], c = c.concat(u);
            for (e = 0, i = c.length; e < i; e++) u = c[e], r.push(u.x, u.y, 0), o.push(0, 0, 1), a.push(u.x, u.y);
            for (e = 0, i = d.length; e < i; e++) c = d[e], n.push(c[0] + s, c[1] + s, c[2] + s), l += 3
        }
        k.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var n = [],
            r = [],
            o = [],
            a = [],
            s = 0,
            l = 0;
        if (!1 === Array.isArray(e)) i(e);
        else
            for (var c = 0; c < e.length; c++) i(e[c]), this.addGroup(s, l, c), s += l, l = 0;
        this.setIndex(n), this.addAttribute("position", new z(r, 3)), this.addAttribute("normal", new z(o, 3)), this.addAttribute("uv", new z(a, 2))
    }

    function Vi(e, t) {
        if (t.shapes = [], Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++) t.shapes.push(e[i].uuid);
        else t.shapes.push(e.uuid);
        return t
    }

    function Wi(e, t) {
        k.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        };
        var i = [];
        t = Math.cos(fo.DEG2RAD * (void 0 !== t ? t : 1));
        var n = [0, 0],
            r = {},
            o = ["a", "b", "c"];
        if (e.isBufferGeometry) {
            var a = new S;
            a.fromBufferGeometry(e)
        } else a = e.clone();
        a.mergeVertices(), a.computeFaceNormals(), e = a.vertices;
        for (var s = 0, l = (a = a.faces).length; s < l; s++)
            for (var c = a[s], h = 0; 3 > h; h++) {
                var u = c[o[h]],
                    d = c[o[(h + 1) % 3]];
                n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
                    index1: n[0],
                    index2: n[1],
                    face1: s,
                    face2: void 0
                } : r[u].face2 = s
            }
        for (u in r)(void 0 === (n = r[u]).face2 || a[n.face1].normal.dot(a[n.face2].normal) <= t) && (o = e[n.index1], i.push(o.x, o.y, o.z), o = e[n.index2], i.push(o.x, o.y, o.z));
        this.addAttribute("position", new z(i, 3))
    }

    function qi(e, t, i, n, r, o, a, s) {
        S.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new Xi(e, t, i, n, r, o, a, s)), this.mergeVertices()
    }

    function Xi(e, t, n, o, a, s, l, c) {
        function h(n) {
            var a, s = new i,
                h = new r,
                v = 0,
                x = !0 === n ? e : t,
                w = !0 === n ? 1 : -1,
                _ = g;
            for (a = 1; a <= o; a++) p.push(0, y * w, 0), f.push(0, w, 0), m.push(.5, .5), g++;
            var E = g;
            for (a = 0; a <= o; a++) {
                var M = a / o * c + l,
                    T = Math.cos(M);
                M = Math.sin(M), h.x = x * M, h.y = y * w, h.z = x * T, p.push(h.x, h.y, h.z), f.push(0, w, 0), s.x = .5 * T + .5, s.y = .5 * M * w + .5, m.push(s.x, s.y), g++
            }
            for (a = 0; a < o; a++) s = _ + a, h = E + a, !0 === n ? d.push(h, h + 1, s) : d.push(h + 1, h, s), v += 3;
            u.addGroup(b, v, !0 === n ? 1 : 2), b += v
        }
        k.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: o,
            heightSegments: a,
            openEnded: s,
            thetaStart: l,
            thetaLength: c
        };
        var u = this;
        e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, o = Math.floor(o) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
        var d = [],
            p = [],
            f = [],
            m = [],
            g = 0,
            v = [],
            y = n / 2,
            b = 0;
        ! function() {
            var i, s, h = new r,
                x = new r,
                w = 0,
                _ = (t - e) / n;
            for (s = 0; s <= a; s++) {
                var E = [],
                    M = s / a,
                    T = M * (t - e) + e;
                for (i = 0; i <= o; i++) {
                    var S = i / o,
                        A = S * c + l,
                        C = Math.sin(A);
                    A = Math.cos(A), x.x = T * C, x.y = -M * n + y, x.z = T * A, p.push(x.x, x.y, x.z), h.set(C, _, A).normalize(), f.push(h.x, h.y, h.z), m.push(S, 1 - M), E.push(g++)
                }
                v.push(E)
            }
            for (i = 0; i < o; i++)
                for (s = 0; s < a; s++) h = v[s + 1][i], x = v[s + 1][i + 1], _ = v[s][i + 1], d.push(v[s][i], h, _), d.push(h, x, _), w += 6;
            u.addGroup(b, w, 0), b += w
        }(), !1 === s && (0 < e && h(!0), 0 < t && h(!1)), this.setIndex(d), this.addAttribute("position", new z(p, 3)), this.addAttribute("normal", new z(f, 3)), this.addAttribute("uv", new z(m, 2))
    }

    function Yi(e, t, i, n, r, o, a) {
        qi.call(this, 0, e, t, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Zi(e, t, i, n, r, o, a) {
        Xi.call(this, 0, e, t, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Ji(e, t, i, n) {
        S.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new Qi(e, t, i, n)), this.mergeVertices()
    }

    function Qi(e, t, n, o) {
        k.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: o
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI;
        var a, s = [],
            l = [],
            c = [],
            h = [],
            u = new r,
            d = new i;
        l.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5);
        var p = 0;
        for (a = 3; p <= t; p++, a += 3) {
            var f = n + p / t * o;
            u.x = e * Math.cos(f), u.y = e * Math.sin(f), l.push(u.x, u.y, u.z), c.push(0, 0, 1), d.x = (l[a] / e + 1) / 2, d.y = (l[a + 1] / e + 1) / 2, h.push(d.x, d.y)
        }
        for (a = 1; a <= t; a++) s.push(a, a + 1, 0);
        this.setIndex(s), this.addAttribute("position", new z(l, 3)), this.addAttribute("normal", new z(c, 3)), this.addAttribute("uv", new z(h, 2))
    }

    function $i(e) {
        V.call(this), this.type = "ShadowMaterial", this.color = new b(0), this.transparent = !0, this.setValues(e)
    }

    function Ki(e) {
        W.call(this, e), this.type = "RawShaderMaterial"
    }

    function en(e) {
        V.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new b(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function tn(e) {
        en.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(e)
    }

    function nn(e) {
        V.call(this), this.type = "MeshPhongMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function rn(e) {
        nn.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function on(e) {
        V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(e)
    }

    function an(e) {
        V.call(this), this.type = "MeshLambertMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function sn(e) {
        V.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new b(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function ln(e) {
        Ft.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    function cn(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
    }

    function hn(e, t, i, n) {
        cn.call(this, e, t, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function un(e, t, i, n) {
        cn.call(this, e, t, i, n)
    }

    function dn(e, t, i, n) {
        cn.call(this, e, t, i, n)
    }

    function pn(e, t, i, n) {
        if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Xo.convertArray(t, this.TimeBufferType), this.values = Xo.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }

    function fn(e, t, i) {
        pn.call(this, e, t, i)
    }

    function mn(e, t, i, n) {
        pn.call(this, e, t, i, n)
    }

    function gn(e, t, i, n) {
        pn.call(this, e, t, i, n)
    }

    function vn(e, t, i, n) {
        cn.call(this, e, t, i, n)
    }

    function yn(e, t, i, n) {
        pn.call(this, e, t, i, n)
    }

    function bn(e, t, i, n) {
        pn.call(this, e, t, i, n)
    }

    function xn(e, t, i, n) {
        pn.call(this, e, t, i, n)
    }

    function wn(e, t, i) {
        this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = fo.generateUUID(), 0 > this.duration && this.resetDuration()
    }

    function _n(e) {
        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return gn;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return xn;
                case "color":
                    return mn;
                case "quaternion":
                    return yn;
                case "bool":
                case "boolean":
                    return fn;
                case "string":
                    return bn
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var i = [],
                n = [];
            Xo.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }

    function En(e, t, i) {
        var n = this,
            r = !1,
            o = 0,
            a = 0,
            s = void 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
            a++, !1 === r && void 0 !== n.onStart && n.onStart(e, o, a), r = !0
        }, this.itemEnd = function(e) {
            o++, void 0 !== n.onProgress && n.onProgress(e, o, a), o === a && (r = !1, void 0 !== n.onLoad) && n.onLoad()
        }, this.itemError = function(e) {
            void 0 !== n.onError && n.onError(e)
        }, this.resolveURL = function(e) {
            return s ? s(e) : e
        }, this.setURLModifier = function(e) {
            return s = e, this
        }
    }

    function Mn(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function Tn(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function Sn(e) {
        this.manager = void 0 !== e ? e : Zo, this._parser = null
    }

    function An(e) {
        this.manager = void 0 !== e ? e : Zo, this._parser = null
    }

    function Cn(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function Ln(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function Dn(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function Pn() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function Rn(e, t, i, n, r, o, a, s) {
        Pn.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function On(e, t, i, n, r, o) {
        Rn.call(this, e, t, i, i, n, r, o), this.type = "ArcCurve"
    }

    function In() {
        var e = 0,
            t = 0,
            i = 0,
            n = 0;
        return {
            initCatmullRom: function(r, o, a, s, l) {
                e = o, t = r = l * (a - r), i = -3 * o + 3 * a - 2 * r - (s = l * (s - o)), n = 2 * o - 2 * a + r + s
            },
            initNonuniformCatmullRom: function(r, o, a, s, l, c, h) {
                e = o, t = r = ((o - r) / l - (a - r) / (l + c) + (a - o) / c) * c, i = -3 * o + 3 * a - 2 * r - (s = ((a - o) / c - (s - o) / (c + h) + (s - a) / h) * c), n = 2 * o - 2 * a + r + s
            },
            calc: function(r) {
                var o = r * r;
                return e + t * r + i * o + n * o * r
            }
        }
    }

    function zn(e, t, i, n) {
        Pn.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function Nn(e, t, i, n, r) {
        var o = e * e;
        return (2 * i - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - i))) * e * o + (-3 * i + 3 * n - 2 * t - r) * o + t * e + i
    }

    function Bn(e, t, i, n) {
        var r = 1 - e;
        return r * r * t + 2 * (1 - e) * e * i + e * e * n
    }

    function Fn(e, t, i, n, r) {
        var o = 1 - e,
            a = 1 - e;
        return o * o * o * t + 3 * a * a * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
    }

    function kn(e, t, n, r) {
        Pn.call(this), this.type = "CubicBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i, this.v3 = r || new i
    }

    function Un(e, t, i, n) {
        Pn.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r, this.v3 = n || new r
    }

    function Hn(e, t) {
        Pn.call(this), this.type = "LineCurve", this.v1 = e || new i, this.v2 = t || new i
    }

    function Gn(e, t) {
        Pn.call(this), this.type = "LineCurve3", this.v1 = e || new r, this.v2 = t || new r
    }

    function jn(e, t, n) {
        Pn.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i
    }

    function Vn(e, t, i) {
        Pn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r
    }

    function Wn(e) {
        Pn.call(this), this.type = "SplineCurve", this.points = e || []
    }

    function qn() {
        Pn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Xn(e) {
        qn.call(this), this.type = "Path", this.currentPoint = new i, e && this.setFromPoints(e)
    }

    function Yn(e) {
        Xn.call(this, e), this.uuid = fo.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Zn(e, t) {
        T.call(this), this.type = "Light", this.color = new b(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Jn(e, t, i) {
        Zn.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(T.DefaultUp), this.updateMatrix(), this.groundColor = new b(t)
    }

    function Qn(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new g
    }

    function $n() {
        Qn.call(this, new wt(50, 1, .5, 500))
    }

    function Kn(e, t, i, n, r, o) {
        Zn.call(this, e, t), this.type = "SpotLight", this.position.copy(T.DefaultUp), this.updateMatrix(), this.target = new T, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new $n
    }

    function er(e, t, i, n) {
        Zn.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Qn(new wt(90, 1, .5, 500))
    }

    function tr(e, t, i, n, r, o) {
        xt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function ir() {
        Qn.call(this, new tr(-5, 5, 5, -5, .5, 500))
    }

    function nr(e, t) {
        Zn.call(this, e, t), this.type = "DirectionalLight", this.position.copy(T.DefaultUp), this.updateMatrix(), this.target = new T, this.shadow = new ir
    }

    function rr(e, t) {
        Zn.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function or(e, t, i, n) {
        Zn.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function ar(e) {
        this.manager = void 0 !== e ? e : Zo, this.textures = {}
    }

    function sr() {
        k.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function lr(e, t, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, e, t, i), this.meshPerAttribute = n || 1
    }

    function cr(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function hr(e) {
        this.manager = void 0 !== e ? e : Zo, this.resourcePath = ""
    }

    function ur(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Zo, this.options = void 0
    }

    function dr() {
        this.type = "ShapePath", this.color = new b, this.subPaths = [], this.currentPath = null
    }

    function pr(e) {
        this.type = "Font", this.data = e
    }

    function fr(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function mr() {}

    function gr(e) {
        this.manager = void 0 !== e ? e : Zo
    }

    function vr() {
        this.coefficients = [];
        for (var e = 0; 9 > e; e++) this.coefficients.push(new r)
    }

    function yr(e, t) {
        Zn.call(this, void 0, t), this.sh = void 0 !== e ? e : new vr
    }

    function br(e, t, i) {
        yr.call(this, void 0, i), e = (new b).set(e), i = (new b).set(t), t = new r(e.r, e.g, e.b), e = new r(i.r, i.g, i.b);
        var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75);
        this.sh.coefficients[0].copy(t).add(e).multiplyScalar(i), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(n)
    }

    function xr(e, t) {
        yr.call(this, void 0, t), e = (new b).set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }

    function wr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new wt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new wt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function _r(e, t, i, n) {
        T.call(this), this.type = "CubeCamera";
        var o = new wt(90, 1, e, t);
        o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o);
        var a = new wt(90, 1, e, t);
        a.up.set(0, -1, 0), a.lookAt(new r(-1, 0, 0)), this.add(a);
        var s = new wt(90, 1, e, t);
        s.up.set(0, 0, 1), s.lookAt(new r(0, 1, 0)), this.add(s);
        var l = new wt(90, 1, e, t);
        l.up.set(0, 0, -1), l.lookAt(new r(0, -1, 0)), this.add(l);
        var c = new wt(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new r(0, 0, 1)), this.add(c);
        var u = new wt(90, 1, e, t);
        u.up.set(0, -1, 0), u.lookAt(new r(0, 0, -1)), this.add(u), n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }, this.renderTarget = new h(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = e.getRenderTarget(),
                n = this.renderTarget,
                r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, o), e.setRenderTarget(n, 1), e.render(t, a), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, l), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = r, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(i)
        }, this.clear = function(e, t, i, n) {
            for (var r = e.getRenderTarget(), o = this.renderTarget, a = 0; 6 > a; a++) e.setRenderTarget(o, a), e.clear(t, i, n);
            e.setRenderTarget(r)
        }
    }

    function Er(e) {
        this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }

    function Mr() {
        T.call(this), this.type = "AudioListener", this.context = ha.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
    }

    function Tr(e) {
        T.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function Sr(e) {
        Tr.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function Ar(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Cr(e, t, i) {
        switch (this.binding = e, this.valueSize = i, e = Float64Array, t) {
            case "quaternion":
                t = this._slerp;
                break;
            case "string":
            case "bool":
                e = Array, t = this._select;
                break;
            default:
                t = this._lerp
        }
        this.buffer = new e(4 * i), this._mixBufferRegion = t, this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function Lr(e, t, i) {
        i = i || Dr.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i)
    }

    function Dr(e, t, i) {
        this.path = t, this.parsedPath = i || Dr.parseTrackName(t), this.node = Dr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function Pr() {
        this.uuid = fo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Rr(e, t, i) {
        this._mixer = e, this._clip = t, this._localRoot = i || null, t = (e = t.tracks).length, i = Array(t);
        for (var n = {
                endingStart: 2400,
                endingEnd: 2400
            }, r = 0; r !== t; ++r) {
            var o = e[r].createInterpolant(null);
            i[r] = o, o.settings = n
        }
        this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function Or(e) {
        this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
    }

    function Ir(e, t) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
    }

    function zr(e, t, i) {
        Dt.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function Nr(e, t, i, n) {
        this.ray = new q(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Br(e, t) {
        return e.distance - t.distance
    }

    function Fr(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) {
            n = 0;
            for (var r = (e = e.children).length; n < r; n++) Fr(e[n], t, i, !0)
        }
    }

    function kr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function Ur(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Hr(e, t) {
        this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
    }

    function Gr(e, t) {
        this.start = void 0 !== e ? e : new r, this.end = void 0 !== t ? t : new r
    }

    function jr(e) {
        T.call(this), this.material = e, this.render = function() {}
    }

    function Vr(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count), i = new k, t = new z(6 * t, 3), i.addAttribute("position", t), Ut.call(this, i, new Ft({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Wr(e, t) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, e = new k, t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; 32 > i; i++, n++) {
            var r = i / 32 * Math.PI * 2,
                o = n / 32 * Math.PI * 2;
            t.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        e.addAttribute("position", new z(t, 3)), t = new Ft({
            fog: !1
        }), this.cone = new Ut(e, t), this.add(this.cone), this.update()
    }

    function qr(e) {
        var t = [];
        e && e.isBone && t.push(e);
        for (var i = 0; i < e.children.length; i++) t.push.apply(t, qr(e.children[i]));
        return t
    }

    function Xr(e) {
        for (var t = qr(e), i = new k, n = [], r = [], o = new b(0, 0, 1), a = new b(0, 1, 0), s = 0; s < t.length; s++) {
            var l = t[s];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
        }
        i.addAttribute("position", new z(n, 3)), i.addAttribute("color", new z(r, 3)), n = new Ft({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Ut.call(this, i, n), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function Yr(e, t, i) {
        this.light = e, this.light.updateMatrixWorld(), this.color = i, e = new Bi(t, 4, 2), t = new Y({
            wireframe: !0,
            fog: !1
        }), Z.call(this, e, t), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Zr(e, t) {
        this.type = "RectAreaLightHelper", this.light = e, this.color = t, (e = new k).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), e.computeBoundingSphere(), t = new Ft({
            fog: !1
        }), kt.call(this, e, t), (e = new k).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), e.computeBoundingSphere(), this.add(new Z(e, new Y({
            side: 1,
            fog: !1
        }))), this.update()
    }

    function Jr(e, t, i) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (e = new ii(t)).rotateY(.5 * Math.PI), this.material = new Y({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2), t = e.getAttribute("position"), t = new Float32Array(3 * t.count), e.addAttribute("color", new A(t, 3)), this.add(new Z(e, this.material)), this.update()
    }

    function Qr(e, t) {
        this.lightProbe = e, this.size = t, e = new W({
            defines: {
                GAMMA_OUTPUT: ""
            },
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
        }), t = new Bi(1, 32, 16), Z.call(this, t, e), this.onBeforeRender()
    }

    function $r(e, t, i, n) {
        e = e || 10, t = t || 10, i = new b(void 0 !== i ? i : 4473924), n = new b(void 0 !== n ? n : 8947848);
        var r = t / 2,
            o = e / t,
            a = e / 2;
        e = [];
        for (var s = [], l = 0, c = 0, h = -a; l <= t; l++, h += o) {
            e.push(-a, 0, h, a, 0, h), e.push(h, 0, -a, h, 0, a);
            var u = l === r ? i : n;
            u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3
        }(t = new k).addAttribute("position", new z(e, 3)), t.addAttribute("color", new z(s, 3)), i = new Ft({
            vertexColors: 2
        }), Ut.call(this, t, i)
    }

    function Kr(e, t, i, n, r, o) {
        e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new b(void 0 !== r ? r : 4473924), o = new b(void 0 !== o ? o : 8947848);
        var a, s = [],
            l = [];
        for (a = 0; a <= t; a++) {
            var c = a / t * 2 * Math.PI,
                h = Math.sin(c) * e;
            c = Math.cos(c) * e, s.push(0, 0, 0), s.push(h, 0, c);
            var u = 1 & a ? r : o;
            l.push(u.r, u.g, u.b), l.push(u.r, u.g, u.b)
        }
        for (a = 0; a <= i; a++) {
            u = 1 & a ? r : o;
            var d = e - e / i * a;
            for (t = 0; t < n; t++) c = t / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, s.push(h, 0, c), l.push(u.r, u.g, u.b), c = (t + 1) / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, s.push(h, 0, c), l.push(u.r, u.g, u.b)
        }(e = new k).addAttribute("position", new z(s, 3)), e.addAttribute("color", new z(l, 3)), s = new Ft({
            vertexColors: 2
        }), Ut.call(this, e, s)
    }

    function eo(e, t, i, n) {
        this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, e = new k, t = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), e.addAttribute("position", new A(t, 3)), t = new Ft({
            color: 65280
        }), i = new Ft({
            color: 16776960
        }), kt.call(this, e, [i, t]), this.update()
    }

    function to(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new k, t = new z(6 * t, 3), i.addAttribute("position", t), Ut.call(this, i, new Ft({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function io(e, t, i) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1), (e = new k).addAttribute("position", new z([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), t = new Ft({
            fog: !1
        }), this.lightPlane = new kt(e, t), this.add(this.lightPlane), (e = new k).addAttribute("position", new z([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new kt(e, t), this.add(this.targetLine), this.update()
    }

    function no(e) {
        function t(e, t, n) {
            i(e, n), i(t, n)
        }

        function i(e, t) {
            o.push(0, 0, 0), a.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(o.length / 3 - 1)
        }
        var n = new k,
            r = new Ft({
                color: 16777215,
                vertexColors: 1
            }),
            o = [],
            a = [],
            s = {},
            l = new b(16755200),
            c = new b(16711680),
            h = new b(43775),
            u = new b(16777215),
            d = new b(3355443);
        t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", h), t("u2", "u3", h), t("u3", "u1", h), t("c", "t", u), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), n.addAttribute("position", new z(o, 3)), n.addAttribute("color", new z(a, 3)), Ut.call(this, n, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
    }

    function ro(e, t) {
        this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24),
            n = new k;
        n.setIndex(new A(e, 1)), n.addAttribute("position", new A(i, 3)), Ut.call(this, n, new Ft({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function oo(e, t) {
        this.type = "Box3Helper", this.box = e, e = void 0 !== t ? t : 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new k;
        i.setIndex(new A(t, 1)), i.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ut.call(this, i, new Ft({
            color: e
        })), this.geometry.computeBoundingSphere()
    }

    function ao(e, t, i) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== i ? i : 16776960, (t = new k).addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), t.computeBoundingSphere(), kt.call(this, t, new Ft({
            color: e
        })), (t = new k).addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), this.add(new Z(t, new Y({
            color: e,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function so(e, t, i, n, o, a) {
        T.call(this), void 0 === e && (e = new r(0, 0, 1)), void 0 === t && (t = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === a && (a = .2 * o), void 0 === la && ((la = new k).addAttribute("position", new z([0, 0, 0, 0, 1, 0], 3)), (ca = new Xi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new kt(la, new Ft({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(ca, new Y({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, o, a)
    }

    function lo(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
        (e = new k).addAttribute("position", new z(t, 3)), e.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new Ft({
            vertexColors: 2
        }), Ut.call(this, e, t)
    }

    function co(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), zn.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function ho(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), zn.call(this, e), this.type = "catmullrom"
    }

    function uo(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), zn.call(this, e), this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function(e) {
        return 0 > e ? -1 : 0 < e ? 1 : +e
    }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n)
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }), Object.assign(t.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            void 0 !== this._listeners && (void 0 !== (e = this._listeners[e]) && (-1 !== (t = e.indexOf(t)) && e.splice(t, 1)))
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = 0, n = (t = t.slice(0)).length; i < n; i++) t[i].call(this, e)
                }
            }
        }
    });
    var po, fo = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var e = [], t = 0; 256 > t; t++) e[t] = (16 > t ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function(e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * fo.DEG2RAD
        },
        radToDeg: function(e) {
            return e * fo.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return !(e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function(e) {
            return this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function(e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x,
                i = this.y;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6], this.y = e[1] * t + e[4] * i + e[7], this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return 0 > e && (e += 2 * Math.PI), e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x;
            return t * t + (e = this.y - e.y) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function(e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = this.x - e.x,
                r = this.y - e.y;
            return this.x = n * i - r * t + e.x, this.y = n * t + r * i + e.y, this
        }
    }), Object.assign(n, {
        slerp: function(e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function(e, t, i, n, r, o, a) {
            var s = i[n + 0],
                l = i[n + 1],
                c = i[n + 2];
            i = i[n + 3], n = r[o + 0];
            var h = r[o + 1],
                u = r[o + 2];
            if (i !== (r = r[o + 3]) || s !== n || l !== h || c !== u) {
                o = 1 - a;
                var d = s * n + l * h + c * u + i * r,
                    p = 0 <= d ? 1 : -1,
                    f = 1 - d * d;
                f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, a = Math.sin(a * d) / f), s = s * o + n * (p *= a), l = l * o + h * p, c = c * o + u * p, i = i * o + r * p, o === 1 - a && (s *= a = 1 / Math.sqrt(s * s + l * l + c * c + i * i), l *= a, c *= a, i *= a)
            }
            e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = i
        }
    }), Object.defineProperties(n.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(n.prototype, {
        isQuaternion: !0,
        set: function(e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e.order;
            var o = Math.cos,
                a = Math.sin,
                s = o(i / 2),
                l = o(n / 2);
            return o = o(r / 2), i = a(i / 2), n = a(n / 2), r = a(r / 2), "XYZ" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o - i * n * r) : "YXZ" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o + i * n * r) : "ZXY" === e ? (this._x = i * l * o - s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o - i * n * r) : "ZYX" === e ? (this._x = i * l * o - s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o + i * n * r) : "YZX" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o - i * n * r) : "XZY" === e && (this._x = i * l * o - s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o + i * n * r), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(e, t) {
            t /= 2;
            var i = Math.sin(t);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(t), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e) {
            var t = e.elements,
                i = t[0];
            e = t[4];
            var n = t[8],
                r = t[1],
                o = t[5],
                a = t[9],
                s = t[2],
                l = t[6],
                c = i + o + (t = t[10]);
            return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - a) * i, this._y = (n - s) * i, this._z = (r - e) * i) : i > o && i > t ? (i = 2 * Math.sqrt(1 + i - o - t), this._w = (l - a) / i, this._x = .25 * i, this._y = (e + r) / i, this._z = (n + s) / i) : o > t ? (i = 2 * Math.sqrt(1 + o - i - t), this._w = (n - s) / i, this._x = (e + r) / i, this._y = .25 * i, this._z = (a + l) / i) : (i = 2 * Math.sqrt(1 + t - i - o), this._w = (r - e) / i, this._x = (n + s) / i, this._y = (a + l) / i, this._z = .25 * i), this.onChangeCallback(), this
        },
        setFromUnitVectors: function(e, t) {
            var i = e.dot(t) + 1;
            return 1e-6 > i ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(fo.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var i = this.angleTo(e);
            return 0 === i || this.slerp(e, Math.min(1, t / i)), this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e._w;
            var o = t._x,
                a = t._y,
                s = t._z;
            return t = t._w, this._x = i * t + e * o + n * s - r * a, this._y = n * t + e * a + r * o - i * s, this._z = r * t + e * s + i * a - n * o, this._w = e * t - i * o - n * a - r * s, this.onChangeCallback(), this
        },
        slerp: function(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x,
                n = this._y,
                r = this._z,
                o = this._w,
                a = o * e._w + i * e._x + n * e._y + r * e._z;
            if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), 1 <= a) return this._w = o, this._x = i, this._y = n, this._z = r, this;
            if ((e = 1 - a * a) <= Number.EPSILON) return a = 1 - t, this._w = a * o + t * this._w, this._x = a * i + t * this._x, this._y = a * n + t * this._y, this._z = a * r + t * this._z, this.normalize();
            e = Math.sqrt(e);
            var s = Math.atan2(e, a);
            return a = Math.sin((1 - t) * s) / e, t = Math.sin(t * s) / e, this._w = o * a + this._w * t, this._x = i * a + this._x * t, this._y = n * a + this._y * t, this._z = r * a + this._z * t, this.onChangeCallback(), this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(r.prototype, {
        isVector3: !0,
        set: function(e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setScalar: function(e) {
            return this.z = this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: (po = new n, function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(po.setFromEuler(e))
        }),
        applyAxisAngle: function() {
            var e = new n;
            return function(t, i) {
                return this.applyQuaternion(e.setFromAxisAngle(t, i))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
        },
        applyQuaternion: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = e.x,
                o = e.y,
                a = e.z,
                s = (e = e.w) * t + o * n - a * i,
                l = e * i + a * t - r * n,
                c = e * n + r * i - o * t;
            return t = -r * t - o * i - a * n, this.x = s * e + t * -r + l * -a - c * -o, this.y = l * e + t * -o + c * -r - s * -a, this.z = c * e + t * -a + s * -o - l * -r, this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = t.x,
                o = t.y;
            return t = t.z, this.x = n * t - e * o, this.y = e * r - i * t, this.z = i * o - n * r, this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function() {
            var e = new r;
            return function(t) {
                return e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function() {
            var e = new r;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()), Math.acos(fo.clamp(e, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return t * t + i * i + (e = this.z - e.z) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, i) {
            return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
        },
        setFromMatrixPosition: function(e) {
            return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                i = this.setFromMatrixColumn(e, 1).length();
            return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(o.prototype, {
        isMatrix3: !0,
        set: function(e, t, i, n, r, o, a, s, l) {
            var c = this.elements;
            return c[0] = e, c[1] = n, c[2] = a, c[3] = t, c[4] = r, c[5] = s, c[6] = i, c[7] = o, c[8] = l, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
        },
        setFromMatrix4: function(e) {
            return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function() {
            var e = new r;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[3],
                o = i[6],
                a = i[1],
                s = i[4],
                l = i[7],
                c = i[2],
                h = i[5];
            i = i[8];
            var u = n[0],
                d = n[3],
                p = n[6],
                f = n[1],
                m = n[4],
                g = n[7],
                v = n[2],
                y = n[5];
            return n = n[8], t[0] = e * u + r * f + o * v, t[3] = e * d + r * m + o * y, t[6] = e * p + r * g + o * n, t[1] = a * u + s * f + l * v, t[4] = a * d + s * m + l * y, t[7] = a * p + s * g + l * n, t[2] = c * u + h * f + i * v, t[5] = c * d + h * m + i * y, t[8] = c * p + h * g + i * n, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[1],
                n = e[2],
                r = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                l = e[7];
            return t * o * (e = e[8]) - t * a * l - i * r * e + i * a * s + n * r * l - n * o * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = e.elements;
            e = this.elements;
            var n = i[0],
                r = i[1],
                o = i[2],
                a = i[3],
                s = i[4],
                l = i[5],
                c = i[6],
                h = i[7],
                u = (i = i[8]) * s - l * h,
                d = l * c - i * a,
                p = h * a - s * c,
                f = n * u + r * d + o * p;
            if (0 === f) {
                if (!0 === t) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / f, e[0] = u * t, e[1] = (o * h - i * r) * t, e[2] = (l * r - o * s) * t, e[3] = d * t, e[4] = (i * n - o * c) * t, e[5] = (o * a - l * n) * t, e[6] = p * t, e[7] = (r * c - h * n) * t, e[8] = (s * n - r * a) * t, this
        },
        transpose: function() {
            var e = this.elements,
                t = e[1];
            return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        setUvTransform: function(e, t, i, n, r, o, a) {
            var s = Math.cos(r);
            r = Math.sin(r), this.set(i * s, i * r, -i * (s * o + r * a) + o + e, -n * r, n * s, -n * (-r * o + s * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var i = this.elements;
            return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
        },
        rotate: function(e) {
            var t = Math.cos(e);
            e = Math.sin(e);
            var i = this.elements,
                n = i[0],
                r = i[3],
                o = i[6],
                a = i[1],
                s = i[4],
                l = i[7];
            return i[0] = t * n + e * a, i[3] = t * r + e * s, i[6] = t * o + e * l, i[1] = -e * n + t * a, i[4] = -e * r + t * s, i[7] = -e * o + t * l, this
        },
        translate: function(e, t) {
            var i = this.elements;
            return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 9 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        }
    });
    var mo, go = {
            getDataURL: function(e) {
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (!(e instanceof HTMLCanvasElement)) {
                    void 0 === mo && (mo = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), mo.width = e.width, mo.height = e.height;
                    var t = mo.getContext("2d");
                    e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), e = mo
                }
                return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        vo = 0;
    a.DEFAULT_IMAGE = void 0, a.DEFAULT_MAPPING = 300, a.prototype = Object.assign(Object.create(t.prototype), {
        constructor: a,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = fo.generateUUID()), !t && void 0 === e.images[n.uuid]) {
                    if (Array.isArray(n))
                        for (var r = [], o = 0, a = n.length; o < a; o++) r.push(go.getDataURL(n[o]));
                    else r = go.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i), i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
                case 1e3:
                    e.x -= Math.floor(e.x);
                    break;
                case 1001:
                    e.x = 0 > e.x ? 0 : 1;
                    break;
                case 1002:
                    e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
            }
            if (0 > e.y || 1 < e.y) switch (this.wrapT) {
                case 1e3:
                    e.y -= Math.floor(e.y);
                    break;
                case 1001:
                    e.y = 0 > e.y ? 0 : 1;
                    break;
                case 1002:
                    e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(a.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(s.prototype, {
        isVector4: !0,
        set: function(e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        },
        setScalar: function(e) {
            return this.w = this.z = this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setW: function(e) {
            return this.w = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t = (e = e.elements)[0],
                i = e[4],
                n = e[8],
                r = e[1],
                o = e[5],
                a = e[9],
                s = e[2],
                l = e[6],
                c = e[10];
            return .01 > Math.abs(i - r) && .01 > Math.abs(n - s) && .01 > Math.abs(a - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + s) && .1 > Math.abs(a + l) && .1 > Math.abs(t + o + c - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, c = (c + 1) / 2, i = (i + r) / 4, n = (n + s) / 4, a = (a + l) / 4, (t = (t + 1) / 2) > (o = (o + 1) / 2) && t > c ? .01 > t ? (l = 0, i = s = .707106781) : (s = i / (l = Math.sqrt(t)), i = n / l) : o > c ? .01 > o ? (l = .707106781, s = 0, i = .707106781) : (l = i / (s = Math.sqrt(o)), i = a / s) : .01 > c ? (s = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(c)), s = a / i), this.set(l, s, i, e), this) : (e = Math.sqrt((l - a) * (l - a) + (n - s) * (n - s) + (r - i) * (r - i)), .001 > Math.abs(e) && (e = 1), this.x = (l - a) / e, this.y = (n - s) / e, this.z = (r - i) / e, this.w = Math.acos((t + o + c - 1) / 2), this)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function() {
            var e, t;
            return function(i, n) {
                return void 0 === e && (e = new s, t = new s), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), l.prototype = Object.assign(Object.create(t.prototype), {
        constructor: l,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), c.prototype = Object.assign(Object.create(l.prototype), {
        constructor: c,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return l.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    }), h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.prototype.isWebGLRenderTargetCube = !0, u.prototype = Object.create(a.prototype), u.prototype.constructor = u, u.prototype.isDataTexture = !0, Object.assign(d.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                var c = e[s],
                    h = e[s + 1],
                    u = e[s + 2];
                c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, i, n), this.max.set(r, o, a), this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.count; s < l; s++) {
                var c = e.getX(s),
                    h = e.getY(s),
                    u = e.getZ(s);
                c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, i, n), this.max.set(r, o, a), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new r;
            return function(t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function() {
            function e(e) {
                var r = e.geometry;
                if (void 0 !== r)
                    if (r.isGeometry)
                        for (r = r.vertices, i = 0, n = r.length; i < n; i++) o.copy(r[i]), o.applyMatrix4(e.matrixWorld), t.expandByPoint(o);
                    else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position))
                    for (i = 0, n = r.count; i < n; i++) o.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), t.expandByPoint(o)
            }
            var t, i, n, o = new r;
            return function(i) {
                return t = this, i.updateMatrixWorld(!0), i.traverse(e), this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new r), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var e = new r;
            return function(t) {
                return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function(e) {
            if (0 < e.normal.x) var t = e.normal.x * this.min.x,
                i = e.normal.x * this.max.x;
            else t = e.normal.x * this.max.x, i = e.normal.x * this.min.x;
            return 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
        },
        intersectsTriangle: function() {
            function e(e) {
                var r, o = 0;
                for (r = e.length - 3; o <= r; o += 3) {
                    l.fromArray(e, o);
                    var a = h.x * Math.abs(l.x) + h.y * Math.abs(l.y) + h.z * Math.abs(l.z),
                        s = t.dot(l),
                        c = i.dot(l),
                        u = n.dot(l);
                    if (Math.max(-Math.max(s, c, u), Math.min(s, c, u)) > a) return !1
                }
                return !0
            }
            var t = new r,
                i = new r,
                n = new r,
                o = new r,
                a = new r,
                s = new r,
                l = new r,
                c = new r,
                h = new r,
                u = new r;
            return function(r) {
                return !this.isEmpty() && (this.getCenter(c), h.subVectors(this.max, c), t.subVectors(r.a, c), i.subVectors(r.b, c), n.subVectors(r.c, c), o.subVectors(i, t), a.subVectors(n, i), s.subVectors(t, n), !!e(r = [0, -o.z, o.y, 0, -a.z, a.y, 0, -s.z, s.y, o.z, 0, -o.x, a.z, 0, -a.x, s.z, 0, -s.x, -o.y, o.x, 0, -a.y, a.x, 0, -s.y, s.x, 0]) && (!!e(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(o, a), e(r = [u.x, u.y, u.z]))))
            }
        }(),
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new r), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new r;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new r;
            return function(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function() {
            var e = [new r, new r, new r, new r, new r, new r, new r, new r];
            return function(t) {
                return this.isEmpty() || (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e)), this
            }
        }(),
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(p.prototype, {
        set: function(e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function() {
            var e = new d;
            return function(t, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : e.setFromPoints(t).getCenter(n);
                for (var r = i = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new r), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new d), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function(e) {
            return this.center.add(e), this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(f.prototype, {
        set: function(e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function(e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var e = new r,
                t = new r;
            return function(i, n, r) {
                return n = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function() {
            var e = new r;
            return function(t, i) {
                void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new r);
                var n = t.delta(e),
                    o = this.normal.dot(n);
                if (0 === o) {
                    if (0 === this.distanceToPoint(t.start)) return i.copy(t.start)
                } else if (!(0 > (o = -(t.start.dot(this.normal) + this.constant) / o) || 1 < o)) return i.copy(n).multiplyScalar(o).add(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new r,
                t = new o;
            return function(i, n) {
                return n = n || t.getNormalMatrix(i), i = this.coplanarPoint(e).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(m.prototype, {
        set: function(e, t, i, n, r, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes,
                i = e.elements;
            e = i[0];
            var n = i[1],
                r = i[2],
                o = i[3],
                a = i[4],
                s = i[5],
                l = i[6],
                c = i[7],
                h = i[8],
                u = i[9],
                d = i[10],
                p = i[11],
                f = i[12],
                m = i[13],
                g = i[14];
            return i = i[15], t[0].setComponents(o - e, c - a, p - h, i - f).normalize(), t[1].setComponents(o + e, c + a, p + h, i + f).normalize(), t[2].setComponents(o + n, c + s, p + u, i + m).normalize(), t[3].setComponents(o - n, c - s, p - u, i - m).normalize(), t[4].setComponents(o - r, c - l, p - d, i - g).normalize(), t[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
        },
        intersectsObject: function() {
            var e = new p;
            return function(t) {
                var i = t.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function() {
            var e = new p;
            return function(t) {
                return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var n = 0; 6 > n; n++)
                if (t[n].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function() {
            var e = new r;
            return function(t) {
                for (var i = this.planes, n = 0; 6 > n; n++) {
                    var r = i[n];
                    if (e.x = 0 < r.normal.x ? t.max.x : t.min.x, e.y = 0 < r.normal.y ? t.max.y : t.min.y, e.z = 0 < r.normal.z ? t.max.z : t.min.z, 0 > r.distanceToPoint(e)) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++)
                if (0 > t[i].distanceToPoint(e)) return !1;
            return !0
        }
    }), Object.assign(g.prototype, {
        isMatrix4: !0,
        set: function(e, t, i, n, r, o, a, s, l, c, h, u, d, p, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new g).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
        },
        copyPosition: function(e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractBasis: function(e, t, i) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var e = new r;
            return function(t) {
                var i = this.elements,
                    n = t.elements,
                    r = 1 / e.setFromMatrixColumn(t, 0).length(),
                    o = 1 / e.setFromMatrixColumn(t, 1).length();
                return t = 1 / e.setFromMatrixColumn(t, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
            }
        }(),
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                o = Math.cos(i);
            i = Math.sin(i);
            var a = Math.cos(n);
            n = Math.sin(n);
            var s = Math.cos(r);
            if (r = Math.sin(r), "XYZ" === e.order) {
                e = o * s;
                var l = o * r,
                    c = i * s,
                    h = i * r;
                t[0] = a * s, t[4] = -a * r, t[8] = n, t[1] = l + c * n, t[5] = e - h * n, t[9] = -i * a, t[2] = h - e * n, t[6] = c + l * n, t[10] = o * a
            } else "YXZ" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e + h * i, t[4] = c * i - l, t[8] = o * n, t[1] = o * r, t[5] = o * s, t[9] = -i, t[2] = l * i - c, t[6] = h + e * i, t[10] = o * a) : "ZXY" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e - h * i, t[4] = -o * r, t[8] = c + l * i, t[1] = l + c * i, t[5] = o * s, t[9] = h - e * i, t[2] = -o * n, t[6] = i, t[10] = o * a) : "ZYX" === e.order ? (e = o * s, l = o * r, c = i * s, h = i * r, t[0] = a * s, t[4] = c * n - l, t[8] = e * n + h, t[1] = a * r, t[5] = h * n + e, t[9] = l * n - c, t[2] = -n, t[6] = i * a, t[10] = o * a) : "YZX" === e.order ? (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = h - e * r, t[8] = c * r + l, t[1] = r, t[5] = o * s, t[9] = -i * s, t[2] = -n * s, t[6] = l * r + c, t[10] = e - h * r) : "XZY" === e.order && (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = -r, t[8] = n * s, t[1] = e * r + h, t[5] = o * s, t[9] = l * r - c, t[2] = c * r - l, t[6] = i * s, t[10] = h * r + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function() {
            var e = new r(0, 0, 0),
                t = new r(1, 1, 1);
            return function(i) {
                return this.compose(e, i, t)
            }
        }(),
        lookAt: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, r, o) {
                var a = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), e.crossVectors(o, i), 0 === e.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(o, i)), e.normalize(), t.crossVectors(i, e), a[0] = e.x, a[4] = t.x, a[8] = i.x, a[1] = e.y, a[5] = t.y, a[9] = i.y, a[2] = e.z, a[6] = t.z, a[10] = i.z, this
            }
        }(),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[4],
                o = i[8],
                a = i[12],
                s = i[1],
                l = i[5],
                c = i[9],
                h = i[13],
                u = i[2],
                d = i[6],
                p = i[10],
                f = i[14],
                m = i[3],
                g = i[7],
                v = i[11];
            i = i[15];
            var y = n[0],
                b = n[4],
                x = n[8],
                w = n[12],
                _ = n[1],
                E = n[5],
                M = n[9],
                T = n[13],
                S = n[2],
                A = n[6],
                C = n[10],
                L = n[14],
                D = n[3],
                P = n[7],
                R = n[11];
            return n = n[15], t[0] = e * y + r * _ + o * S + a * D, t[4] = e * b + r * E + o * A + a * P, t[8] = e * x + r * M + o * C + a * R, t[12] = e * w + r * T + o * L + a * n, t[1] = s * y + l * _ + c * S + h * D, t[5] = s * b + l * E + c * A + h * P, t[9] = s * x + l * M + c * C + h * R, t[13] = s * w + l * T + c * L + h * n, t[2] = u * y + d * _ + p * S + f * D, t[6] = u * b + d * E + p * A + f * P, t[10] = u * x + d * M + p * C + f * R, t[14] = u * w + d * T + p * L + f * n, t[3] = m * y + g * _ + v * S + i * D, t[7] = m * b + g * E + v * A + i * P, t[11] = m * x + g * M + v * C + i * R, t[15] = m * w + g * T + v * L + i * n, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function() {
            var e = new r;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[4],
                n = e[8],
                r = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                l = e[13],
                c = e[2],
                h = e[6],
                u = e[10],
                d = e[14];
            return e[3] * (+r * s * h - n * l * h - r * a * u + i * l * u + n * a * d - i * s * d) + e[7] * (+t * s * d - t * l * u + r * o * u - n * o * d + n * l * c - r * s * c) + e[11] * (+t * l * h - t * a * d - r * o * h + i * o * d + r * a * c - i * l * c) + e[15] * (-n * a * c - t * s * h + t * a * u + n * o * h - i * o * u + i * s * c)
        },
        transpose: function() {
            var e = this.elements,
                t = e[1];
            return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function(e, t, i) {
            var n = this.elements;
            return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
        },
        getInverse: function(e, t) {
            var i = this.elements,
                n = e.elements;
            e = n[0];
            var r = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                l = n[5],
                c = n[6],
                h = n[7],
                u = n[8],
                d = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = d * v * h - g * p * h + g * c * f - l * v * f - d * c * (n = n[15]) + l * p * n,
                b = m * p * h - u * v * h - m * c * f + s * v * f + u * c * n - s * p * n,
                x = u * g * h - m * d * h + m * l * f - s * g * f - u * l * n + s * d * n,
                w = m * d * c - u * g * c - m * l * p + s * g * p + u * l * v - s * d * v,
                _ = e * y + r * b + o * x + a * w;
            if (0 === _) {
                if (!0 === t) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / _, i[0] = y * t, i[1] = (g * p * a - d * v * a - g * o * f + r * v * f + d * o * n - r * p * n) * t, i[2] = (l * v * a - g * c * a + g * o * h - r * v * h - l * o * n + r * c * n) * t, i[3] = (d * c * a - l * p * a - d * o * h + r * p * h + l * o * f - r * c * f) * t, i[4] = b * t, i[5] = (u * v * a - m * p * a + m * o * f - e * v * f - u * o * n + e * p * n) * t, i[6] = (m * c * a - s * v * a - m * o * h + e * v * h + s * o * n - e * c * n) * t, i[7] = (s * p * a - u * c * a + u * o * h - e * p * h - s * o * f + e * c * f) * t, i[8] = x * t, i[9] = (m * d * a - u * g * a - m * r * f + e * g * f + u * r * n - e * d * n) * t, i[10] = (s * g * a - m * l * a + m * r * h - e * g * h - s * r * n + e * l * n) * t, i[11] = (u * l * a - s * d * a - u * r * h + e * d * h + s * r * f - e * l * f) * t, i[12] = w * t, i[13] = (u * g * o - m * d * o + m * r * p - e * g * p - u * r * v + e * d * v) * t, i[14] = (m * l * o - s * g * o - m * r * c + e * g * c + s * r * v - e * l * v) * t, i[15] = (s * d * o - u * l * o + u * r * c - e * d * c - s * r * p + e * l * p) * t, this
        },
        scale: function(e) {
            var t = this.elements,
                i = e.x,
                n = e.y;
            return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
        },
        makeTranslation: function(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = 1 - i,
                r = e.x,
                o = e.y;
            e = e.z;
            var a = n * r,
                s = n * o;
            return this.set(a * r + i, a * o - t * e, a * e + t * o, 0, a * o + t * e, s * o + i, s * e - t * r, 0, a * e - t * o, s * e + t * r, n * e * e + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function(e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(e, t, i) {
            var n = this.elements,
                r = t._x,
                o = t._y,
                a = t._z,
                s = t._w,
                l = r + r,
                c = o + o,
                h = a + a;
            t = r * l;
            var u = r * c;
            r *= h;
            var d = o * c;
            o *= h, a *= h, l *= s, c *= s, s *= h, h = i.x;
            var p = i.y;
            return i = i.z, n[0] = (1 - (d + a)) * h, n[1] = (u + s) * h, n[2] = (r - c) * h, n[3] = 0, n[4] = (u - s) * p, n[5] = (1 - (t + a)) * p, n[6] = (o + l) * p, n[7] = 0, n[8] = (r + c) * i, n[9] = (o - l) * i, n[10] = (1 - (t + d)) * i, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
        },
        decompose: function() {
            var e = new r,
                t = new g;
            return function(i, n, r) {
                var o = this.elements,
                    a = e.set(o[0], o[1], o[2]).length(),
                    s = e.set(o[4], o[5], o[6]).length(),
                    l = e.set(o[8], o[9], o[10]).length();
                0 > this.determinant() && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], t.copy(this), i = 1 / a, o = 1 / s;
                var c = 1 / l;
                return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= c, t.elements[9] *= c, t.elements[10] *= c, n.setFromRotationMatrix(t), r.x = a, r.y = s, r.z = l, this
            }
        }(),
        makePerspective: function(e, t, i, n, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements;
            return a[0] = 2 * r / (t - e), a[4] = 0, a[8] = (t + e) / (t - e), a[12] = 0, a[1] = 0, a[5] = 2 * r / (i - n), a[9] = (i + n) / (i - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + r) / (o - r), a[14] = -2 * o * r / (o - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(e, t, i, n, r, o) {
            var a = this.elements,
                s = 1 / (t - e),
                l = 1 / (i - n),
                c = 1 / (o - r);
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -(t + e) * s, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -(i + n) * l, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -(o + r) * c, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 16 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        }
    });
    var yo = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        bo = {
            clone: v,
            merge: y
        },
        xo = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
    Object.assign(b.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function(e) {
            return this.b = this.g = this.r = e, this
        },
        setHex: function(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function(e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function() {
            function e(e, t, i) {
                return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? e + 6 * (t - e) * i : .5 > i ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }
            return function(t, i, n) {
                return t = fo.euclideanModulo(t, 1), i = fo.clamp(i, 0, 1), n = fo.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i), this.r = e(n, i, t + 1 / 3), this.g = e(n, i, t), this.b = e(n, i, t - 1 / 3)), this
            }
        }(),
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n = i[2];
                switch (i[1]) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                        if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                            n = parseFloat(i[1]) / 360;
                            var r = parseInt(i[2], 10) / 100,
                                o = parseInt(i[3], 10) / 100;
                            return t(i[5]), this.setHSL(n, r, o)
                        }
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(e)) {
                if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
            }
            return e && 0 < e.length && (void 0 !== (i = xo[e]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function(e, t) {
            return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e), this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e), this
        },
        copySRGBToLinear: function() {
            function e(e) {
                return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function(t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        copyLinearToSRGB: function() {
            function e(e) {
                return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function(t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, i = this.r,
                n = this.g,
                r = this.b,
                o = Math.max(i, n, r),
                a = Math.min(i, n, r),
                s = (a + o) / 2;
            if (a === o) a = t = 0;
            else {
                var l = o - a;
                switch (a = .5 >= s ? l / (o + a) : l / (2 - o - a), o) {
                    case i:
                        t = (n - r) / l + (n < r ? 6 : 0);
                        break;
                    case n:
                        t = (r - i) / l + 2;
                        break;
                    case r:
                        t = (i - n) / l + 4
                }
                t /= 6
            }
            return e.h = t, e.s = a, e.l = s, e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var e = {};
            return function(t, i, n) {
                return this.getHSL(e), e.h += t, e.s += i, e.l += n, this.setHSL(e.h, e.s, e.l), this
            }
        }(),
        add: function(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function(e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        lerpHSL: function() {
            var e = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                t = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            return function(i, n) {
                this.getHSL(e), i.getHSL(t), i = fo.lerp(e.h, t.h, n);
                var r = fo.lerp(e.s, t.s, n);
                return n = fo.lerp(e.l, t.l, n), this.setHSL(i, r, n), this
            }
        }(),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var wo = {
            common: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new i(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new b(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            },
            sprite: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new i(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            }
        },
        _o = {
            basic: {
                uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.fog]),
                vertexShader: yo.meshbasic_vert,
                fragmentShader: yo.meshbasic_frag
            },
            lambert: {
                uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.fog, wo.lights, {
                    emissive: {
                        value: new b(0)
                    }
                }]),
                vertexShader: yo.meshlambert_vert,
                fragmentShader: yo.meshlambert_frag
            },
            phong: {
                uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.gradientmap, wo.fog, wo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    specular: {
                        value: new b(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: yo.meshphong_vert,
                fragmentShader: yo.meshphong_frag
            },
            standard: {
                uniforms: y([wo.common, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.roughnessmap, wo.metalnessmap, wo.fog, wo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: yo.meshphysical_vert,
                fragmentShader: yo.meshphysical_frag
            },
            matcap: {
                uniforms: y([wo.common, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: yo.meshmatcap_vert,
                fragmentShader: yo.meshmatcap_frag
            },
            points: {
                uniforms: y([wo.points, wo.fog]),
                vertexShader: yo.points_vert,
                fragmentShader: yo.points_frag
            },
            dashed: {
                uniforms: y([wo.common, wo.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: yo.linedashed_vert,
                fragmentShader: yo.linedashed_frag
            },
            depth: {
                uniforms: y([wo.common, wo.displacementmap]),
                vertexShader: yo.depth_vert,
                fragmentShader: yo.depth_frag
            },
            normal: {
                uniforms: y([wo.common, wo.bumpmap, wo.normalmap, wo.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: yo.normal_vert,
                fragmentShader: yo.normal_frag
            },
            sprite: {
                uniforms: y([wo.sprite, wo.fog]),
                vertexShader: yo.sprite_vert,
                fragmentShader: yo.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new o
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: yo.background_vert,
                fragmentShader: yo.background_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: yo.cube_vert,
                fragmentShader: yo.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: yo.equirect_vert,
                fragmentShader: yo.equirect_frag
            },
            distanceRGBA: {
                uniforms: y([wo.common, wo.displacementmap, {
                    referencePosition: {
                        value: new r
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: yo.distanceRGBA_vert,
                fragmentShader: yo.distanceRGBA_frag
            },
            shadow: {
                uniforms: y([wo.lights, wo.fog, {
                    color: {
                        value: new b(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: yo.shadow_vert,
                fragmentShader: yo.shadow_frag
            }
        };
    _o.physical = {
        uniforms: y([_o.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: yo.meshphysical_vert,
        fragmentShader: yo.meshphysical_frag
    }, Object.assign(_.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }), E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), E.DefaultOrder = "XYZ", Object.defineProperties(E.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(E.prototype, {
        isEuler: !0,
        set: function(e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e, t, i) {
            var n = fo.clamp,
                r = e.elements;
            e = r[0];
            var o = r[4],
                a = r[8],
                s = r[1],
                l = r[5],
                c = r[9],
                h = r[2],
                u = r[6];
            return r = r[10], "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, e)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(a, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-h, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, e))) : "ZYX" === t ? (this._y = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, e)) : (this._x = 0, this._y = Math.atan2(a, r))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, e)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function() {
            var e = new n;
            return function(t) {
                return e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(M.prototype, {
        set: function(e) {
            this.mask = 1 << e
        },
        enable: function(e) {
            this.mask = this.mask | 1 << e
        },
        toggle: function(e) {
            this.mask ^= 1 << e
        },
        disable: function(e) {
            this.mask &= ~(1 << e)
        },
        test: function(e) {
            return 0 !== (this.mask & e.mask)
        }
    });
    var Eo = 0;
    T.DefaultUp = new r(0, 1, 0), T.DefaultMatrixAutoUpdate = !0, T.prototype = Object.assign(Object.create(t.prototype), {
        constructor: T,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function() {
            var e = new n;
            return function(t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
            }
        }(),
        rotateOnWorldAxis: function() {
            var e = new n;
            return function(t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.premultiply(e), this
            }
        }(),
        rotateX: function() {
            var e = new r(1, 0, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new r(0, 1, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new r(0, 0, 1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new r;
            return function(t, i) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
            }
        }(),
        translateX: function() {
            var e = new r(1, 0, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new r(0, 1, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new r(0, 0, 1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var e = new g;
            return function(t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var e = new n,
                t = new g,
                i = new r,
                o = new r;
            return function(n, r, a) {
                n.isVector3 ? i.copy(n) : i.set(n, r, a), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(o, i, this.up) : t.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(t), n && (t.extractRotation(n.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(t, 1)), this
        },
        attach: function() {
            var e = new g;
            return function(t) {
                return this.updateWorldMatrix(!0, !1), e.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), e.multiply(t.parent.matrixWorld)), t.applyMatrix(e), t.updateWorldMatrix(!1, !1), this.add(t), this
            }
        }(),
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new r), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var e = new r,
                t = new r;
            return function(i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
            }
        }(),
        getWorldScale: function() {
            var e = new r,
                t = new n;
            return function(i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
            }
        }(),
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (t = 0, i = (e = this.children).length; t < i; t++) e[t].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            function t(t, i) {
                return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
            }

            function i(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var n = void 0 === e || "string" == typeof e,
                r = {};
            n && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var o = {};
            if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                o.geometry = t(e.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes)
                    if (a = a.shapes, Array.isArray(a))
                        for (var s = 0, l = a.length; s < l; s++) t(e.shapes, a[s]);
                    else t(e.shapes, a)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (a = [], s = 0, l = this.material.length; s < l; s++) a.push(t(e.materials, this.material[s]));
                    o.material = a
                } else o.material = t(e.materials, this.material);
            if (0 < this.children.length)
                for (o.children = [], s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(e).object);
            if (n) {
                n = i(e.geometries), s = i(e.materials), l = i(e.textures);
                var c = i(e.images);
                a = i(e.shapes), 0 < n.length && (r.geometries = n), 0 < s.length && (r.materials = s), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < a.length && (r.shapes = a)
            }
            return r.object = o, r
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
            return this
        }
    });
    var Mo = 0;
    S.prototype = Object.assign(Object.create(t.prototype), {
        constructor: S,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new o).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, n = this.faces.length; i < n; i++) {
                (e = this.faces[i]).normal.applyMatrix3(t).normalize();
                for (var r = 0, a = e.vertexNormals.length; r < a; r++) e.vertexNormals[r].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
        },
        rotateX: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new T;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function(e) {
            function t(e, t, o, a) {
                var s = void 0 === c ? [] : [n.colors[e].clone(), n.colors[t].clone(), n.colors[o].clone()];
                a = new _(e, t, o, void 0 === l ? [] : [(new r).fromArray(l, 3 * e), (new r).fromArray(l, 3 * t), (new r).fromArray(l, 3 * o)], s, a), n.faces.push(a), void 0 !== h && n.faceVertexUvs[0].push([(new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * o)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * o)])
            }
            var n = this,
                o = null !== e.index ? e.index.array : void 0,
                a = e.attributes,
                s = a.position.array,
                l = void 0 !== a.normal ? a.normal.array : void 0,
                c = void 0 !== a.color ? a.color.array : void 0,
                h = void 0 !== a.uv ? a.uv.array : void 0,
                u = void 0 !== a.uv2 ? a.uv2.array : void 0;
            for (void 0 !== u && (this.faceVertexUvs[1] = []), a = 0; a < s.length; a += 3) n.vertices.push((new r).fromArray(s, a)), void 0 !== c && n.colors.push((new b).fromArray(c, a));
            var d = e.groups;
            if (0 < d.length)
                for (a = 0; a < d.length; a++) {
                    var p = (s = d[a]).start,
                        f = p;
                    for (p += s.count; f < p; f += 3) void 0 !== o ? t(o[f], o[f + 1], o[f + 2], s.materialIndex) : t(f, f + 1, f + 2, s.materialIndex)
                } else if (void 0 !== o)
                    for (a = 0; a < o.length; a += 3) t(o[a], o[a + 1], o[a + 2]);
                else
                    for (a = 0; a < s.length / 3; a += 3) t(a, a + 1, a + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            var e = new r;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius;
            t = 0 === t ? 1 : 1 / t;
            var i = new g;
            return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix(i), this
        },
        computeFaceNormals: function() {
            for (var e = new r, t = new r, i = 0, n = this.faces.length; i < n; i++) {
                var o = this.faces[i],
                    a = this.vertices[o.a],
                    s = this.vertices[o.b];
                e.subVectors(this.vertices[o.c], s), t.subVectors(a, s), e.cross(t), e.normalize(), o.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t;
            void 0 === e && (e = !0);
            var i = Array(this.vertices.length),
                n = 0;
            for (t = this.vertices.length; n < t; n++) i[n] = new r;
            if (e) {
                var o = new r,
                    a = new r;
                for (e = 0, n = this.faces.length; e < n; e++) {
                    t = this.faces[e];
                    var s = this.vertices[t.a],
                        l = this.vertices[t.b],
                        c = this.vertices[t.c];
                    o.subVectors(c, l), a.subVectors(s, l), o.cross(a), i[t.a].add(o), i[t.b].add(o), i[t.c].add(o)
                }
            } else
                for (this.computeFaceNormals(), e = 0, n = this.faces.length; e < n; e++) i[(t = this.faces[e]).a].add(t.normal), i[t.b].add(t.normal), i[t.c].add(t.normal);
            for (n = 0, t = this.vertices.length; n < t; n++) i[n].normalize();
            for (e = 0, n = this.faces.length; e < n; e++) 3 === (s = (t = this.faces[e]).vertexNormals).length ? (s[0].copy(i[t.a]), s[1].copy(i[t.b]), s[2].copy(i[t.c])) : (s[0] = i[t.a].clone(), s[1] = i[t.b].clone(), s[2] = i[t.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e;
            this.computeFaceNormals();
            var t = 0;
            for (e = this.faces.length; t < e; t++) {
                var i = this.faces[t],
                    n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, i = 0;
            for (t = this.faces.length; i < t; i++) {
                var n = this.faces[i];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                var o = 0;
                for (e = n.vertexNormals.length; o < e; o++) n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone()
            }
            var a = new S;
            for (a.faces = this.faces, o = 0, e = this.morphTargets.length; o < e; o++) {
                if (!this.morphNormals[o]) {
                    this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
                    var s = this.morphNormals[o].vertexNormals;
                    for (i = 0, t = this.faces.length; i < t; i++) {
                        var l = new r,
                            c = {
                                a: new r,
                                b: new r,
                                c: new r
                            };
                        n.push(l), s.push(c)
                    }
                }
                for (s = this.morphNormals[o], a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, t = this.faces.length; i < t; i++) n = this.faces[i], l = s.faceNormals[i], c = s.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
            }
            for (i = 0, t = this.faces.length; i < t; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length,
                    a = this.vertices,
                    s = e.vertices,
                    l = this.faces,
                    c = e.faces,
                    h = this.faceVertexUvs[0],
                    u = e.faceVertexUvs[0],
                    d = this.colors,
                    p = e.colors;
                void 0 === i && (i = 0), void 0 !== t && (n = (new o).getNormalMatrix(t)), e = 0;
                for (var f = s.length; e < f; e++) {
                    var m = s[e].clone();
                    void 0 !== t && m.applyMatrix4(t), a.push(m)
                }
                for (e = 0, f = p.length; e < f; e++) d.push(p[e].clone());
                for (e = 0, f = c.length; e < f; e++) {
                    var g = (s = c[e]).vertexNormals;
                    for (p = s.vertexColors, (d = new _(s.a + r, s.b + r, s.c + r)).normal.copy(s.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize(), t = 0, a = g.length; t < a; t++) m = g[t].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), d.vertexNormals.push(m);
                    for (d.color.copy(s.color), t = 0, a = p.length; t < a; t++) m = p[t], d.vertexColors.push(m.clone());
                    d.materialIndex = s.materialIndex + i, l.push(d)
                }
                for (e = 0, f = u.length; e < f; e++)
                    if (n = [], void 0 !== (i = u[e])) {
                        for (t = 0, a = i.length; t < a; t++) n.push(i[t].clone());
                        h.push(n)
                    }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t = {},
                i = [],
                n = [],
                r = Math.pow(10, 4),
                o = 0;
            for (e = this.vertices.length; o < e; o++) {
                var a = this.vertices[o];
                void 0 === t[a = Math.round(a.x * r) + "_" + Math.round(a.y * r) + "_" + Math.round(a.z * r)] ? (t[a] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[t[a]]
            }
            for (t = [], o = 0, e = this.faces.length; o < e; o++)
                for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], a = 0; 3 > a; a++)
                    if (r[a] === r[(a + 1) % 3]) {
                        t.push(o);
                        break
                    } for (o = t.length - 1; 0 <= o; o--)
                for (r = t[o], this.faces.splice(r, 1), n = 0, e = this.faceVertexUvs.length; n < e; n++) this.faceVertexUvs[n].splice(r, 1);
            return o = this.vertices.length - i.length, this.vertices = i, o
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new r(n.x, n.y, n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
            e.sort((function(e, t) {
                return e.materialIndex - t.materialIndex
            }));
            var n, r, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            for (o && o.length === t && (n = []), a && a.length === t && (r = []), i = 0; i < t; i++) {
                var s = e[i]._id;
                n && n.push(o[s]), r && r.push(a[s])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] || (c[t] = l.length / 3, l.push(e.x, e.y, e.z)), c[t]
            }

            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] || (u[t] = h.length, h.push(e.getHex())), u[t]
            }

            function n(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] || (p[t] = d.length / 2, d.push(e.x, e.y)), p[t]
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var o, a = this.parameters;
                for (o in a) void 0 !== a[o] && (r[o] = a[o]);
                return r
            }
            for (a = [], o = 0; o < this.vertices.length; o++) {
                var s = this.vertices[o];
                a.push(s.x, s.y, s.z)
            }
            s = [];
            var l = [],
                c = {},
                h = [],
                u = {},
                d = [],
                p = {};
            for (o = 0; o < this.faces.length; o++) {
                var f = this.faces[o],
                    m = void 0 !== this.faceVertexUvs[0][o],
                    g = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length,
                    y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    b = 0 < f.vertexColors.length,
                    x = 0;
                x = e(x, 0, 0), x = e(x, 1, !0), x = e(x, 2, !1), x = e(x, 3, m), x = e(x, 4, g), x = e(x, 5, v), x = e(x, 6, y), x = e(x, 7, b), s.push(x), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(t(f.normal)), v && (g = f.vertexNormals, s.push(t(g[0]), t(g[1]), t(g[2]))), y && s.push(i(f.color)), b && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {}, r.data.vertices = a, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < d.length && (r.data.uvs = [d]), r.data.faces = s, r
        },
        clone: function() {
            return (new S).copy(this)
        },
        copy: function(e) {
            var t, i, n;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var r = e.vertices,
                o = 0;
            for (t = r.length; o < t; o++) this.vertices.push(r[o].clone());
            for (o = 0, t = (r = e.colors).length; o < t; o++) this.colors.push(r[o].clone());
            for (o = 0, t = (r = e.faces).length; o < t; o++) this.faces.push(r[o].clone());
            for (o = 0, t = e.faceVertexUvs.length; o < t; o++) {
                var a = e.faceVertexUvs[o];
                for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = a.length; r < i; r++) {
                    var s = a[r],
                        l = [],
                        c = 0;
                    for (n = s.length; c < n; c++) l.push(s[c].clone());
                    this.faceVertexUvs[o].push(l)
                }
            }
            for (o = 0, t = (c = e.morphTargets).length; o < t; o++) {
                if ((n = {}).name = c[o].name, void 0 !== c[o].vertices)
                    for (n.vertices = [], r = 0, i = c[o].vertices.length; r < i; r++) n.vertices.push(c[o].vertices[r].clone());
                if (void 0 !== c[o].normals)
                    for (n.normals = [], r = 0, i = c[o].normals.length; r < i; r++) n.normals.push(c[o].normals[r].clone());
                this.morphTargets.push(n)
            }
            for (o = 0, t = (c = e.morphNormals).length; o < t; o++) {
                if (n = {}, void 0 !== c[o].vertexNormals)
                    for (n.vertexNormals = [], r = 0, i = c[o].vertexNormals.length; r < i; r++) a = c[o].vertexNormals[r], (s = {}).a = a.a.clone(), s.b = a.b.clone(), s.c = a.c.clone(), n.vertexNormals.push(s);
                if (void 0 !== c[o].faceNormals)
                    for (n.faceNormals = [], r = 0, i = c[o].faceNormals.length; r < i; r++) n.faceNormals.push(c[o].faceNormals[r].clone());
                this.morphNormals.push(n)
            }
            for (o = 0, t = (r = e.skinWeights).length; o < t; o++) this.skinWeights.push(r[o].clone());
            for (o = 0, t = (r = e.skinIndices).length; o < t; o++) this.skinIndices.push(r[o].clone());
            for (o = 0, t = (r = e.lineDistances).length; o < t; o++) this.lineDistances.push(r[o]);
            return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()), null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(A.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(A.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
        },
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e), this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new b), t[i++] = o.r, t[i++] = o.g, t[i++] = o.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, o = e.length; r < o; r++) {
                var a = e[r];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), t[n++] = a.x, t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, o = e.length; n < o; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new r), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new s), t[i++] = o.x, t[i++] = o.y, t[i++] = o.z, t[i++] = o.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function(e, t, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
        },
        setXYZ: function(e, t, i, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
        },
        setXYZW: function(e, t, i, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), C.prototype = Object.create(A.prototype), C.prototype.constructor = C, L.prototype = Object.create(A.prototype), L.prototype.constructor = L, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, P.prototype = Object.create(A.prototype), P.prototype.constructor = P, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, z.prototype = Object.create(A.prototype), z.prototype.constructor = z, N.prototype = Object.create(A.prototype), N.prototype.constructor = N, Object.assign(B.prototype, {
        computeGroups: function(e) {
            var t = [],
                i = void 0;
            e = e.faces;
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                if (r.materialIndex !== i) {
                    i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, t.push(o));
                    var o = {
                        start: 3 * n,
                        materialIndex: i
                    }
                }
            }
            void 0 !== o && (o.count = 3 * n - o.start, t.push(o)), this.groups = t
        },
        fromGeometry: function(e) {
            var t = e.faces,
                n = e.vertices,
                r = e.faceVertexUvs,
                o = r[0] && 0 < r[0].length,
                a = r[1] && 0 < r[1].length,
                s = e.morphTargets,
                l = s.length;
            if (0 < l) {
                for (var c = [], h = 0; h < l; h++) c[h] = {
                    name: s[h].name,
                    data: []
                };
                this.morphTargets.position = c
            }
            var u = e.morphNormals,
                d = u.length;
            if (0 < d) {
                var p = [];
                for (h = 0; h < d; h++) p[h] = {
                    name: u[h].name,
                    data: []
                };
                this.morphTargets.normal = p
            }
            var f = e.skinIndices,
                m = e.skinWeights,
                g = f.length === n.length,
                v = m.length === n.length;
            for (0 < n.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < t.length; h++) {
                var y = t[h];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var b = y.vertexNormals;
                for (3 === b.length ? this.normals.push(b[0], b[1], b[2]) : (b = y.normal, this.normals.push(b, b, b)), 3 === (b = y.vertexColors).length ? this.colors.push(b[0], b[1], b[2]) : (b = y.color, this.colors.push(b, b, b)), !0 === o && (void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === a && (void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), b = 0; b < l; b++) {
                    var x = s[b].vertices;
                    c[b].data.push(x[y.a], x[y.b], x[y.c])
                }
                for (b = 0; b < d; b++) x = u[b].vertexNormals[h], p[b].data.push(x.a, x.b, x.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    });
    var To = 1;
    k.prototype = Object.assign(Object.create(t.prototype), {
        constructor: k,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new(65535 < F(e) ? I : R)(e, 1) : this.index = e
        },
        addAttribute: function(e, t, i) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new A(t, i)))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e], this
        },
        addGroup: function(e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var i = this.attributes.normal;
            return void 0 !== i && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new T;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            var e = new r;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                e = new z(3 * t.vertices.length, 3);
                var i = new z(3 * t.colors.length, 3);
                this.addAttribute("position", e.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new z(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new z(t, 3)), this
        },
        updateFromObject: function(e) {
            var t = e.geometry;
            if (e.isMesh) {
                var i = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (i = void 0, t.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(t);
                i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
            }
            return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new B).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            for (var i in this.addAttribute("position", new A(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", new A(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", new A(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", new A(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", new A(t, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) {
                t = [];
                for (var n = e.morphTargets[i], r = 0, o = n.length; r < o; r++) {
                    var a = n[r],
                        s = new z(3 * a.data.length, 3);
                    s.name = a.name, t.push(s.copyVector3sArray(a.data))
                }
                this.morphAttributes[i] = t
            }
            return 0 < e.skinIndices.length && (i = new z(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new z(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            var e = new d;
            return function() {
                null === this.boundingBox && (this.boundingBox = new d);
                var t = this.attributes.position,
                    i = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), i) {
                        t = 0;
                        for (var n = i.length; t < n; t++) e.setFromBufferAttribute(i[t]), this.boundingBox.expandByPoint(e.min), this.boundingBox.expandByPoint(e.max)
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function() {
            var e = new d,
                t = new d,
                i = new r;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new p);
                var n = this.attributes.position,
                    r = this.morphAttributes.position;
                if (n) {
                    var o = this.boundingSphere.center;
                    if (e.setFromBufferAttribute(n), r)
                        for (var a = 0, s = r.length; a < s; a++) {
                            var l = r[a];
                            t.setFromBufferAttribute(l), e.expandByPoint(t.min), e.expandByPoint(t.max)
                        }
                    e.getCenter(o);
                    var c = 0;
                    for (a = 0, s = n.count; a < s; a++) i.fromBufferAttribute(n, a), c = Math.max(c, o.distanceToSquared(i));
                    if (r)
                        for (a = 0, s = r.length; a < s; a++) {
                            n = 0;
                            for (var h = (l = r[a]).count; n < h; n++) i.fromBufferAttribute(l, n), c = Math.max(c, o.distanceToSquared(i))
                        }
                    this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index,
                t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3));
                else
                    for (var n = t.normal.array, o = 0, a = n.length; o < a; o++) n[o] = 0;
                n = t.normal.array;
                var s = new r,
                    l = new r,
                    c = new r,
                    h = new r,
                    u = new r;
                if (e) {
                    var d = e.array;
                    for (o = 0, a = e.count; o < a; o += 3) {
                        e = 3 * d[o + 0];
                        var p = 3 * d[o + 1],
                            f = 3 * d[o + 2];
                        s.fromArray(i, e), l.fromArray(i, p), c.fromArray(i, f), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[e] += h.x, n[e + 1] += h.y, n[e + 2] += h.z, n[p] += h.x, n[p + 1] += h.y, n[p + 2] += h.z, n[f] += h.x, n[f + 1] += h.y, n[f + 2] += h.z
                    }
                } else
                    for (o = 0, a = i.length; o < a; o += 9) s.fromArray(i, o), l.fromArray(i, o + 3), c.fromArray(i, o + 6), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[o] = h.x, n[o + 1] = h.y, n[o + 2] = h.z, n[o + 3] = h.x, n[o + 4] = h.y, n[o + 5] = h.z, n[o + 6] = h.x, n[o + 7] = h.y, n[o + 8] = h.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== e.attributes[i]) {
                        var r = n[i].array,
                            o = e.attributes[i],
                            a = o.array,
                            s = o.itemSize * t;
                        o = Math.min(a.length, r.length - s);
                        for (var l = 0; l < o; l++, s++) r[s] = a[l]
                    } return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            var e = new r;
            return function() {
                for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.normalize(), t.setXYZ(i, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function() {
            function e(e, t) {
                var i = e.array;
                e = e.itemSize;
                for (var n, r = new i.constructor(t.length * e), o = 0, a = 0, s = t.length; a < s; a++) {
                    n = t[a] * e;
                    for (var l = 0; l < e; l++) r[o++] = i[n++]
                }
                return new A(r, e)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t, i = new k,
                n = this.index.array,
                r = this.attributes;
            for (t in r) {
                var o = r[t];
                o = e(o, n), i.addAttribute(t, o)
            }
            var a = this.morphAttributes;
            for (t in a) {
                var s = [],
                    l = a[t];
                r = 0;
                for (var c = l.length; r < c; r++) o = e(o = l[r], n), s.push(o);
                i.morphAttributes[t] = s
            }
            for (r = 0, t = (n = this.groups).length; r < t; r++) o = n[r], i.addGroup(o.start, o.count, o.materialIndex);
            return i
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (c in t) void 0 !== t[c] && (e[c] = t[c]);
                return e
            }
            e.data = {
                attributes: {}
            }, null !== (t = this.index) && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            var i = this.attributes;
            for (c in i) {
                var n = (t = i[c]).toJSON();
                "" !== t.name && (n.name = t.name), e.data.attributes[c] = n
            }
            i = {};
            var r = !1;
            for (c in this.morphAttributes) {
                for (var o = this.morphAttributes[c], a = [], s = 0, l = o.length; s < l; s++) n = (t = o[s]).toJSON(), "" !== t.name && (n.name = t.name), a.push(n);
                0 < a.length && (i[c] = a, r = !0)
            }
            r && (e.data.morphAttributes = i);
            var c = this.groups;
            return 0 < c.length && (e.data.groups = JSON.parse(JSON.stringify(c))), null !== (c = this.boundingSphere) && (e.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }), e
        },
        clone: function() {
            return (new k).copy(this)
        },
        copy: function(e) {
            var t;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var i = e.index;
            for (a in null !== i && this.setIndex(i.clone()), i = e.attributes) this.addAttribute(a, i[a].clone());
            var n = e.morphAttributes;
            for (a in n) {
                var r = [],
                    o = n[a];
                for (i = 0, t = o.length; i < t; i++) r.push(o[i].clone());
                this.morphAttributes[a] = r
            }
            var a = e.groups;
            for (i = 0, t = a.length; i < t; i++) n = a[i], this.addGroup(n.start, n.count, n.materialIndex);
            return null !== (a = e.boundingBox) && (this.boundingBox = a.clone()), null !== (a = e.boundingSphere) && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), U.prototype = Object.create(S.prototype), U.prototype.constructor = U, H.prototype = Object.create(k.prototype), H.prototype.constructor = H, G.prototype = Object.create(S.prototype), G.prototype.constructor = G, j.prototype = Object.create(k.prototype), j.prototype.constructor = j;
    var So = 0;
    V.prototype = Object.assign(Object.create(t.prototype), {
        constructor: V,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else if ("shading" === t) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                    else {
                        var n = this[t];
                        void 0 === n ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
                    }
                }
        },
        toJSON: function(e) {
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var i = void 0 === e || "string" == typeof e;
            i && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = t(e.textures), e = t(e.images), 0 < i.length && (n.textures = i), 0 < e.length && (n.images = e)), n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes,
                i = null;
            if (null !== t) {
                var n = t.length;
                i = Array(n);
                for (var r = 0; r !== n; ++r) i[r] = t[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = v(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, W.prototype.toJSON = function(e) {
        var t = V.prototype.toJSON.call(this, e);
        for (var i in t.uniforms = {}, this.uniforms) {
            var n = this.uniforms[i].value;
            t.uniforms[i] = n && n.isTexture ? {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? {
                type: "m4",
                value: n.toArray()
            } : {
                value: n
            }
        }
        for (var r in 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, this.extensions) !0 === this.extensions[r] && (e[r] = !0);
        return 0 < Object.keys(e).length && (t.extensions = e), t
    }, Object.assign(q.prototype, {
        set: function(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new r), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function() {
            var e = new r;
            return function(t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new r), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new r;
            return function(t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, r, o, a) {
                e.copy(n).add(r).multiplyScalar(.5), t.copy(r).sub(n).normalize(), i.copy(this.origin).sub(e);
                var s = .5 * n.distanceTo(r),
                    l = -this.direction.dot(t),
                    c = i.dot(this.direction),
                    h = -i.dot(t),
                    u = i.lengthSq(),
                    d = Math.abs(1 - l * l);
                if (0 < d) {
                    r = l * c - h;
                    var p = s * d;
                    0 <= (n = l * h - c) ? r >= -p ? r <= p ? l = (n *= s = 1 / d) * (n + l * (r *= s) + 2 * c) + r * (l * n + r + 2 * h) + u : (r = s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : (r = -s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : r <= -p ? l = -(n = Math.max(0, -(-l * s + c))) * n + (r = 0 < n ? -s : Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u : r <= p ? (n = 0, l = (r = Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u) : l = -(n = Math.max(0, -(l * s + c))) * n + (r = 0 < n ? s : Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u
                } else r = 0 < l ? -s : s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u;
                return o && o.copy(this.direction).multiplyScalar(n).add(this.origin), a && a.copy(t).multiplyScalar(r).add(e), l
            }
        }(),
        intersectSphere: function() {
            var e = new r;
            return function(t, i) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction),
                    r = e.dot(e) - n * n;
                return r > (t = t.radius * t.radius) ? null : (r = n - (t = Math.sqrt(t - r)), n += t, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
        },
        intersectPlane: function(e, t) {
            return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || 0 > e.normal.dot(this.direction) * t
        },
        intersectBox: function(e, t) {
            var i = 1 / this.direction.x,
                n = 1 / this.direction.y,
                r = 1 / this.direction.z,
                o = this.origin;
            if (0 <= i) {
                var a = (e.min.x - o.x) * i;
                i *= e.max.x - o.x
            } else a = (e.max.x - o.x) * i, i *= e.min.x - o.x;
            if (0 <= n) {
                var s = (e.min.y - o.y) * n;
                n *= e.max.y - o.y
            } else s = (e.max.y - o.y) * n, n *= e.min.y - o.y;
            return a > n || s > i ? null : ((s > a || a != a) && (a = s), (n < i || i != i) && (i = n), 0 <= r ? (s = (e.min.z - o.z) * r, e = (e.max.z - o.z) * r) : (s = (e.max.z - o.z) * r, e = (e.min.z - o.z) * r), a > e || s > i ? null : ((s > a || a != a) && (a = s), (e < i || i != i) && (i = e), 0 > i ? null : this.at(0 <= a ? a : i, t)))
        },
        intersectsBox: function() {
            var e = new r;
            return function(t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function() {
            var e = new r,
                t = new r,
                i = new r,
                n = new r;
            return function(r, o, a, s, l) {
                if (t.subVectors(o, r), i.subVectors(a, r), n.crossVectors(t, i), 0 < (o = this.direction.dot(n))) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > o)) return null;
                    s = -1, o = -o
                }
                return e.subVectors(this.origin, r), 0 > (r = s * this.direction.dot(i.crossVectors(e, i))) || 0 > (a = s * this.direction.dot(t.cross(e))) || r + a > o || 0 > (r = -s * e.dot(n)) ? null : this.at(r / o, l)
            }
        }(),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), Object.assign(X, {
        getNormal: function() {
            var e = new r;
            return function(t, i, n, o) {
                return void 0 === o && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new r), o.subVectors(n, i), e.subVectors(t, i), o.cross(e), 0 < (t = o.lengthSq()) ? o.multiplyScalar(1 / Math.sqrt(t)) : o.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, o, a, s, l) {
                e.subVectors(s, o), t.subVectors(a, o), i.subVectors(n, o), n = e.dot(e), o = e.dot(t), a = e.dot(i);
                var c = t.dot(t);
                s = t.dot(i);
                var h = n * c - o * o;
                return void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new r), 0 === h ? l.set(-2, -1, -1) : (c = (c * a - o * s) * (h = 1 / h), n = (n * s - o * a) * h, l.set(1 - c - n, n, c))
            }
        }(),
        containsPoint: function() {
            var e = new r;
            return function(t, i, n, r) {
                return X.getBarycoord(t, i, n, r, e), 0 <= e.x && 0 <= e.y && 1 >= e.x + e.y
            }
        }(),
        getUV: function() {
            var e = new r;
            return function(t, i, n, r, o, a, s, l) {
                return this.getBarycoord(t, i, n, r, e), l.set(0, 0), l.addScaledVector(o, e.x), l.addScaledVector(a, e.y), l.addScaledVector(s, e.z), l
            }
        }(),
        isFrontFacing: function() {
            var e = new r,
                t = new r;
            return function(i, n, r, o) {
                return e.subVectors(r, n), t.subVectors(i, n), 0 > e.cross(t).dot(o)
            }
        }()
    }), Object.assign(X.prototype, {
        set: function(e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function(e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: function() {
            var e = new r,
                t = new r;
            return function() {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new r), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return X.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new r), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return X.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function(e, t, i, n, r) {
            return X.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        containsPoint: function(e) {
            return X.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function(e) {
            return X.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var e = new r,
                t = new r,
                i = new r,
                n = new r,
                o = new r,
                a = new r;
            return function(s, l) {
                void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new r);
                var c = this.a,
                    h = this.b,
                    u = this.c;
                e.subVectors(h, c), t.subVectors(u, c), n.subVectors(s, c);
                var d = e.dot(n),
                    p = t.dot(n);
                if (0 >= d && 0 >= p) return l.copy(c);
                o.subVectors(s, h);
                var f = e.dot(o),
                    m = t.dot(o);
                if (0 <= f && m <= f) return l.copy(h);
                var g = d * m - f * p;
                if (0 >= g && 0 <= d && 0 >= f) return h = d / (d - f), l.copy(c).addScaledVector(e, h);
                a.subVectors(s, u), s = e.dot(a);
                var v = t.dot(a);
                return 0 <= v && s <= v ? l.copy(u) : 0 >= (d = s * p - d * v) && 0 <= p && 0 >= v ? (g = p / (p - v), l.copy(c).addScaledVector(t, g)) : 0 >= (p = f * v - s * m) && 0 <= m - f && 0 <= s - v ? (i.subVectors(u, h), g = (m - f) / (m - f + (s - v)), l.copy(h).addScaledVector(i, g)) : (h = d * (u = 1 / (p + d + g)), g *= u, l.copy(c).addScaledVector(e, h).addScaledVector(t, g))
            }
        }(),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Z.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Z,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return T.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
        },
        updateMorphTargets: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                e = e.morphAttributes;
                var t = Object.keys(e);
                if (0 < t.length) {
                    var i = e[t[0]];
                    if (void 0 !== i)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = i.length; e < t; e++) {
                            var n = i[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                }
            } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        raycast: function() {
            function e(e, t, i, n, r, o, a, s) {
                return null === (1 === t.side ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, 2 !== t.side, s)) ? null : (E.copy(s), E.applyMatrix4(e.matrixWorld), (t = i.ray.origin.distanceTo(E)) < i.near || t > i.far ? null : {
                    distance: t,
                    point: E.clone(),
                    object: e
                })
            }

            function t(t, n, r, o, a, p, g, E, M, T) {
                if (s.fromBufferAttribute(a, E), l.fromBufferAttribute(a, M), c.fromBufferAttribute(a, T), a = t.morphTargetInfluences, n.morphTargets && p && a) {
                    f.set(0, 0, 0), m.set(0, 0, 0), v.set(0, 0, 0);
                    for (var S = 0, A = p.length; S < A; S++) {
                        var C = a[S],
                            L = p[S];
                        0 !== C && (h.fromBufferAttribute(L, E), u.fromBufferAttribute(L, M), d.fromBufferAttribute(L, T), f.addScaledVector(h.sub(s), C), m.addScaledVector(u.sub(l), C), v.addScaledVector(d.sub(c), C))
                    }
                    s.add(f), l.add(m), c.add(v)
                }
                return (t = e(t, n, r, o, s, l, c, w)) && (g && (y.fromBufferAttribute(g, E), b.fromBufferAttribute(g, M), x.fromBufferAttribute(g, T), t.uv = X.getUV(w, s, l, c, y, b, x, new i)), g = new _(E, M, T), X.getNormal(s, l, c, g.normal), t.face = g), t
            }
            var n = new g,
                o = new q,
                a = new p,
                s = new r,
                l = new r,
                c = new r,
                h = new r,
                u = new r,
                d = new r,
                f = new r,
                m = new r,
                v = new r,
                y = new i,
                b = new i,
                x = new i,
                w = new r,
                E = new r;
            return function(r, s) {
                var l = this.geometry,
                    c = this.material,
                    h = this.matrixWorld;
                if (void 0 !== c && (null === l.boundingSphere && l.computeBoundingSphere(), a.copy(l.boundingSphere), a.applyMatrix4(h), !1 !== r.ray.intersectsSphere(a) && (n.getInverse(h), o.copy(r.ray).applyMatrix4(n), null === l.boundingBox || !1 !== o.intersectsBox(l.boundingBox))))
                    if (l.isBufferGeometry) {
                        var u = l.index;
                        h = l.attributes.position;
                        var d, p, f = l.morphAttributes.position,
                            m = l.attributes.uv,
                            g = l.groups,
                            v = l.drawRange;
                        if (null !== u)
                            if (Array.isArray(c)) {
                                var _ = 0;
                                for (d = g.length; _ < d; _++) {
                                    var E = g[_],
                                        M = c[E.materialIndex],
                                        T = Math.max(E.start, v.start);
                                    for (p = l = Math.min(E.start + E.count, v.start + v.count); T < p; T += 3) {
                                        l = u.getX(T);
                                        var S = u.getX(T + 1),
                                            A = u.getX(T + 2);
                                        (l = t(this, M, r, o, h, f, m, l, S, A)) && (l.faceIndex = Math.floor(T / 3), l.face.materialIndex = E.materialIndex, s.push(l))
                                    }
                                }
                            } else
                                for (_ = T = Math.max(0, v.start), d = l = Math.min(u.count, v.start + v.count); _ < d; _ += 3) l = u.getX(_), S = u.getX(_ + 1), A = u.getX(_ + 2), (l = t(this, c, r, o, h, f, m, l, S, A)) && (l.faceIndex = Math.floor(_ / 3), s.push(l));
                        else if (void 0 !== h)
                            if (Array.isArray(c))
                                for (_ = 0, d = g.length; _ < d; _++)
                                    for (M = c[(E = g[_]).materialIndex], T = Math.max(E.start, v.start), p = l = Math.min(E.start + E.count, v.start + v.count); T < p; T += 3)(l = t(this, M, r, o, h, f, m, l = T, S = T + 1, A = T + 2)) && (l.faceIndex = Math.floor(T / 3), l.face.materialIndex = E.materialIndex, s.push(l));
                            else
                                for (_ = T = Math.max(0, v.start), d = l = Math.min(h.count, v.start + v.count); _ < d; _ += 3)(l = t(this, c, r, o, h, f, m, l = _, S = _ + 1, A = _ + 2)) && (l.faceIndex = Math.floor(_ / 3), s.push(l))
                    } else if (l.isGeometry)
                    for (h = Array.isArray(c), f = l.vertices, m = l.faces, 0 < (l = l.faceVertexUvs[0]).length && (u = l), d = 0, E = m.length; d < E; d++) M = m[d], void 0 !== (l = h ? c[M.materialIndex] : c) && (g = f[M.a], v = f[M.b], _ = f[M.c], l = e(this, l, r, o, g, v, _, w)) && (u && u[d] && (T = u[d], y.copy(T[0]), b.copy(T[1]), x.copy(T[2]), l.uv = X.getUV(w, g, v, _, y, b, x, new i)), l.face = M, l.faceIndex = d, s.push(l))
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), se.prototype = Object.create(a.prototype), se.prototype.constructor = se, se.prototype.isCubeTexture = !0, Object.defineProperty(se.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }), le.prototype = Object.create(a.prototype), le.prototype.constructor = le, le.prototype.isDataTexture2DArray = !0, ce.prototype = Object.create(a.prototype), ce.prototype.constructor = ce, ce.prototype.isDataTexture3D = !0;
    var Ao = new a,
        Co = new le,
        Lo = new ce,
        Do = new se,
        Po = [],
        Ro = [],
        Oo = new Float32Array(16),
        Io = new Float32Array(9),
        zo = new Float32Array(4);
    je.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), de(t, e)
    }, Ve.prototype.setValue = function(e, t, i) {
        for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
            var a = n[r];
            a.setValue(e, t[a.id], i)
        }
    };
    var No = /([\w\d_]+)(\])?(\[|\.)?/g;
    We.prototype.setValue = function(e, t, i, n) {
        void 0 !== (t = this.map[t]) && t.setValue(e, i, n)
    }, We.prototype.setOptional = function(e, t, i) {
        void 0 !== (t = t[i]) && this.setValue(e, i, t)
    }, We.upload = function(e, t, i, n) {
        for (var r = 0, o = t.length; r !== o; ++r) {
            var a = t[r],
                s = i[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, n)
        }
    }, We.seqWithValue = function(e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var o = e[n];
            o.id in t && i.push(o)
        }
        return i
    };
    var Bo = 0,
        Fo = 0;
    pt.prototype = Object.create(V.prototype), pt.prototype.constructor = pt, pt.prototype.isMeshDepthMaterial = !0, pt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ft.prototype = Object.create(V.prototype), ft.prototype.constructor = ft, ft.prototype.isMeshDistanceMaterial = !0, ft.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }, bt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: bt,
        isGroup: !0
    }), xt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: xt,
        isCamera: !0,
        copy: function(e, t) {
            return T.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            T.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), wt.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: wt,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return xt.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function(e) {
            e = .5 * this.getFilmHeight() / e, this.fov = 2 * fo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * fo.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * fo.RAD2DEG * Math.atan(Math.tan(.5 * fo.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, i, n, r, o) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near,
                t = e * Math.tan(.5 * fo.DEG2RAD * this.fov) / this.zoom,
                i = 2 * t,
                n = this.aspect * i,
                r = -.5 * n,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                r += o.offsetX * n / a, t -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
            }
            0 !== (o = this.filmOffset) && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), _t.prototype = Object.assign(Object.create(wt.prototype), {
        constructor: _t,
        isArrayCamera: !0
    });
    var ko, Uo = new r,
        Ho = new r;
    Object.assign(At.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new At(this.color, this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(Ct.prototype, {
        isFog: !0,
        clone: function() {
            return new Ct(this.color, this.near, this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Lt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Lt,
        isScene: !0,
        copy: function(e, t) {
            return T.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function(e) {
            var t = T.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(Dt.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(Dt.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
        },
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, i) {
            e *= this.stride, i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        }
    }), Object.defineProperties(Pt.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(Pt.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
        },
        setXYZ: function(e, t, i, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
        },
        setXYZW: function(e, t, i, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
        }
    }), Rt.prototype = Object.create(V.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isSpriteMaterial = !0, Rt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    }, Ot.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Ot,
        isSprite: !0,
        raycast: function() {
            function e(e, t, i, n, r, o) {
                a.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = o * a.x - r * a.y, s.y = r * a.x + o * a.y) : s.copy(a), e.copy(t), e.x += s.x, e.y += s.y, e.applyMatrix4(l)
            }
            var t = new r,
                n = new r,
                o = new r,
                a = new i,
                s = new i,
                l = new g,
                c = new r,
                h = new r,
                u = new r,
                d = new i,
                p = new i,
                f = new i;
            return function(r, a) {
                n.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                var s = this.material.rotation;
                if (0 !== s) var m = Math.cos(s),
                    g = Math.sin(s);
                s = this.center, e(c.set(-.5, -.5, 0), o, s, n, g, m), e(h.set(.5, -.5, 0), o, s, n, g, m), e(u.set(.5, .5, 0), o, s, n, g, m), d.set(0, 0), p.set(1, 0), f.set(1, 1);
                var v = r.ray.intersectTriangle(c, h, u, !1, t);
                null === v && (e(h.set(-.5, .5, 0), o, s, n, g, m), p.set(0, 1), null === (v = r.ray.intersectTriangle(c, u, h, !1, t))) || (g = r.ray.origin.distanceTo(t)) < r.near || g > r.far || a.push({
                    distance: g,
                    point: t.clone(),
                    uv: X.getUV(t, c, h, u, d, p, f, new i),
                    face: null,
                    object: this
                })
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return T.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    }), It.prototype = Object.assign(Object.create(T.prototype), {
        constructor: It,
        isLOD: !0,
        copy: function(e) {
            T.prototype.copy.call(this, e, !1);
            for (var t = 0, i = (e = e.levels).length; t < i; t++) {
                var n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
            return i.splice(n, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++);
            return t[i - 1].object
        },
        raycast: function() {
            var e = new r;
            return function(t, i) {
                e.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(n).raycast(t, i)
            }
        }(),
        update: function() {
            var e = new r,
                t = new r;
            return function(i) {
                var n = this.levels;
                if (1 < n.length) {
                    e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), n[0].object.visible = !0;
                    for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                    for (; r < o; r++) n[r].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            (e = T.prototype.toJSON.call(this, e)).object.levels = [];
            for (var t = this.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return e
        }
    }), zt.prototype = Object.assign(Object.create(Z.prototype), {
        constructor: zt,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new s, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
                e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
                var r = 1 / e.manhattanLength();
                1 / 0 !== r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Object.assign(Nt.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new g;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function() {
            var e, t, i = 0;
            for (t = this.bones.length; i < t; i++)(e = this.bones[i]) && e.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, t = this.bones.length; i < t; i++)(e = this.bones[i]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            var e = new g,
                t = new g;
            return function() {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) e.multiplyMatrices(i[a] ? i[a].matrixWorld : t, n[a]), e.toArray(r, 16 * a);
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new Nt(this.bones, this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e) return n
            }
        }
    }), Bt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Bt,
        isBone: !0
    }), Ft.prototype = Object.create(V.prototype), Ft.prototype.constructor = Ft, Ft.prototype.isLineBasicMaterial = !0, Ft.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, kt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: kt,
        isLine: !0,
        computeLineDistances: function() {
            var e = new r,
                t = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [0], o = 1, a = n.count; o < a; o++) e.fromBufferAttribute(n, o - 1), t.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += e.distanceTo(t);
                        i.addAttribute("lineDistance", new z(r, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, (r = i.lineDistances)[0] = 0, o = 1, a = n.length; o < a; o++) r[o] = r[o - 1], r[o] += n[o - 1].distanceTo(n[o]);
                return this
            }
        }(),
        raycast: function() {
            var e = new g,
                t = new q,
                i = new p;
            return function(n, o) {
                var a = n.linePrecision,
                    s = this.geometry,
                    l = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(l), i.radius += a, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(l), t.copy(n.ray).applyMatrix4(e), a /= (this.scale.x + this.scale.y + this.scale.z) / 3, a *= a;
                    var c = new r,
                        h = new r;
                    l = new r;
                    var u = new r,
                        d = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var p = s.index,
                            f = s.attributes.position.array;
                        if (null !== p) {
                            s = 0;
                            for (var m = (p = p.array).length - 1; s < m; s += d) {
                                var g = p[s + 1];
                                c.fromArray(f, 3 * p[s]), h.fromArray(f, 3 * g), (g = t.distanceSqToSegment(c, h, u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                                    distance: g,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (s = 0, m = f.length / 3 - 1; s < m; s += d) c.fromArray(f, 3 * s), h.fromArray(f, 3 * s + 3), (g = t.distanceSqToSegment(c, h, u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                                distance: g,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (s.isGeometry)
                        for (h = (c = s.vertices).length, s = 0; s < h - 1; s += d)(g = t.distanceSqToSegment(c[s], c[s + 1], u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                            distance: g,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: s,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ut.prototype = Object.assign(Object.create(kt.prototype), {
        constructor: Ut,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = new r,
                t = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2) e.fromBufferAttribute(n, o), t.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                        i.addAttribute("lineDistance", new z(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, r = i.lineDistances, o = 0, a = n.length; o < a; o += 2) e.copy(n[o]), t.copy(n[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                return this
            }
        }()
    }), Ht.prototype = Object.assign(Object.create(kt.prototype), {
        constructor: Ht,
        isLineLoop: !0
    }), Gt.prototype = Object.create(V.prototype), Gt.prototype.constructor = Gt, Gt.prototype.isPointsMaterial = !0, Gt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    }, jt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: jt,
        isPoints: !0,
        raycast: function() {
            var e = new g,
                t = new q,
                i = new p;
            return function(n, o) {
                function a(e, i) {
                    var r = t.distanceSqToPoint(e);
                    r < u && (t.closestPointToPoint(e, d), d.applyMatrix4(c), (e = n.ray.origin.distanceTo(d)) < n.near || e > n.far || o.push({
                        distance: e,
                        distanceToRay: Math.sqrt(r),
                        point: d.clone(),
                        index: i,
                        face: null,
                        object: s
                    }))
                }
                var s = this,
                    l = this.geometry,
                    c = this.matrixWorld,
                    h = n.params.Points.threshold;
                if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
                    var u = (h /= (this.scale.x + this.scale.y + this.scale.z) / 3) * h;
                    h = new r;
                    var d = new r;
                    if (l.isBufferGeometry) {
                        var p = l.index;
                        if (l = l.attributes.position.array, null !== p) {
                            var f = p.array;
                            p = 0;
                            for (var m = f.length; p < m; p++) {
                                var g = f[p];
                                h.fromArray(l, 3 * g), a(h, g)
                            }
                        } else
                            for (p = 0, f = l.length / 3; p < f; p++) h.fromArray(l, 3 * p), a(h, p)
                    } else
                        for (p = 0, f = (h = l.vertices).length; p < f; p++) a(h[p], p)
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Vt.prototype = Object.assign(Object.create(a.prototype), {
        constructor: Vt,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), Wt.prototype = Object.create(a.prototype), Wt.prototype.constructor = Wt, Wt.prototype.isCompressedTexture = !0, qt.prototype = Object.create(a.prototype), qt.prototype.constructor = qt, qt.prototype.isCanvasTexture = !0, Xt.prototype = Object.create(a.prototype), Xt.prototype.constructor = Xt, Xt.prototype.isDepthTexture = !0, Yt.prototype = Object.create(k.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(S.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(k.prototype), Jt.prototype.constructor = Jt, Qt.prototype = Object.create(S.prototype), Qt.prototype.constructor = Qt, $t.prototype = Object.create(k.prototype), $t.prototype.constructor = $t, Kt.prototype = Object.create(S.prototype), Kt.prototype.constructor = Kt, ei.prototype = Object.create($t.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(S.prototype), ti.prototype.constructor = ti, ii.prototype = Object.create($t.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(S.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create($t.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(S.prototype), oi.prototype.constructor = oi, ai.prototype = Object.create($t.prototype), ai.prototype.constructor = ai, si.prototype = Object.create(S.prototype), si.prototype.constructor = si, li.prototype = Object.create(k.prototype), li.prototype.constructor = li, li.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(), e
    }, ci.prototype = Object.create(S.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(k.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(S.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(k.prototype), di.prototype.constructor = di;
    var Go = function(e, t, i) {
            i = i || 2;
            var n, r = t && t.length,
                o = r ? t[0] * i : e.length,
                a = pi(e, 0, o, i, !0),
                s = [];
            if (!a) return s;
            if (r) {
                var l, c = i;
                r = [];
                var h = 0;
                for (l = t.length; h < l; h++) {
                    var u = t[h] * c;
                    (u = pi(e, u, h < l - 1 ? t[h + 1] * c : e.length, c, !1)) === u.next && (u.steiner = !0), r.push(bi(u))
                }
                for (r.sort(gi), h = 0; h < r.length; h++)(c = vi(t = r[h], c = a)) && fi(t = Ti(c, t), t.next), a = fi(a, a.next)
            }
            if (e.length > 80 * i) {
                var d = n = e[0],
                    p = r = e[1];
                for (c = i; c < o; c += i)(h = e[c]) < d && (d = h), (t = e[c + 1]) < p && (p = t), h > n && (n = h), t > r && (r = t);
                n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0
            }
            return mi(a, s, i, d, p, n), s
        },
        jo = {
            area: function(e) {
                for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
                return .5 * i
            },
            isClockWise: function(e) {
                return 0 > jo.area(e)
            },
            triangulateShape: function(e, t) {
                var i = [],
                    n = [],
                    r = [];
                Li(e), Di(i, e);
                var o = e.length;
                for (t.forEach(Li), e = 0; e < t.length; e++) n.push(o), o += t[e].length, Di(i, t[e]);
                for (t = Go(i, n), e = 0; e < t.length; e += 3) r.push(t.slice(e, e + 3));
                return r
            }
        };
    Pi.prototype = Object.create(S.prototype), Pi.prototype.constructor = Pi, Pi.prototype.toJSON = function() {
        var e = S.prototype.toJSON.call(this);
        return Oi(this.parameters.shapes, this.parameters.options, e)
    }, Ri.prototype = Object.create(k.prototype), Ri.prototype.constructor = Ri, Ri.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return Oi(this.parameters.shapes, this.parameters.options, e)
    };
    var Vo = {
        generateTopUV: function(e, t, n, r, o) {
            e = t[3 * r], r = t[3 * r + 1];
            var a = t[3 * o];
            return o = t[3 * o + 1], [new i(t[3 * n], t[3 * n + 1]), new i(e, r), new i(a, o)]
        },
        generateSideWallUV: function(e, t, n, r, o, a) {
            e = t[3 * n];
            var s = t[3 * n + 1];
            n = t[3 * n + 2];
            var l = t[3 * r],
                c = t[3 * r + 1];
            r = t[3 * r + 2];
            var h = t[3 * o],
                u = t[3 * o + 1];
            o = t[3 * o + 2];
            var d = t[3 * a],
                p = t[3 * a + 1];
            return t = t[3 * a + 2], .01 > Math.abs(s - c) ? [new i(e, 1 - n), new i(l, 1 - r), new i(h, 1 - o), new i(d, 1 - t)] : [new i(s, 1 - n), new i(c, 1 - r), new i(u, 1 - o), new i(p, 1 - t)]
        }
    };
    Ii.prototype = Object.create(S.prototype), Ii.prototype.constructor = Ii, zi.prototype = Object.create(Ri.prototype), zi.prototype.constructor = zi, Ni.prototype = Object.create(S.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(k.prototype), Bi.prototype.constructor = Bi, Fi.prototype = Object.create(S.prototype), Fi.prototype.constructor = Fi, ki.prototype = Object.create(k.prototype), ki.prototype.constructor = ki, Ui.prototype = Object.create(S.prototype), Ui.prototype.constructor = Ui, Hi.prototype = Object.create(k.prototype), Hi.prototype.constructor = Hi, Gi.prototype = Object.create(S.prototype), Gi.prototype.constructor = Gi, Gi.prototype.toJSON = function() {
        var e = S.prototype.toJSON.call(this);
        return Vi(this.parameters.shapes, e)
    }, ji.prototype = Object.create(k.prototype), ji.prototype.constructor = ji, ji.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return Vi(this.parameters.shapes, e)
    }, Wi.prototype = Object.create(k.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(S.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(k.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(qi.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(Xi.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(S.prototype), Ji.prototype.constructor = Ji, Qi.prototype = Object.create(k.prototype), Qi.prototype.constructor = Qi;
    var Wo = Object.freeze({
        WireframeGeometry: Yt,
        ParametricGeometry: Zt,
        ParametricBufferGeometry: Jt,
        TetrahedronGeometry: Kt,
        TetrahedronBufferGeometry: ei,
        OctahedronGeometry: ti,
        OctahedronBufferGeometry: ii,
        IcosahedronGeometry: ni,
        IcosahedronBufferGeometry: ri,
        DodecahedronGeometry: oi,
        DodecahedronBufferGeometry: ai,
        PolyhedronGeometry: Qt,
        PolyhedronBufferGeometry: $t,
        TubeGeometry: si,
        TubeBufferGeometry: li,
        TorusKnotGeometry: ci,
        TorusKnotBufferGeometry: hi,
        TorusGeometry: ui,
        TorusBufferGeometry: di,
        TextGeometry: Ii,
        TextBufferGeometry: zi,
        SphereGeometry: Ni,
        SphereBufferGeometry: Bi,
        RingGeometry: Fi,
        RingBufferGeometry: ki,
        PlaneGeometry: G,
        PlaneBufferGeometry: j,
        LatheGeometry: Ui,
        LatheBufferGeometry: Hi,
        ShapeGeometry: Gi,
        ShapeBufferGeometry: ji,
        ExtrudeGeometry: Pi,
        ExtrudeBufferGeometry: Ri,
        EdgesGeometry: Wi,
        ConeGeometry: Yi,
        ConeBufferGeometry: Zi,
        CylinderGeometry: qi,
        CylinderBufferGeometry: Xi,
        CircleGeometry: Ji,
        CircleBufferGeometry: Qi,
        BoxGeometry: U,
        BoxBufferGeometry: H
    });
    $i.prototype = Object.create(V.prototype), $i.prototype.constructor = $i, $i.prototype.isShadowMaterial = !0, $i.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, Ki.prototype = Object.create(W.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isRawShaderMaterial = !0, en.prototype = Object.create(V.prototype), en.prototype.constructor = en, en.prototype.isMeshStandardMaterial = !0, en.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, tn.prototype = Object.create(en.prototype), tn.prototype.constructor = tn, tn.prototype.isMeshPhysicalMaterial = !0, tn.prototype.copy = function(e) {
        return en.prototype.copy.call(this, e), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, nn.prototype = Object.create(V.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshPhongMaterial = !0, nn.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, rn.prototype = Object.create(nn.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshToonMaterial = !0, rn.prototype.copy = function(e) {
        return nn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, on.prototype.isMeshNormalMaterial = !0, on.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, an.prototype = Object.create(V.prototype), an.prototype.constructor = an, an.prototype.isMeshLambertMaterial = !0, an.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, sn.prototype = Object.create(V.prototype), sn.prototype.constructor = sn, sn.prototype.isMeshMatcapMaterial = !0, sn.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ln.prototype = Object.create(Ft.prototype), ln.prototype.constructor = ln, ln.prototype.isLineDashedMaterial = !0, ln.prototype.copy = function(e) {
        return Ft.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var qo = Object.freeze({
            ShadowMaterial: $i,
            SpriteMaterial: Rt,
            RawShaderMaterial: Ki,
            ShaderMaterial: W,
            PointsMaterial: Gt,
            MeshPhysicalMaterial: tn,
            MeshStandardMaterial: en,
            MeshPhongMaterial: nn,
            MeshToonMaterial: rn,
            MeshNormalMaterial: on,
            MeshLambertMaterial: an,
            MeshDepthMaterial: pt,
            MeshDistanceMaterial: ft,
            MeshBasicMaterial: Y,
            MeshMatcapMaterial: sn,
            LineDashedMaterial: ln,
            LineBasicMaterial: Ft,
            Material: V
        }),
        Xo = {
            arraySlice: function(e, t, i) {
                return Xo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
            },
            convertArray: function(e, t, i) {
                return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function(e) {
                for (var t = e.length, i = Array(t), n = 0; n !== t; ++n) i[n] = n;
                return i.sort((function(t, i) {
                    return e[t] - e[i]
                })), i
            },
            sortedArray: function(e, t, i) {
                for (var n = e.length, r = new e.constructor(n), o = 0, a = 0; a !== n; ++o)
                    for (var s = i[o] * t, l = 0; l !== t; ++l) r[a++] = e[s + l];
                return r
            },
            flattenJSON: function(e, t, i, n) {
                for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[n];) o = e[r++];
                if (void 0 !== o) {
                    var a = o[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                void 0 !== (a = o[n]) && (t.push(o.time), i.push.apply(i, a)), o = e[r++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time), a.toArray(i, i.length)), o = e[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time), i.push(a)), o = e[r++]
                        } while (void 0 !== o)
                }
            }
        };
    Object.assign(cn.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions,
                i = this._cachedIndex,
                n = t[i],
                r = t[i - 1];
            e: {
                t: {
                    i: {
                        n: if (!(e < n)) {
                            for (var o = i + 2;;) {
                                if (void 0 === n) {
                                    if (e < r) break n;
                                    return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, e, r)
                                }
                                if (i === o) break;
                                if (r = n, e < (n = t[++i])) break t
                            }
                            n = t.length;
                            break i
                        }if (e >= r) break e;
                        for (e < (o = t[1]) && (i = 2, r = o), o = i - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (i === o) break;
                            if (n = r, e >= (r = t[--i - 1])) break t
                        }
                        n = i,
                        i = 0
                    }
                    for (; i < n;) e < t[r = i + n >>> 1] ? n = r : i = r + 1;
                    if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, e, n);
                    if (void 0 === n) return this._cachedIndex = i = t.length,
                    this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            var t = this.resultBuffer,
                i = this.sampleValues,
                n = this.valueSize;
            e *= n;
            for (var r = 0; r !== n; ++r) t[r] = i[e + r];
            return t
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }), Object.assign(cn.prototype, {
        beforeStart_: cn.prototype.copySampleValue_,
        afterEnd_: cn.prototype.copySampleValue_
    }), hn.prototype = Object.assign(Object.create(cn.prototype), {
        constructor: hn,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(e, t, i) {
            var n = this.parameterPositions,
                r = e - 2,
                o = e + 1,
                a = n[r],
                s = n[o];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e, a = 2 * t - i;
                    break;
                case 2402:
                    a = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e, a = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = e, s = 2 * i - t;
                    break;
                case 2402:
                    o = 1, s = i + n[1] - n[0];
                    break;
                default:
                    o = e - 1, s = t
            }
            e = .5 * (i - t), n = this.valueSize, this._weightPrev = e / (t - a), this._weightNext = e / (s - i), this._offsetPrev = r * n, this._offsetNext = o * n
        },
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                s = (e *= a) - a,
                l = this._offsetPrev,
                c = this._offsetNext,
                h = this._weightPrev,
                u = this._weightNext,
                d = (i - t) / (n - t);
            for (t = -h * (n = (i = d * d) * d) + 2 * h * i - h * d, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== a; ++i) r[i] = t * o[l + i] + h * o[s + i] + d * o[e + i] + u * o[c + i];
            return r
        }
    }), un.prototype = Object.assign(Object.create(cn.prototype), {
        constructor: un,
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                s = (e *= a) - a;
            for (i = 1 - (t = (i - t) / (n - t)), n = 0; n !== a; ++n) r[n] = o[s + n] * i + o[e + n] * t;
            return r
        }
    }), dn.prototype = Object.assign(Object.create(cn.prototype), {
        constructor: dn,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }), Object.assign(pn, {
        toJSON: function(e) {
            var t = e.constructor;
            if (void 0 !== t.toJSON) t = t.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: Xo.convertArray(e.times, Array),
                    values: Xo.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName, t
        }
    }), Object.assign(pn.prototype, {
        constructor: pn,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new dn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new un(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new hn(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function(e) {
            switch (e) {
                case 2300:
                    var t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", t), this
            }
            return this.createInterpolant = t, this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
            return this
        },
        trim: function(e, t) {
            for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < e;) ++r;
            for (; - 1 !== o && i[o] > t;) --o;
            return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), e = this.getValueSize(), this.times = Xo.arraySlice(i, r, o), this.values = Xo.arraySlice(this.values, r * e, o * e)), this
        },
        validate: function() {
            var e = !0,
                t = this.getValueSize();
            0 !== t - Math.floor(t) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var i = this.times;
            t = this.values;
            var n = i.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            for (var r = null, o = 0; o !== n; o++) {
                var a = i[o];
                if ("number" == typeof a && isNaN(a)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a), e = !1;
                    break
                }
                if (null !== r && r > a) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, r), e = !1;
                    break
                }
                r = a
            }
            if (void 0 !== t && Xo.isTypedArray(t))
                for (o = 0, i = t.length; o !== i; ++o)
                    if (n = t[o], isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), e = !1;
                        break
                    } return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = e.length - 1, a = 1; a < o; ++a) {
                var s = !1,
                    l = e[a];
                if (l !== e[a + 1] && (1 !== a || l !== l[0]))
                    if (n) s = !0;
                    else {
                        var c = a * i,
                            h = c - i,
                            u = c + i;
                        for (l = 0; l !== i; ++l) {
                            var d = t[c + l];
                            if (d !== t[h + l] || d !== t[u + l]) {
                                s = !0;
                                break
                            }
                        }
                    } if (s) {
                    if (a !== r)
                        for (e[r] = e[a], s = a * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[s + l];
                    ++r
                }
            }
            if (0 < o) {
                for (e[r] = e[o], s = o * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[s + l];
                ++r
            }
            return r !== e.length && (this.times = Xo.arraySlice(e, 0, r), this.values = Xo.arraySlice(t, 0, r * i)), this
        },
        clone: function() {
            var e = Xo.arraySlice(this.times, 0),
                t = Xo.arraySlice(this.values, 0);
            return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, e
        }
    }), fn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: fn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), mn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: mn,
        ValueTypeName: "color"
    }), gn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: gn,
        ValueTypeName: "number"
    }), vn.prototype = Object.assign(Object.create(cn.prototype), {
        constructor: vn,
        interpolate_: function(e, t, i, r) {
            var o = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize;
            for (t = (i - t) / (r - t), i = (e *= s) + s; e !== i; e += 4) n.slerpFlat(o, 0, a, e - s, a, e, t);
            return o
        }
    }), yn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: yn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new vn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), bn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: bn,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), xn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: xn,
        ValueTypeName: "vector"
    }), Object.assign(wn, {
        parse: function(e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, o = i.length; r !== o; ++r) t.push(_n(i[r]).scale(n));
            return new wn(e.name, e.duration, t)
        },
        toJSON: function(e) {
            var t = [],
                i = e.tracks;
            e = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            };
            for (var n = 0, r = i.length; n !== r; ++n) t.push(pn.toJSON(i[n]));
            return e
        },
        CreateFromMorphTargetSequence: function(e, t, i, n) {
            for (var r = t.length, o = [], a = 0; a < r; a++) {
                var s = [],
                    l = [];
                s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                var c = Xo.getKeyframeOrder(s);
                s = Xo.sortedArray(s, 1, c), l = Xo.sortedArray(l, 1, c), n || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new gn(".morphTargetInfluences[" + t[a].name + "]", s, l).scale(1 / i))
            }
            return new wn(e, -1, o)
        },
        findByName: function(e, t) {
            var i = e;
            for (Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations), e = 0; e < i.length; e++)
                if (i[e].name === t) return i[e];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                var s = e[o],
                    l = s.name.match(r);
                if (l && 1 < l.length) {
                    var c = l[1];
                    (l = n[c]) || (n[c] = l = []), l.push(s)
                }
            }
            for (c in e = [], n) e.push(wn.CreateFromMorphTargetSequence(c, n[c], t, i));
            return e
        },
        parseAnimation: function(e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            var i = function(e, t, i, n, r) {
                    if (0 !== i.length) {
                        var o = [],
                            a = [];
                        Xo.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new e(t, o, a))
                    }
                },
                n = [],
                r = e.name || "default",
                o = e.length || -1,
                a = e.fps || 30;
            e = e.hierarchy || [];
            for (var s = 0; s < e.length; s++) {
                var l = e[s].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        o = {};
                        for (var c = 0; c < l.length; c++)
                            if (l[c].morphTargets)
                                for (var h = 0; h < l[c].morphTargets.length; h++) o[l[c].morphTargets[h]] = -1;
                        for (var u in o) {
                            var d = [],
                                p = [];
                            for (h = 0; h !== l[c].morphTargets.length; ++h) {
                                var f = l[c];
                                d.push(f.time), p.push(f.morphTarget === u ? 1 : 0)
                            }
                            n.push(new gn(".morphTargetInfluence[" + u + "]", d, p))
                        }
                        o = o.length * (a || 1)
                    } else i(xn, (c = ".bones[" + t[s].name + "]") + ".position", l, "pos", n), i(yn, c + ".quaternion", l, "rot", n), i(xn, c + ".scale", l, "scl", n)
            }
            return 0 === n.length ? null : new wn(r, o, n)
        }
    }), Object.assign(wn.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new wn(this.name, this.duration, e)
        }
    });
    var Yo = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        },
        Zo = new En,
        Jo = {};
    Object.assign(Mn.prototype, {
        load: function(e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = Yo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            if (void 0 === Jo[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    i = a[1];
                    var s = !!a[2];
                    a = a[3], a = decodeURIComponent(a), s && (a = atob(a));
                    try {
                        var l = (this.responseType || "").toLowerCase();
                        switch (l) {
                            case "arraybuffer":
                            case "blob":
                                var c = new Uint8Array(a.length);
                                for (s = 0; s < a.length; s++) c[s] = a.charCodeAt(s);
                                var h = "blob" === l ? new Blob([c.buffer], {
                                    type: i
                                }) : c.buffer;
                                break;
                            case "document":
                                h = (new DOMParser).parseFromString(a, i);
                                break;
                            case "json":
                                h = JSON.parse(a);
                                break;
                            default:
                                h = a
                        }
                        setTimeout((function() {
                            t && t(h), r.manager.itemEnd(e)
                        }), 0)
                    } catch (t) {
                        setTimeout((function() {
                            n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                        }), 0)
                    }
                } else {
                    Jo[e] = [], Jo[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    var u = new XMLHttpRequest;
                    for (s in u.open("GET", e, !0), u.addEventListener("load", (function(t) {
                            var i = this.response;
                            Yo.add(e, i);
                            var n = Jo[e];
                            if (delete Jo[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, a = n.length; o < a; o++) {
                                    var s = n[o];
                                    s.onLoad && s.onLoad(i)
                                }
                            } else {
                                for (o = 0, a = n.length; o < a; o++)(s = n[o]).onError && s.onError(t);
                                r.manager.itemError(e)
                            }
                            r.manager.itemEnd(e)
                        }), !1), u.addEventListener("progress", (function(t) {
                            for (var i = Jo[e], n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o.onProgress && o.onProgress(t)
                            }
                        }), !1), u.addEventListener("error", (function(t) {
                            var i = Jo[e];
                            delete Jo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), u.addEventListener("abort", (function(t) {
                            var i = Jo[e];
                            delete Jo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(s, this.requestHeader[s]);
                    u.send(null)
                }
                return r.manager.itemStart(e), u
            }
            Jo[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
            })
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResponseType: function(e) {
            return this.responseType = e, this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e, this
        },
        setMimeType: function(e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(Tn.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new Mn(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = wn.parse(e[i]);
                t.push(n)
            }
            return t
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Sn.prototype, {
        load: function(e, t, i, n) {
            function r(r) {
                l.load(e[r], (function(e) {
                    e = o._parser(e, !0), a[r] = {
                        width: e.width,
                        height: e.height,
                        format: e.format,
                        mipmaps: e.mipmaps
                    }, 6 === (c += 1) && (1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s))
                }), i, n)
            }
            var o = this,
                a = [],
                s = new Wt;
            s.image = a;
            var l = new Mn(this.manager);
            if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
                for (var c = 0, h = 0, u = e.length; h < u; ++h) r(h);
            else l.load(e, (function(e) {
                if ((e = o._parser(e, !0)).isCubemap)
                    for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                        a[n] = {
                            mipmaps: []
                        };
                        for (var r = 0; r < e.mipmapCount; r++) a[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), a[n].format = e.format, a[n].width = e.width, a[n].height = e.height
                    } else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s)
            }), i, n);
            return s
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(An.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new u,
                a = new Mn(this.manager);
            return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(e, (function(e) {
                (e = r._parser(e)) && (void 0 !== e.image ? o.image = e.image : void 0 !== e.data && (o.image.width = e.width, o.image.height = e.height, o.image.data = e.data), o.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, o.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, o.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, o.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008, o.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (o.format = e.format), void 0 !== e.type && (o.type = e.type), void 0 !== e.mipmaps && (o.mipmaps = e.mipmaps), 1 === e.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, t && t(o, e))
            }), i, n), o
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Cn.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            function r() {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), Yo.add(e, this), t && t(this), a.manager.itemEnd(e)
            }

            function o(t) {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), n && n(t), a.manager.itemError(e), a.manager.itemEnd(e)
            }
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var a = this,
                s = Yo.get(e);
            if (void 0 !== s) return a.manager.itemStart(e), setTimeout((function() {
                t && t(s), a.manager.itemEnd(e)
            }), 0), s;
            var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return l.addEventListener("load", r, !1), l.addEventListener("error", o, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Ln.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            function r(i) {
                a.load(e[i], (function(e) {
                    o.images[i] = e, 6 === ++s && (o.needsUpdate = !0, t && t(o))
                }), void 0, n)
            }
            var o = new se,
                a = new Cn(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var s = 0;
            for (i = 0; i < e.length; ++i) r(i);
            return o
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Dn.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = new a,
                o = new Cn(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(i) {
                r.image = i, i = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r)
            }), i, n), r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Pn.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(e, t) {
            return e = this.getUtoTmapping(e), this.getPoint(e, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i = [],
                n = this.getPoint(0),
                r = 0;
            for (i.push(0), t = 1; t <= e; t++) {
                var o = this.getPoint(t / e);
                r += o.distanceTo(n), i.push(r), n = o
            }
            return this.cacheArcLengths = i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var i = this.getLengths(),
                n = i.length;
            t = t || e * i[n - 1];
            for (var r, o = 0, a = n - 1; o <= a;)
                if (0 > (r = i[e = Math.floor(o + (a - o) / 2)] - t)) o = e + 1;
                else {
                    if (!(0 < r)) {
                        a = e;
                        break
                    }
                    a = e - 1
                } return i[e = a] === t ? e / (n - 1) : (e + (t - (o = i[e])) / (i[e + 1] - o)) / (n - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4;
            return 0 > t && (t = 0), 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
        },
        getTangentAt: function(e) {
            return e = this.getUtoTmapping(e), this.getTangent(e)
        },
        computeFrenetFrames: function(e, t) {
            var i, n = new r,
                o = [],
                a = [],
                s = [],
                l = new r,
                c = new g;
            for (i = 0; i <= e; i++) {
                var h = i / e;
                o[i] = this.getTangentAt(h), o[i].normalize()
            }
            a[0] = new r, s[0] = new r, i = Number.MAX_VALUE, h = Math.abs(o[0].x);
            var u = Math.abs(o[0].y),
                d = Math.abs(o[0].z);
            for (h <= i && (i = h, n.set(1, 0, 0)), u <= i && (i = u, n.set(0, 1, 0)), d <= i && n.set(0, 0, 1), l.crossVectors(o[0], n).normalize(), a[0].crossVectors(o[0], l), s[0].crossVectors(o[0], a[0]), i = 1; i <= e; i++) a[i] = a[i - 1].clone(), s[i] = s[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(fo.clamp(o[i - 1].dot(o[i]), -1, 1)), a[i].applyMatrix4(c.makeRotationAxis(l, n))), s[i].crossVectors(o[i], a[i]);
            if (!0 === t)
                for (n = Math.acos(fo.clamp(a[0].dot(a[e]), -1, 1)), n /= e, 0 < o[0].dot(l.crossVectors(a[0], a[e])) && (n = -n), i = 1; i <= e; i++) a[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), s[i].crossVectors(o[i], a[i]);
            return {
                tangents: o,
                normals: a,
                binormals: s
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), Rn.prototype = Object.create(Pn.prototype), Rn.prototype.constructor = Rn, Rn.prototype.isEllipseCurve = !0, Rn.prototype.getPoint = function(e, t) {
        t = t || new i;
        for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + e * r, e = this.aX + this.xRadius * Math.cos(n);
        var a = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), e = (o = e - this.aX) * n - (a -= this.aY) * r + this.aX, a = o * r + a * n + this.aY), t.set(e, a)
    }, Rn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, Rn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, Rn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, On.prototype = Object.create(Rn.prototype), On.prototype.constructor = On, On.prototype.isArcCurve = !0;
    var Qo = new r,
        $o = new In,
        Ko = new In,
        ea = new In;
    zn.prototype = Object.create(Pn.prototype), zn.prototype.constructor = zn, zn.prototype.isCatmullRomCurve3 = !0, zn.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.points,
            n = i.length;
        e *= n - (this.closed ? 0 : 1);
        var o = Math.floor(e);
        if (e -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === e && o === n - 1 && (o = n - 2, e = 1), this.closed || 0 < o) var a = i[(o - 1) % n];
        else Qo.subVectors(i[0], i[1]).add(i[0]), a = Qo;
        var s = i[o % n],
            l = i[(o + 1) % n];
        if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Qo.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Qo), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var c = "chordal" === this.curveType ? .5 : .25;
            n = Math.pow(a.distanceToSquared(s), c), 1e-4 > (o = Math.pow(s.distanceToSquared(l), c)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (c = Math.pow(l.distanceToSquared(i), c)) && (c = o), $o.initNonuniformCatmullRom(a.x, s.x, l.x, i.x, n, o, c), Ko.initNonuniformCatmullRom(a.y, s.y, l.y, i.y, n, o, c), ea.initNonuniformCatmullRom(a.z, s.z, l.z, i.z, n, o, c)
        } else "catmullrom" === this.curveType && ($o.initCatmullRom(a.x, s.x, l.x, i.x, this.tension), Ko.initCatmullRom(a.y, s.y, l.y, i.y, this.tension), ea.initCatmullRom(a.z, s.z, l.z, i.z, this.tension));
        return t.set($o.calc(e), Ko.calc(e), ea.calc(e)), t
    }, zn.prototype.copy = function(e) {
        Pn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, zn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, zn.prototype.fromJSON = function(e) {
        Pn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new r).fromArray(n))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, kn.prototype = Object.create(Pn.prototype), kn.prototype.constructor = kn, kn.prototype.isCubicBezierCurve = !0, kn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return t.set(Fn(e, n.x, r.x, o.x, a.x), Fn(e, n.y, r.y, o.y, a.y)), t
    }, kn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, kn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, kn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, Un.prototype = Object.create(Pn.prototype), Un.prototype.constructor = Un, Un.prototype.isCubicBezierCurve3 = !0, Un.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2,
            a = this.v3;
        return t.set(Fn(e, i.x, n.x, o.x, a.x), Fn(e, i.y, n.y, o.y, a.y), Fn(e, i.z, n.z, o.z, a.z)), t
    }, Un.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, Un.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, Un.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, Hn.prototype = Object.create(Pn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isLineCurve = !0, Hn.prototype.getPoint = function(e, t) {
        return t = t || new i, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Hn.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, Hn.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }, Hn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Hn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Hn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Gn.prototype = Object.create(Pn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isLineCurve3 = !0, Gn.prototype.getPoint = function(e, t) {
        return t = t || new r, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Gn.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, Gn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Gn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Gn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, jn.prototype = Object.create(Pn.prototype), jn.prototype.constructor = jn, jn.prototype.isQuadraticBezierCurve = !0, jn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2;
        return t.set(Bn(e, n.x, r.x, o.x), Bn(e, n.y, r.y, o.y)), t
    }, jn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, jn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, jn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Vn.prototype = Object.create(Pn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isQuadraticBezierCurve3 = !0, Vn.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2;
        return t.set(Bn(e, i.x, n.x, o.x), Bn(e, i.y, n.y, o.y), Bn(e, i.z, n.z, o.z)), t
    }, Vn.prototype.copy = function(e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Vn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Vn.prototype.fromJSON = function(e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Wn.prototype = Object.create(Pn.prototype), Wn.prototype.constructor = Wn, Wn.prototype.isSplineCurve = !0, Wn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.points,
            r = (n.length - 1) * e;
        r -= e = Math.floor(r);
        var o = n[0 === e ? e : e - 1],
            a = n[e],
            s = n[e > n.length - 2 ? n.length - 1 : e + 1];
        return n = n[e > n.length - 3 ? n.length - 1 : e + 2], t.set(Nn(r, o.x, a.x, s.x, n.x), Nn(r, o.y, a.y, s.y, n.y)), t
    }, Wn.prototype.copy = function(e) {
        Pn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this
    }, Wn.prototype.toJSON = function() {
        var e = Pn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e
    }, Wn.prototype.fromJSON = function(e) {
        Pn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new i).fromArray(r))
        }
        return this
    };
    var ta = Object.freeze({
        ArcCurve: On,
        CatmullRomCurve3: zn,
        CubicBezierCurve: kn,
        CubicBezierCurve3: Un,
        EllipseCurve: Rn,
        LineCurve: Hn,
        LineCurve3: Gn,
        QuadraticBezierCurve: jn,
        QuadraticBezierCurve3: Vn,
        SplineCurve: Wn
    });
    qn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: qn,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Hn(t, e))
        },
        getPoint: function(e) {
            var t = e * this.getLength(),
                i = this.getCurveLengths();
            for (e = 0; e < i.length;) {
                if (i[e] >= t) return t = i[e] - t, i = (e = this.curves[e]).getLength(), e.getPointAt(0 === i ? 0 : 1 - t / i);
                e++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++) {
                var o = r[n];
                o = o.getPoints(o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e);
                for (var a = 0; a < o.length; a++) {
                    var s = o[a];
                    t && t.equals(s) || (i.push(s), t = s)
                }
            }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        copy: function(e) {
            Pn.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) this.curves.push(e.curves[t].clone());
            return this.autoClose = e.autoClose, this
        },
        toJSON: function() {
            var e = Pn.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) e.curves.push(this.curves[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            Pn.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new ta[n.type]).fromJSON(n))
            }
            return this
        }
    }), Xn.prototype = Object.assign(Object.create(qn.prototype), {
        constructor: Xn,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var n = new Hn(this.currentPoint.clone(), new i(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            e = new jn(this.currentPoint.clone(), new i(e, t), new i(n, r)), this.curves.push(e), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(e, t, n, r, o, a) {
            e = new kn(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(o, a)), this.curves.push(e), this.currentPoint.set(o, a)
        },
        splineThru: function(e) {
            var t = [this.currentPoint.clone()].concat(e);
            t = new Wn(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, i, n, r, o) {
            this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o)
        },
        absarc: function(e, t, i, n, r, o) {
            this.absellipse(e, t, i, i, n, r, o)
        },
        ellipse: function(e, t, i, n, r, o, a, s) {
            this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o, a, s)
        },
        absellipse: function(e, t, i, n, r, o, a, s) {
            e = new Rn(e, t, i, n, r, o, a, s), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e)
        },
        copy: function(e) {
            return qn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function() {
            var e = qn.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function(e) {
            return qn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), Yn.prototype = Object.assign(Object.create(Xn.prototype), {
        constructor: Yn,
        getPointsHoles: function(e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            Xn.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) this.holes.push(e.holes[t].clone());
            return this
        },
        toJSON: function() {
            var e = Xn.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) e.holes.push(this.holes[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            Xn.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new Xn).fromJSON(n))
            }
            return this
        }
    }), Zn.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Zn,
        isLight: !0,
        copy: function(e) {
            return T.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Jn.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Jn,
        isHemisphereLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(Qn.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), $n.prototype = Object.assign(Object.create(Qn.prototype), {
        constructor: $n,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera,
                i = 2 * fo.RAD2DEG * e.angle,
                n = this.mapSize.width / this.mapSize.height;
            e = e.distance || t.far, i === t.fov && n === t.aspect && e === t.far || (t.fov = i, t.aspect = n, t.far = e, t.updateProjectionMatrix())
        }
    }), Kn.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Kn,
        isSpotLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), er.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: er,
        isPointLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), tr.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: tr,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return xt.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function(e, t, i, n, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - e;
            if (i += e, e = n + t, t = n - t, null !== this.view && this.view.enabled) {
                i = this.zoom / (this.view.width / this.view.fullWidth), t = this.zoom / (this.view.height / this.view.fullHeight);
                var o = (this.right - this.left) / this.view.width;
                n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, t = (e -= this.view.offsetY / t * n) - this.view.height / t * n
            }
            this.projectionMatrix.makeOrthographic(r, i, e, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), ir.prototype = Object.assign(Object.create(Qn.prototype), {
        constructor: ir
    }), nr.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: nr,
        isDirectionalLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), rr.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: rr,
        isAmbientLight: !0
    }), or.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: or,
        isRectAreaLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function(e) {
            return (e = Zn.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, e
        }
    }), Object.assign(ar.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new Mn(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            function t(e) {
                return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
            }
            var n = this.textures,
                a = new qo[e.type];
            if (void 0 !== e.uuid && (a.uuid = e.uuid), void 0 !== e.name && (a.name = e.name), void 0 !== e.color && a.color.setHex(e.color), void 0 !== e.roughness && (a.roughness = e.roughness), void 0 !== e.metalness && (a.metalness = e.metalness), void 0 !== e.emissive && a.emissive.setHex(e.emissive), void 0 !== e.specular && a.specular.setHex(e.specular), void 0 !== e.shininess && (a.shininess = e.shininess), void 0 !== e.clearCoat && (a.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (a.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (a.vertexColors = e.vertexColors), void 0 !== e.fog && (a.fog = e.fog), void 0 !== e.flatShading && (a.flatShading = e.flatShading), void 0 !== e.blending && (a.blending = e.blending), void 0 !== e.combine && (a.combine = e.combine), void 0 !== e.side && (a.side = e.side), void 0 !== e.opacity && (a.opacity = e.opacity), void 0 !== e.transparent && (a.transparent = e.transparent), void 0 !== e.alphaTest && (a.alphaTest = e.alphaTest), void 0 !== e.depthTest && (a.depthTest = e.depthTest), void 0 !== e.depthWrite && (a.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (a.colorWrite = e.colorWrite), void 0 !== e.wireframe && (a.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (a.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (a.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (a.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (a.rotation = e.rotation), 1 !== e.linewidth && (a.linewidth = e.linewidth), void 0 !== e.dashSize && (a.dashSize = e.dashSize), void 0 !== e.gapSize && (a.gapSize = e.gapSize), void 0 !== e.scale && (a.scale = e.scale), void 0 !== e.polygonOffset && (a.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (a.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (a.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (a.skinning = e.skinning), void 0 !== e.morphTargets && (a.morphTargets = e.morphTargets), void 0 !== e.dithering && (a.dithering = e.dithering), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.uniforms)
                for (var l in e.uniforms) {
                    var c = e.uniforms[l];
                    switch (a.uniforms[l] = {}, c.type) {
                        case "t":
                            a.uniforms[l].value = t(c.value);
                            break;
                        case "c":
                            a.uniforms[l].value = (new b).setHex(c.value);
                            break;
                        case "v2":
                            a.uniforms[l].value = (new i).fromArray(c.value);
                            break;
                        case "v3":
                            a.uniforms[l].value = (new r).fromArray(c.value);
                            break;
                        case "v4":
                            a.uniforms[l].value = (new s).fromArray(c.value);
                            break;
                        case "m3":
                            a.uniforms[l].value = (new o).fromArray(c.value);
                        case "m4":
                            a.uniforms[l].value = (new g).fromArray(c.value);
                            break;
                        default:
                            a.uniforms[l].value = c.value
                    }
                }
            if (void 0 !== e.defines && (a.defines = e.defines), void 0 !== e.vertexShader && (a.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (a.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var h in e.extensions) a.extensions[h] = e.extensions[h];
            return void 0 !== e.shading && (a.flatShading = 1 === e.shading), void 0 !== e.size && (a.size = e.size), void 0 !== e.sizeAttenuation && (a.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (a.map = t(e.map)), void 0 !== e.matcap && (a.matcap = t(e.matcap)), void 0 !== e.alphaMap && (a.alphaMap = t(e.alphaMap), a.transparent = !0), void 0 !== e.bumpMap && (a.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (a.bumpScale = e.bumpScale), void 0 !== e.normalMap && (a.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (a.normalMapType = e.normalMapType), void 0 !== e.normalScale && (l = e.normalScale, !1 === Array.isArray(l) && (l = [l, l]), a.normalScale = (new i).fromArray(l)), void 0 !== e.displacementMap && (a.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (a.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (a.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (a.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (a.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (a.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (a.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (a.specularMap = t(e.specularMap)), void 0 !== e.envMap && (a.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (a.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (a.reflectivity = e.reflectivity), void 0 !== e.lightMap && (a.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (a.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (a.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (a.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (a.gradientMap = t(e.gradientMap)), a
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setTextures: function(e) {
            return this.textures = e, this
        }
    });
    var ia = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };
    sr.prototype = Object.assign(Object.create(k.prototype), {
        constructor: sr,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return k.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = k.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
        }
    }), lr.prototype = Object.assign(Object.create(A.prototype), {
        constructor: lr,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return A.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function() {
            var e = A.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Object.assign(cr.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new Mn(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            var t = e.isInstancedBufferGeometry ? new sr : new k,
                i = e.data.index;
            if (void 0 !== i) {
                var n = new na[i.type](i.array);
                t.setIndex(new A(n, 1))
            }
            for (var o in i = e.data.attributes) {
                var a = i[o];
                n = new na[a.type](a.array), n = new(a.isInstancedBufferAttribute ? lr : A)(n, a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), t.addAttribute(o, n)
            }
            var s = e.data.morphAttributes;
            if (s)
                for (o in s) {
                    var l = s[o],
                        c = [];
                    i = 0;
                    for (var h = l.length; i < h; i++) a = l[i], n = new A(n = new na[a.type](a.array), a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), c.push(n);
                    t.morphAttributes[o] = c
                }
            if (void 0 !== (o = e.data.groups || e.data.drawcalls || e.data.offsets))
                for (i = 0, a = o.length; i !== a; ++i) n = o[i], t.addGroup(n.start, n.count, n.materialIndex);
            return void 0 !== (i = e.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), t.boundingSphere = new p(o, i.radius)), e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
        },
        setPath: function(e) {
            return this.path = e, this
        }
    });
    var na = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Object.assign(hr.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = this,
                o = void 0 === this.path ? ia.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o, (o = new Mn(r.manager)).setPath(this.path), o.load(e, (function(i) {
                var o = null;
                try {
                    o = JSON.parse(i)
                } catch (t) {
                    return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e) : r.parse(o, t)
            }), i, n)
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e, this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        parse: function(e, t) {
            var i = this.parseShape(e.shapes);
            i = this.parseGeometries(e.geometries, i);
            var n = this.parseImages(e.images, (function() {
                void 0 !== t && t(r)
            }));
            n = this.parseTextures(e.textures, n), n = this.parseMaterials(e.materials, n);
            var r = this.parseObject(e.object, i, n);
            return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var i = 0, n = e.length; i < n; i++) {
                    var r = (new Yn).fromJSON(e[i]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var n = new cr, r = 0, o = e.length; r < o; r++) {
                    var a = e[r];
                    switch (a.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            var s = new Wo[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new Wo[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new Wo[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new Wo[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new Wo[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new Wo[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new Wo[a.type](a.radius, a.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new Wo[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new Wo[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new Wo[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            s = new Wo[a.type]((new ta[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new Wo[a.type](a.points, a.segments, a.phiStart, a.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new Wo[a.type](a.vertices, a.indices, a.radius, a.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            s = [];
                            for (var l = 0, c = a.shapes.length; l < c; l++) {
                                var h = t[a.shapes[l]];
                                s.push(h)
                            }
                            s = new Wo[a.type](s, a.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (s = [], l = 0, c = a.shapes.length; l < c; l++) h = t[a.shapes[l]], s.push(h);
                            void 0 !== (l = a.options.extrudePath) && (a.options.extrudePath = (new ta[l.type]).fromJSON(l)), s = new Wo[a.type](s, a.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            s = n.parse(a);
                            break;
                        case "Geometry":
                            "THREE" in window && "LegacyJSONLoader" in THREE ? s = (new THREE.LegacyJSONLoader).parse(a, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
                            continue
                    }
                    s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s
                }
            return i
        },
        parseMaterials: function(e, t) {
            var i = {},
                n = {};
            if (void 0 !== e) {
                var r = new ar;
                r.setTextures(t), t = 0;
                for (var o = e.length; t < o; t++) {
                    var a = e[t];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], l = 0; l < a.materials.length; l++) {
                            var c = a.materials[l];
                            void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), s.push(i[c.uuid])
                        }
                        n[a.uuid] = s
                    } else void 0 === i[a.uuid] && (i[a.uuid] = r.parse(a)), n[a.uuid] = i[a.uuid]
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i],
                    r = wn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            function i(e) {
                return n.manager.itemStart(e), o.load(e, (function() {
                    n.manager.itemEnd(e)
                }), void 0, (function() {
                    n.manager.itemError(e), n.manager.itemEnd(e)
                }))
            }
            var n = this,
                r = {};
            if (void 0 !== e && 0 < e.length) {
                var o = new Cn(t = new En(t));
                o.setCrossOrigin(this.crossOrigin), t = 0;
                for (var a = e.length; t < a; t++) {
                    var s = e[t],
                        l = s.url;
                    if (Array.isArray(l)) {
                        r[s.uuid] = [];
                        for (var c = 0, h = l.length; c < h; c++) {
                            var u = l[c];
                            u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[s.uuid].push(i(u))
                        }
                    } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url, r[s.uuid] = i(u)
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var n = {};
            if (void 0 !== e)
                for (var r = 0, o = e.length; r < o; r++) {
                    var s = e[r];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    var l = Array.isArray(t[s.image]) ? new se(t[s.image]) : new a(t[s.image]);
                    l.needsUpdate = !0, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = i(s.mapping, ra)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = i(s.wrap[0], oa), l.wrapT = i(s.wrap[1], oa)), void 0 !== s.format && (l.format = s.format), void 0 !== s.type && (l.type = s.type), void 0 !== s.encoding && (l.encoding = s.encoding), void 0 !== s.minFilter && (l.minFilter = i(s.minFilter, aa)), void 0 !== s.magFilter && (l.magFilter = i(s.magFilter, aa)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), n[s.uuid] = l
                }
            return n
        },
        parseObject: function(e, t, i) {
            function n(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
            }

            function r(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var o = e[n];
                            void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(i[o])
                        }
                        return t
                    }
                    return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e]
                }
            }
            switch (e.type) {
                case "Scene":
                    var o = new Lt;
                    void 0 !== e.background && Number.isInteger(e.background) && (o.background = new b(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new Ct(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new At(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    o = new wt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    o = new tr(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    o = new rr(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    o = new nr(e.color, e.intensity);
                    break;
                case "PointLight":
                    o = new er(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    o = new or(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    o = new Kn(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case "HemisphereLight":
                    o = new Jn(e.color, e.groundColor, e.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    o = n(e.geometry);
                    var a = r(e.material);
                    o = o.bones && 0 < o.bones.length ? new zt(o, a) : new Z(o, a), void 0 !== e.drawMode && o.setDrawMode(e.drawMode);
                    break;
                case "LOD":
                    o = new It;
                    break;
                case "Line":
                    o = new kt(n(e.geometry), r(e.material), e.mode);
                    break;
                case "LineLoop":
                    o = new Ht(n(e.geometry), r(e.material));
                    break;
                case "LineSegments":
                    o = new Ut(n(e.geometry), r(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    o = new jt(n(e.geometry), r(e.material));
                    break;
                case "Sprite":
                    o = new Ot(r(e.material));
                    break;
                case "Group":
                    o = new bt;
                    break;
                default:
                    o = new T
            }
            if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.layers && (o.layers.mask = e.layers), void 0 !== e.children) {
                a = e.children;
                for (var s = 0; s < a.length; s++) o.add(this.parseObject(a[s], t, i))
            }
            if ("LOD" === e.type)
                for (e = e.levels, a = 0; a < e.length; a++) {
                    s = e[a];
                    var l = o.getObjectByProperty("uuid", s.object);
                    void 0 !== l && o.addLevel(l, s.distance)
                }
            return o
        }
    });
    var ra = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        oa = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        aa = {
            NearestFilter: 1003,
            NearestMipMapNearestFilter: 1004,
            NearestMipMapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: 1008
        };
    ur.prototype = {
        constructor: ur,
        setOptions: function(e) {
            return this.options = e, this
        },
        load: function(e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = Yo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            fetch(e).then((function(e) {
                return e.blob()
            })).then((function(e) {
                return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
            })).then((function(i) {
                Yo.add(e, i), t && t(i), r.manager.itemEnd(e)
            })).catch((function(t) {
                n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
            })), r.manager.itemStart(e)
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }, Object.assign(dr.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new Xn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, o) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, o)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i],
                        o = new Yn;
                    o.curves = r.curves, t.push(o)
                }
                return t
            }

            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                    var a = t[r],
                        s = t[o],
                        l = s.x - a.x,
                        c = s.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (0 > c && (a = t[o], l = -l, s = t[r], c = -c), !(e.y < a.y || e.y > s.y))
                            if (e.y === a.y) {
                                if (e.x === a.x) return !0
                            } else {
                                if (0 === (r = c * (e.x - a.x) - l * (e.y - a.y))) return !0;
                                0 > r || (n = !n)
                            }
                    } else if (e.y === a.y && (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x)) return !0
                }
                return n
            }
            var r = jo.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === t) return i(o);
            if (t = [], 1 === o.length) {
                var a = o[0],
                    s = new Yn;
                return s.curves = a.curves, t.push(s), t
            }
            var l = !r(o[0].getPoints());
            l = e ? !l : l, s = [];
            var c = [],
                h = [],
                u = 0;
            c[u] = void 0, h[u] = [];
            for (var d = 0, p = o.length; d < p; d++) {
                var f = (a = o[d]).getPoints(),
                    m = r(f);
                (m = e ? !m : m) ? (!l && c[u] && u++, c[u] = {
                    s: new Yn,
                    p: f
                }, c[u].s.curves = a.curves, l && u++, h[u] = []) : h[u].push({
                    h: a,
                    p: f[0]
                })
            }
            if (!c[0]) return i(o);
            if (1 < c.length) {
                for (d = !1, e = [], r = 0, o = c.length; r < o; r++) s[r] = [];
                for (r = 0, o = c.length; r < o; r++)
                    for (a = h[r], m = 0; m < a.length; m++) {
                        for (l = a[m], u = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && e.push({
                            froms: r,
                            tos: f,
                            hole: m
                        }), u ? (u = !1, s[f].push(l)) : d = !0);
                        u && s[r].push(l)
                    }
                0 < e.length && (d || (h = s))
            }
            for (d = 0, r = c.length; d < r; d++)
                for (s = c[d].s, t.push(s), o = 0, a = (e = h[d]).length; o < a; o++) s.holes.push(e[o].h);
            return t
        }
    }), Object.assign(pr.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            var i = [],
                n = t;
            t = this.data;
            var r = Array.from ? Array.from(e) : String(e).split("");
            n /= t.resolution;
            var o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n;
            e = [];
            for (var a = 0, s = 0, l = 0; l < r.length; l++) {
                var c = r[l];
                if ("\n" === c) a = 0, s -= o;
                else {
                    var h = n,
                        u = a,
                        d = s;
                    if (c = t.glyphs[c] || t.glyphs["?"]) {
                        var p = new dr;
                        if (c.o)
                            for (var f = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * h + u,
                                        y = f[m++] * h + d;
                                    p.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * h + u, y = f[m++] * h + d, p.lineTo(v, y);
                                    break;
                                case "q":
                                    var b = f[m++] * h + u,
                                        x = f[m++] * h + d,
                                        w = f[m++] * h + u,
                                        _ = f[m++] * h + d;
                                    p.quadraticCurveTo(w, _, b, x);
                                    break;
                                case "b":
                                    b = f[m++] * h + u, x = f[m++] * h + d, w = f[m++] * h + u, _ = f[m++] * h + d, v = f[m++] * h + u, y = f[m++] * h + d, p.bezierCurveTo(w, _, v, y, b, x)
                            }
                        h = {
                            offsetX: c.ha * h,
                            path: p
                        }
                    } else h = void 0;
                    a += h.offsetX, e.push(h.path)
                }
            }
            for (t = 0, r = e.length; t < r; t++) Array.prototype.push.apply(i, e[t].toShapes());
            return i
        }
    }), Object.assign(fr.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new Mn(this.manager);
            o.setPath(this.path), o.load(e, (function(e) {
                try {
                    var i = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
                }
                e = r.parse(i), t && t(e)
            }), i, n)
        },
        parse: function(e) {
            return new pr(e)
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), mr.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i + 1];
                if (t[i].test(e)) return r
            }
            return null
        }
    }, Object.assign(mr.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: function() {
            var e = {
                    NoBlending: 0,
                    NormalBlending: 1,
                    AdditiveBlending: 2,
                    SubtractiveBlending: 3,
                    MultiplyBlending: 4,
                    CustomBlending: 5
                },
                t = new b,
                i = new Dn,
                n = new ar;
            return function(r, o, a) {
                function s(e, t, n, r, s) {
                    e = o + e;
                    var l = mr.Handlers.get(e);
                    return null !== l ? e = l.load(e) : (i.setCrossOrigin(a), e = i.load(e)), void 0 !== t && (e.repeat.fromArray(t), 1 !== t[0] && (e.wrapS = 1e3), 1 !== t[1] && (e.wrapT = 1e3)), void 0 !== n && e.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (e.wrapS = 1e3), "mirror" === r[0] && (e.wrapS = 1002), "repeat" === r[1] && (e.wrapT = 1e3), "mirror" === r[1] && (e.wrapT = 1002)), void 0 !== s && (e.anisotropy = s), t = fo.generateUUID(), c[t] = e, t
                }
                var l, c = {},
                    h = {
                        uuid: fo.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (l in r) {
                    var u = r[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "DbgName":
                            h.name = u;
                            break;
                        case "blending":
                            h.blending = e[u];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            h.color = t.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            h.specular = t.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            h.emissive = t.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            h.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            h.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapEmissive":
                            h.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case "mapLight":
                            h.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapAO":
                            h.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapBump":
                            h.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            h.bumpScale = u;
                            break;
                        case "mapNormal":
                            h.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            h.normalScale = u;
                            break;
                        case "mapSpecular":
                            h.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapMetalness":
                            h.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case "mapRoughness":
                            h.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case "mapAlpha":
                            h.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "flipSided":
                            h.side = 1;
                            break;
                        case "doubleSided":
                            h.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), h.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            h[l] = u;
                            break;
                        case "vertexColors":
                            !0 === u && (h.vertexColors = 2), "face" === u && (h.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                    }
                }
                return "MeshBasicMaterial" === h.type && delete h.emissive, "MeshPhongMaterial" !== h.type && delete h.specular, 1 > h.opacity && (h.transparent = !0), n.setTextures(c), n.parse(h)
            }
        }()
    });
    var sa, la, ca, ha = {
        getContext: function() {
            return void 0 === sa && (sa = new(window.AudioContext || window.webkitAudioContext)), sa
        },
        setContext: function(e) {
            sa = e
        }
    };
    Object.assign(gr.prototype, {
        load: function(e, t, i, n) {
            var r = new Mn(this.manager);
            r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function(e) {
                e = e.slice(0), ha.getContext().decodeAudioData(e, (function(e) {
                    t(e)
                }))
            }), i, n)
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(vr.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .282095 * r[0], t += .488603 * r[1] * n, t += .488603 * r[2] * e, t += .488603 * r[3] * i, t += 1.092548 * r[4] * i * n, t += 1.092548 * r[5] * n * e, t += .315392 * r[6] * (3 * e * e - 1), (t += 1.092548 * r[7] * i * e) + .546274 * r[8] * (i * i - n * n)
        },
        getIrradianceAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .886227 * r[0], t += 1.023328 * r[1] * n, t += 1.023328 * r[2] * e, t += 1.023328 * r[3] * i, t += .858086 * r[4] * i * n, t += .858086 * r[5] * n * e, t += r[6] * (.743125 * e * e - .247708), (t += .858086 * r[7] * i * e) + .429043 * r[8] * (i * i - n * n)
        },
        add: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var i = 0; 9 > i; i++) this.coefficients[i].lerp(e.coefficients[i], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; 9 > t; t++)
                if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e) {
            for (var t = this.coefficients, i = 0; 9 > i; i++) t[i].fromArray(e, 3 * i);
            return this
        },
        toArray: function() {
            for (var e = [], t = this.coefficients, i = 0; 9 > i; i++) t[i].toArray(e, 3 * i);
            return e
        }
    }), Object.assign(vr, {
        getBasisAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z, t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * e, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * i * e, t[8] = .546274 * (i * i - n * n)
        }
    }), yr.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: yr,
        isLightProbe: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            return Zn.prototype.toJSON.call(this, e)
        }
    }), br.prototype = Object.assign(Object.create(yr.prototype), {
        constructor: br,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return yr.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return yr.prototype.toJSON.call(this, e)
        }
    }), xr.prototype = Object.assign(Object.create(yr.prototype), {
        constructor: xr,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return yr.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return yr.prototype.toJSON.call(this, e)
        }
    }), Object.assign(wr.prototype, {
        update: function() {
            var e, t, i, n, r, o, a, s, l = new g,
                c = new g;
            return function(h) {
                if (e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep) {
                    e = this, t = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, o = h.far, a = h.zoom;
                    var u = h.projectionMatrix.clone(),
                        d = (s = this.eyeSep / 2) * r / t,
                        p = r * Math.tan(fo.DEG2RAD * i * .5) / a;
                    c.elements[12] = -s, l.elements[12] = s;
                    var f = -p * n + d,
                        m = p * n + d;
                    u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(u), f = -p * n - d, m = p * n - d, u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(u)
                }
                this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(l)
            }
        }()
    }), _r.prototype = Object.create(T.prototype), _r.prototype.constructor = _r, Object.assign(Er.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }), Mr.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Mr,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function() {
            var e = new r,
                t = new n,
                i = new r,
                o = new r,
                a = new Er;
            return function(n) {
                T.prototype.updateMatrixWorld.call(this, n), n = this.context.listener;
                var r = this.up;
                if (this.timeDelta = a.getDelta(), this.matrixWorld.decompose(e, t, i), o.set(0, 0, -1).applyQuaternion(t), n.positionX) {
                    var s = this.context.currentTime + this.timeDelta;
                    n.positionX.linearRampToValueAtTime(e.x, s), n.positionY.linearRampToValueAtTime(e.y, s), n.positionZ.linearRampToValueAtTime(e.z, s), n.forwardX.linearRampToValueAtTime(o.x, s), n.forwardY.linearRampToValueAtTime(o.y, s), n.forwardZ.linearRampToValueAtTime(o.z, s), n.upX.linearRampToValueAtTime(r.x, s), n.upY.linearRampToValueAtTime(r.y, s), n.upZ.linearRampToValueAtTime(r.z, s)
                } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z, r.x, r.y, r.z)
            }
        }()
    }), Tr.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Tr,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        },
        setBuffer: function(e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function() {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        setDetune: function(e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    }), Sr.prototype = Object.assign(Object.create(Tr.prototype), {
        constructor: Sr,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e, this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e, this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e, this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e, this
        },
        setDirectionalCone: function(e, t, i) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
        },
        updateMatrixWorld: function() {
            var e = new r,
                t = new n,
                i = new r,
                o = new r;
            return function(n) {
                if (T.prototype.updateMatrixWorld.call(this, n), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                    if (this.matrixWorld.decompose(e, t, i), o.set(0, 0, 1).applyQuaternion(t), (n = this.panner).positionX) {
                        var r = this.context.currentTime + this.listener.timeDelta;
                        n.positionX.linearRampToValueAtTime(e.x, r), n.positionY.linearRampToValueAtTime(e.y, r), n.positionZ.linearRampToValueAtTime(e.z, r), n.orientationX.linearRampToValueAtTime(o.x, r), n.orientationY.linearRampToValueAtTime(o.y, r), n.orientationZ.linearRampToValueAtTime(o.z, r)
                    } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z)
            }
        }()
    }), Object.assign(Ar.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
            return e / t.length
        }
    }), Object.assign(Cr.prototype, {
        accumulate: function(e, t) {
            var i = this.buffer,
                n = this.valueSize;
            e = e * n + n;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== n; ++r) i[e + r] = i[r];
                r = t
            } else r += t, this._mixBufferRegion(i, e, 0, t / r, n);
            this.cumulativeWeight = r
        },
        apply: function(e) {
            var t = this.valueSize,
                i = this.buffer;
            e = e * t + t;
            var n = this.cumulativeWeight,
                r = this.binding;
            this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, e, 3 * t, 1 - n, t), n = t;
            for (var o = t + t; n !== o; ++n)
                if (i[n] !== i[n + t]) {
                    r.setValue(i, e);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.buffer,
                t = this.valueSize,
                i = 3 * t;
            this.binding.getValue(e, i);
            for (var n = t; n !== i; ++n) e[n] = e[i + n % t];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(e, t, i, n, r) {
            if (.5 <= n)
                for (n = 0; n !== r; ++n) e[t + n] = e[i + n]
        },
        _slerp: function(e, t, i, r) {
            n.slerpFlat(e, t, e, t, e, i, r)
        },
        _lerp: function(e, t, i, n, r) {
            for (var o = 1 - n, a = 0; a !== r; ++a) {
                var s = t + a;
                e[s] = e[s] * o + e[i + a] * n
            }
        }
    }), Object.assign(Lr.prototype, {
        getValue: function(e, t) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
        }
    }), Object.assign(Dr, {
        Composite: Lr,
        create: function(e, t, i) {
            return e && e.isAnimationObjectGroup ? new Dr.Composite(e, t, i) : new Dr(e, t, i)
        },
        sanitizeNodeName: function() {
            var e = /[\[\]\.:\/]/g;
            return function(t) {
                return t.replace(/\s/g, "_").replace(e, "")
            }
        }(),
        parseTrackName: function() {
            var e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                t = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            e = /(WCOD+)?/.source.replace("WCOD", e);
            var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                r = new RegExp("^" + t + e + i + n + "$"),
                o = ["material", "materials", "bones"];
            return function(e) {
                var t = r.exec(e);
                if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                var i = (t = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }).nodeName && t.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = t.nodeName.substring(i + 1); - 1 !== o.indexOf(n) && (t.nodeName = t.nodeName.substring(0, i), t.objectName = n)
                }
                if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return t
            }
        }(),
        findNode: function(e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                var i = e.skeleton.getBoneByName(t);
                if (void 0 !== i) return i
            }
            if (e.children) {
                var n = function(e) {
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.name === t || r.uuid === t || (r = n(r.children))) return r
                    }
                    return null
                };
                if (e = n(e.children)) return e
            }
            return null
        }
    }), Object.assign(Dr.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }, function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
        }, function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
            }, function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function() {
            var e = this.node,
                t = this.parsedPath,
                i = t.objectName,
                n = t.propertyName,
                r = t.propertyIndex;
            if (e || (this.node = e = Dr.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (i) {
                    var o = t.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            for (e = e.skeleton.bones, i = 0; i < e.length; i++)
                                if (e[i].name === o) {
                                    o = i;
                                    break
                                } break;
                        default:
                            if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[o]
                    }
                }
                if (void 0 === (o = e[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
                else {
                    if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (e.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (e.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Dr.prototype, {
        _getValue_unbound: Dr.prototype.getValue,
        _setValue_unbound: Dr.prototype.setValue
    }), Object.assign(Pr.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
                var u = arguments[c],
                    d = u.uuid,
                    p = n[d];
                if (void 0 === p) {
                    p = t++, n[d] = p, e.push(u), d = 0;
                    for (var f = s; d !== f; ++d) a[d].push(new Dr(u, r[d], o[d]))
                } else if (p < i) {
                    l = e[p];
                    var m = --i;
                    for (n[(f = e[m]).uuid] = p, e[p] = f, n[d] = m, e[m] = u, d = 0, f = s; d !== f; ++d) {
                        var g = a[d],
                            v = g[p];
                        g[p] = g[m], void 0 === v && (v = new Dr(u, r[d], o[d])), g[m] = v
                    }
                } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o],
                    l = s.uuid,
                    c = i[l];
                if (void 0 !== c && c >= t) {
                    var h = t++,
                        u = e[h];
                    for (i[u.uuid] = c, e[c] = u, i[l] = h, e[h] = s, s = 0, l = r; s !== l; ++s) {
                        var d = (u = n[s])[c];
                        u[c] = u[h], u[h] = d
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var l = arguments[a].uuid,
                    c = n[l];
                if (void 0 !== c)
                    if (delete n[l], c < i) {
                        var h = e[l = --i],
                            u = --t,
                            d = e[u];
                        for (n[h.uuid] = c, e[c] = h, n[d.uuid] = l, e[l] = d, e.pop(), h = 0, d = o; h !== d; ++h) {
                            var p = r[h],
                                f = p[u];
                            p[c] = p[l], p[l] = f, p.pop()
                        }
                    } else
                        for (n[(d = e[u = --t]).uuid] = c, e[c] = d, e.pop(), h = 0, d = o; h !== d; ++h)(p = r[h])[c] = p[u], p.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(e, t) {
            var i = this._bindingsIndicesByPath,
                n = i[e],
                r = this._bindings;
            if (void 0 !== n) return r[n];
            var o = this._paths,
                a = this._parsedPaths,
                s = this._objects,
                l = this.nCachedObjects_,
                c = Array(s.length);
            for (n = r.length, i[e] = n, o.push(e), a.push(t), r.push(c), i = l, n = s.length; i !== n; ++i) c[i] = new Dr(s[i], e, t);
            return c
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath,
                i = t[e];
            if (void 0 !== i) {
                var n = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    a = o.length - 1,
                    s = o[a];
                t[e[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
            }
        }
    }), Object.assign(Rr.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e, this
        },
        setLoop: function(e, t) {
            return this.loop = e, this.repetitions = t, this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, i) {
            if (e.fadeOut(t), this.fadeIn(t), i) {
                i = this._clip.duration;
                var n = e._clip.duration,
                    r = i / n;
                e.warp(1, n / i, t), this.warp(r, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._timeScaleInterpolant,
                a = this.timeScale;
            return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = e / a, o[1] = t / a, this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (0 > (t = (e - r) * i) || 0 === i) return;
                    this._startTime = null, t *= i
                }
                if (t *= this._updateTimeScale(e), i = this._updateTime(t), 0 < (e = this._updateWeight(e))) {
                    t = this._interpolants, r = this._propertyBindings;
                    for (var o = 0, a = t.length; o !== a; ++o) t[o].evaluate(i), r[o].accumulate(n, e)
                }
            } else this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0];
                    t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i) t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t
        },
        _updateTime: function(e) {
            var t = this.time + e,
                i = this._clip.duration,
                n = this.loop,
                r = this._loopCount,
                o = 2202 === n;
            if (0 === e) return -1 === r || !o || 1 & ~r ? t : i - t;
            if (2200 === n) e: {
                if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
                else {
                    if (!(0 > t)) {
                        this.time = t;
                        break e
                    }
                    t = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = t,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > e ? -1 : 1
                })
            }
            else {
                if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= i || 0 > t) {
                    t -= i * (n = Math.floor(t / i)), r += Math.abs(n);
                    var a = this.repetitions - r;
                    0 >= a ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t = 0 < e ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < e ? 1 : -1
                    })) : (1 === a ? (e = 0 > e, this._setEndings(e, !e, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = t, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    }))
                } else this.time = t;
                if (o && !(1 & ~r)) return i - t
            }
            return t
        },
        _setEndings: function(e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._weightInterpolant;
            return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = t, n[1] = r + e, o[1] = i, this
        }
    }), Or.prototype = Object.assign(Object.create(t.prototype), {
        constructor: Or,
        _bindAction: function(e, t) {
            var i = e._localRoot || this._root,
                n = e._clip.tracks,
                r = n.length,
                o = e._propertyBindings;
            e = e._interpolants;
            var a = i.uuid,
                s = this._bindingsByRootAndName,
                l = s[a];
            for (void 0 === l && (l = {}, s[a] = l), s = 0; s !== r; ++s) {
                var c = n[s],
                    h = c.name,
                    u = l[h];
                if (void 0 === u) {
                    if (void 0 !== (u = o[s])) {
                        null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, h));
                        continue
                    }++(u = new Cr(Dr.create(i, h, t && t._propertyBindings[s].binding.parsedPath), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(u, a, h)
                }
                o[s] = u, e[s].resultBuffer = u.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid,
                        i = e._clip.uuid,
                        n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                }
                for (i = 0, n = (t = e._propertyBindings).length; i !== n; ++i) {
                    var r = t[i];
                    0 === r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            return null !== (e = e._cacheIndex) && e < this._nActiveActions
        },
        _addInactiveAction: function(e, t, i) {
            var n = this._actions,
                r = this._actionsByClip,
                o = r[t];
            void 0 === o ? (o = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = o) : (t = o.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = n.length, n.push(e), o.actionByRoot[i] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions,
                i = t[t.length - 1],
                n = e._cacheIndex;
            i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null, t = e._clip.uuid;
            var r = (n = (i = this._actionsByClip)[t]).knownActions,
                o = r[r.length - 1],
                a = e._byClipCacheIndex;
            o._byClipCacheIndex = a, r[a] = o, r.pop(), e._byClipCacheIndex = null, delete n.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete i[t], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = 0, i = (e = e._propertyBindings).length; t !== i; ++t) {
                var n = e[t];
                0 === --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = this._nActiveActions++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackAction: function(e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = --this._nActiveActions,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _addInactiveBinding: function(e, t, i) {
            var n = this._bindingsByRootAndName,
                r = n[t],
                o = this._bindings;
            void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = o.length, o.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings,
                i = e.binding,
                n = i.rootNode.uuid;
            i = i.path;
            var r = this._bindingsByRootAndName,
                o = r[n],
                a = t[t.length - 1];
            e = e._cacheIndex, a._cacheIndex = e, t[e] = a, t.pop(), delete o[i];
            e: {
                for (var s in o) break e;delete r[n]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = this._nActiveBindings++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackBinding: function(e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = --this._nActiveBindings,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                i = e[t];
            return void 0 === i && ((i = new un(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants,
                i = e.__cacheIndex,
                n = --this._nActiveControlInterpolants,
                r = t[n];
            e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var i = t || this._root,
                n = i.uuid;
            e = null !== (i = "string" == typeof e ? wn.findByName(i, e) : e) ? i.uuid : e;
            var r = this._actionsByClip[e],
                o = null;
            if (void 0 !== r) {
                if (void 0 !== (o = r.actionByRoot[n])) return o;
                o = r.knownActions[0], null === i && (i = o._clip)
            }
            return null === i ? null : (t = new Rr(this, i, t), this._bindAction(t, o), this._addInactiveAction(t, e, n), t)
        },
        existingAction: function(e, t) {
            var i = t || this._root;
            return t = i.uuid, i = "string" == typeof e ? wn.findByName(i, e) : e, void 0 !== (e = this._actionsByClip[i ? i.uuid : e]) && e.actionByRoot[t] || null
        },
        stopAllAction: function() {
            for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r) e[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) t[a]._update(n, e, r, o);
            for (e = this._bindings, t = this._nActiveBindings, a = 0; a !== t; ++a) e[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions;
            e = e.uuid;
            var i = this._actionsByClip,
                n = i[e];
            if (void 0 !== n) {
                for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) {
                    var a = n[r];
                    this._deactivateAction(a);
                    var s = a._cacheIndex,
                        l = t[t.length - 1];
                    a._cacheIndex = null, a._byClipCacheIndex = null, l._cacheIndex = s, t[s] = l, t.pop(), this._removeInactiveBindingsForAction(a)
                }
                delete i[e]
            }
        },
        uncacheRoot: function(e) {
            e = e.uuid;
            var t = this._actionsByClip;
            for (n in t) {
                var i = t[n].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[e];
            if (void 0 !== n)
                for (var r in n)(e = n[r]).restoreOriginalState(), this._removeInactiveBinding(e)
        },
        uncacheAction: function(e, t) {
            null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e))
        }
    }), Ir.prototype.clone = function() {
        return new Ir(void 0 === this.value.clone ? this.value : this.value.clone())
    }, zr.prototype = Object.assign(Object.create(Dt.prototype), {
        constructor: zr,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return Dt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(Nr.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, i) {
            return Fr(e, this, i = i || [], t), i.sort(Br), i
        },
        intersectObjects: function(e, t, i) {
            if (i = i || [], !1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var n = 0, r = e.length; n < r; n++) Fr(e[n], this, i, t);
            return i.sort(Br), i
        }
    }), Object.assign(kr.prototype, {
        set: function(e, t, i) {
            return this.radius = e, this.phi = t, this.theta = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, i), this.phi = Math.acos(fo.clamp(t / this.radius, -1, 1))), this
        }
    }), Object.assign(Ur.prototype, {
        set: function(e, t, i) {
            return this.radius = e, this.theta = t, this.y = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
        }
    }), Object.assign(Hr.prototype, {
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new i;
            return function(t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new i), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new i), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new i;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(Gr.prototype, {
        set: function(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new r), e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new r), e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new r), this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function() {
            var e = new r,
                t = new r;
            return function(i, n) {
                return e.subVectors(i, this.start), t.subVectors(this.end, this.start), i = t.dot(t), i = t.dot(e) / i, n && (i = fo.clamp(i, 0, 1)), i
            }
        }(),
        closestPointToPoint: function(e, t, i) {
            return e = this.closestPointToPointParameter(e, t), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), jr.prototype = Object.create(T.prototype), jr.prototype.constructor = jr, jr.prototype.isImmediateRenderObject = !0, Vr.prototype = Object.create(Ut.prototype), Vr.prototype.constructor = Vr, Vr.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new o;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
                o = this.geometry.attributes.position,
                a = this.object.geometry;
            if (a && a.isGeometry)
                for (var s = a.vertices, l = a.faces, c = a = 0, h = l.length; c < h; c++)
                    for (var u = l[c], d = 0, p = u.vertexNormals.length; d < p; d++) {
                        var f = u.vertexNormals[d];
                        e.copy(s[u[n[d]]]).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(a, e.x, e.y, e.z), a += 1, o.setXYZ(a, t.x, t.y, t.z), a += 1
                    } else if (a && a.isBufferGeometry)
                        for (n = a.attributes.position, s = a.attributes.normal, d = a = 0, p = n.count; d < p; d++) e.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), t.set(s.getX(d), s.getY(d), s.getZ(d)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(a, e.x, e.y, e.z), a += 1, o.setXYZ(a, t.x, t.y, t.z), a += 1;
            o.needsUpdate = !0
        }
    }(), Wr.prototype = Object.create(T.prototype), Wr.prototype.constructor = Wr, Wr.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Wr.prototype.update = function() {
        var e = new r;
        return function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3,
                i = t * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(), Xr.prototype = Object.create(Ut.prototype), Xr.prototype.constructor = Xr, Xr.prototype.updateMatrixWorld = function() {
        var e = new r,
            t = new g,
            i = new g;
        return function(n) {
            var r = this.bones,
                o = this.geometry,
                a = o.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var s = 0, l = 0; s < r.length; s++) {
                var c = r[s];
                c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
            }
            o.getAttribute("position").needsUpdate = !0, T.prototype.updateMatrixWorld.call(this, n)
        }
    }(), Yr.prototype = Object.create(Z.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, Yr.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, Zr.prototype = Object.create(kt.prototype), Zr.prototype.constructor = Zr, Zr.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color,
                t = Math.max(e.r, e.g, e.b);
            1 < t && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
        }
    }, Zr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Jr.prototype = Object.create(T.prototype), Jr.prototype.constructor = Jr, Jr.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Jr.prototype.update = function() {
        var e = new r,
            t = new b,
            i = new b;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                t.copy(this.light.color), i.copy(this.light.groundColor);
                for (var o = 0, a = r.count; o < a; o++) {
                    var s = o < a / 2 ? t : i;
                    r.setXYZ(o, s.r, s.g, s.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(), Qr.prototype = Object.create(Z.prototype), Qr.prototype.constructor = Qr, Qr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, Qr.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
    }, $r.prototype = Object.assign(Object.create(Ut.prototype), {
        constructor: $r,
        copy: function(e) {
            return Ut.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Kr.prototype = Object.create(Ut.prototype), Kr.prototype.constructor = Kr, eo.prototype = Object.create(kt.prototype), eo.prototype.constructor = eo, eo.prototype.update = function() {
        function e(e, n, o, a) {
            for (o = (n - e) / o, p.setXYZ(h, 0, 0, 0), u++, t = e; t < n; t += o) i = h + u, p.setXYZ(i, Math.sin(t) * r, 0, Math.cos(t) * r), p.setXYZ(i + 1, Math.sin(Math.min(t + o, n)) * r, 0, Math.cos(Math.min(t + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), u += 3;
            d.addGroup(h, u, a), h += u, u = 0
        }
        var t, i, n = this.audio,
            r = this.range,
            o = this.divisionsInnerAngle,
            a = this.divisionsOuterAngle,
            s = fo.degToRad(n.panner.coneInnerAngle),
            l = s / 2,
            c = (n = fo.degToRad(n.panner.coneOuterAngle)) / 2,
            h = 0,
            u = 0,
            d = this.geometry,
            p = d.attributes.position;
        d.clearGroups(), e(-c, -l, a, 0), e(-l, l, o, 1), e(l, c, a, 0), p.needsUpdate = !0, s === n && (this.material[0].visible = !1)
    }, eo.prototype.dispose = function() {
        this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
    }, to.prototype = Object.create(Ut.prototype), to.prototype.constructor = to, to.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new o;
        return function() {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = 0, l = 0, c = (o = o.faces).length; l < c; l++) {
                var h = o[l],
                    u = h.normal;
                e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(n), t.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(s, e.x, e.y, e.z), s += 1, r.setXYZ(s, t.x, t.y, t.z), s += 1
            }
            r.needsUpdate = !0
        }
    }(), io.prototype = Object.create(T.prototype), io.prototype.constructor = io, io.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, io.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new r;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = i.length()
        }
    }(), no.prototype = Object.create(Ut.prototype), no.prototype.constructor = no, no.prototype.update = function() {
        function e(e, r, a, s) {
            if (n.set(r, a, s).unproject(o), void 0 !== (e = i[e]))
                for (r = t.getAttribute("position"), a = 0, s = e.length; a < s; a++) r.setXYZ(e[a], n.x, n.y, n.z)
        }
        var t, i, n = new r,
            o = new xt;
        return function() {
            t = this.geometry, i = this.pointMap, o.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        }
    }(), ro.prototype = Object.create(Ut.prototype), ro.prototype.constructor = ro, ro.prototype.update = function() {
        var e = new d;
        return function(t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                t = e.min;
                var i = e.max,
                    n = this.geometry.attributes.position,
                    r = n.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), ro.prototype.setFromObject = function(e) {
        return this.object = e, this.update(), this
    }, ro.prototype.copy = function(e) {
        return Ut.prototype.copy.call(this, e), this.object = e.object, this
    }, ro.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, oo.prototype = Object.create(Ut.prototype), oo.prototype.constructor = oo, oo.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), T.prototype.updateMatrixWorld.call(this, e))
    }, ao.prototype = Object.create(kt.prototype), ao.prototype.constructor = ao, ao.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), T.prototype.updateMatrixWorld.call(this, e)
    }, so.prototype = Object.create(T.prototype), so.prototype.constructor = so, so.prototype.setDirection = function() {
        var e, t = new r;
        return function(i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), so.prototype.setLength = function(e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, so.prototype.setColor = function(e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, so.prototype.copy = function(e) {
        return T.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }, so.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, lo.prototype = Object.create(Ut.prototype), lo.prototype.constructor = lo, Pn.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Pn.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Object.assign(qn.prototype, {
        createPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getPoints(e), this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getSpacedPoints(e), this.createGeometry(e)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new S, i = 0, n = e.length; i < n; i++) {
                var o = e[i];
                t.vertices.push(new r(o.x, o.y, o.z || 0))
            }
            return t
        }
    }), Object.assign(Xn.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), co.prototype = Object.create(zn.prototype), ho.prototype = Object.create(zn.prototype), uo.prototype = Object.create(zn.prototype), Object.assign(uo.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), $r.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Xr.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(mr.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ia.extractUrlBase(e)
        }
    }), Object.assign(hr.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(Hr.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(d.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Gr.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(fo, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), fo.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), fo.ceilPowerOfTwo(e)
        }
    }), Object.assign(o.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(g.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new r), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, i, n, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, o)
        }
    }), f.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, n.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(q.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(X.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(X, {
        barycoordFromPoint: function(e, t, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(e, t, i, n, r)
        },
        normal: function(e, t, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(e, t, i, n)
        }
    }), Object.assign(Yn.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pi(this, e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Gi(this, e)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(r.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(s.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(S.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(T.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(T.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(It.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Nt.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), zt.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Pn.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), wt.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Zn.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(A.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(k.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function(e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(k.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(Ri.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Ir.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(V.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new b
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        }
    }), Object.defineProperties(nn.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(W.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(St.prototype, {
        clearTarget: function(e, t, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
    }), Object.defineProperties(St.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(mt.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(h.prototype, {
        activeCubeFace: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }), Object.defineProperties(l.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(Mt.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), Tr.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new gr).load(e, (function(e) {
            t.setBuffer(e)
        })), this
    }, Ar.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, _r.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    }, go.crossOrigin = void 0, go.loadTexture = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new Dn;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, go.loadTextureCube = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Ln;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, go.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, go.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }, e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AmbientLight = rr, e.AmbientLightProbe = xr, e.AnimationClip = wn, e.AnimationLoader = Tn, e.AnimationMixer = Or, e.AnimationObjectGroup = Pr, e.AnimationUtils = Xo, e.ArcCurve = On, e.ArrayCamera = _t, e.ArrowHelper = so, e.Audio = Tr, e.AudioAnalyser = Ar, e.AudioContext = ha, e.AudioListener = Mr, e.AudioLoader = gr, e.AxesHelper = lo, e.AxisHelper = function(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new lo(e)
    }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new An(e)
    }, e.Bone = Bt, e.BooleanKeyframeTrack = fn, e.BoundingBoxHelper = function(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ro(e, t)
    }, e.Box2 = Hr, e.Box3 = d, e.Box3Helper = oo, e.BoxBufferGeometry = H, e.BoxGeometry = U, e.BoxHelper = ro, e.BufferAttribute = A, e.BufferGeometry = k, e.BufferGeometryLoader = cr, e.ByteType = 1010, e.Cache = Yo, e.Camera = xt, e.CameraHelper = no, e.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed")
    }, e.CanvasTexture = qt, e.CatmullRomCurve3 = zn, e.CineonToneMapping = 4, e.CircleBufferGeometry = Qi, e.CircleGeometry = Ji, e.ClampToEdgeWrapping = 1001, e.Clock = Er, e.ClosedSplineCurve3 = co, e.Color = b, e.ColorKeyframeTrack = mn, e.CompressedTexture = Wt, e.CompressedTextureLoader = Sn, e.ConeBufferGeometry = Zi, e.ConeGeometry = Yi, e.CubeCamera = _r, e.CubeGeometry = U, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.CubeTexture = se, e.CubeTextureLoader = Ln, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = kn, e.CubicBezierCurve3 = Un, e.CubicInterpolant = hn, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Pn, e.CurvePath = qn, e.CustomBlending = 5, e.CylinderBufferGeometry = Xi, e.CylinderGeometry = qi, e.Cylindrical = Ur, e.DataTexture = u, e.DataTexture2DArray = le, e.DataTexture3D = ce, e.DataTextureLoader = An, e.DefaultLoadingManager = Zo, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.DepthTexture = Xt, e.DirectionalLight = nr, e.DirectionalLightHelper = io, e.DirectionalLightShadow = ir, e.DiscreteInterpolant = dn, e.DodecahedronBufferGeometry = ai, e.DodecahedronGeometry = oi, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(e, t).setDynamic(!0)
    }, e.EdgesGeometry = Wi, e.EdgesHelper = function(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ut(new Wi(e.geometry), new Ft({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.EllipseCurve = Rn, e.EqualDepth = 4, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.Euler = E, e.EventDispatcher = t, e.ExtrudeBufferGeometry = Ri, e.ExtrudeGeometry = Pi, e.Face3 = _, e.Face4 = function(e, t, i, n, r, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new _(e, t, i, r, o, a)
    }, e.FaceColors = 1, e.FaceNormalsHelper = to, e.FileLoader = Mn, e.FlatShading = 1, e.Float32Attribute = function(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new z(e, t)
    }, e.Float32BufferAttribute = z, e.Float64Attribute = function(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new N(e, t)
    }, e.Float64BufferAttribute = N, e.FloatType = 1015, e.Fog = Ct, e.FogExp2 = At, e.Font = pr, e.FontLoader = fr, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = 0, e.Frustum = m, e.GammaEncoding = 3007, e.Geometry = S, e.GeometryUtils = {
        merge: function(e, t, i) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh) {
                t.matrixAutoUpdate && t.updateMatrix();
                var n = t.matrix;
                t = t.geometry
            }
            e.merge(t, n, i)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    }, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GridHelper = $r, e.Group = bt, e.HalfFloatType = 1016, e.HemisphereLight = Jn, e.HemisphereLightHelper = Jr, e.HemisphereLightProbe = br, e.IcosahedronBufferGeometry = ri, e.IcosahedronGeometry = ni, e.ImageBitmapLoader = ur, e.ImageLoader = Cn, e.ImageUtils = go, e.ImmediateRenderObject = jr, e.InstancedBufferAttribute = lr, e.InstancedBufferGeometry = sr, e.InstancedInterleavedBuffer = zr, e.Int16Attribute = function(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new P(e, t)
    }, e.Int16BufferAttribute = P, e.Int32Attribute = function(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new O(e, t)
    }, e.Int32BufferAttribute = O, e.Int8Attribute = function(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new C(e, t)
    }, e.Int8BufferAttribute = C, e.IntType = 1013, e.InterleavedBuffer = Dt, e.InterleavedBufferAttribute = Pt, e.Interpolant = cn, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.")
    }, e.KeyframeTrack = pn, e.LOD = It, e.LatheBufferGeometry = Hi, e.LatheGeometry = Ui, e.Layers = M, e.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }, e.LessDepth = 2, e.LessEqualDepth = 3, e.Light = Zn, e.LightProbe = yr, e.LightProbeHelper = Qr, e.LightShadow = Qn, e.Line = kt, e.Line3 = Gr, e.LineBasicMaterial = Ft, e.LineCurve = Hn, e.LineCurve3 = Gn, e.LineDashedMaterial = ln, e.LineLoop = Ht, e.LinePieces = 1, e.LineSegments = Ut, e.LineStrip = 0, e.LinearEncoding = 3e3, e.LinearFilter = 1006, e.LinearInterpolant = un, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearToneMapping = 1, e.Loader = mr, e.LoaderUtils = ia, e.LoadingManager = En, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, e.Material = V, e.MaterialLoader = ar, e.Math = fo, e.Matrix3 = o, e.Matrix4 = g, e.MaxEquation = 104, e.Mesh = Z, e.MeshBasicMaterial = Y, e.MeshDepthMaterial = pt, e.MeshDistanceMaterial = ft, e.MeshFaceMaterial = function(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, e.MeshLambertMaterial = an, e.MeshMatcapMaterial = sn, e.MeshNormalMaterial = on, e.MeshPhongMaterial = nn, e.MeshPhysicalMaterial = tn, e.MeshStandardMaterial = en, e.MeshToonMaterial = rn, e.MinEquation = 103, e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMaterial = function(e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
            return e.slice()
        }, e
    }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NeverDepth = 0, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NumberKeyframeTrack = gn, e.Object3D = T, e.ObjectLoader = hr, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = ii, e.OctahedronGeometry = ti, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = tr, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.ParametricBufferGeometry = Jt, e.ParametricGeometry = Zt, e.Particle = function(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ot(e)
    }, e.ParticleBasicMaterial = function(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.ParticleSystem = function(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new jt(e, t)
    }, e.ParticleSystemMaterial = function(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.Path = Xn, e.PerspectiveCamera = wt, e.Plane = f, e.PlaneBufferGeometry = j, e.PlaneGeometry = G, e.PlaneHelper = ao, e.PointCloud = function(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new jt(e, t)
    }, e.PointCloudMaterial = function(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.PointLight = er, e.PointLightHelper = Yr, e.Points = jt, e.PointsMaterial = Gt, e.PolarGridHelper = Kr, e.PolyhedronBufferGeometry = $t, e.PolyhedronGeometry = Qt, e.PositionalAudio = Sr, e.PositionalAudioHelper = eo, e.PropertyBinding = Dr, e.PropertyMixer = Cr, e.QuadraticBezierCurve = jn, e.QuadraticBezierCurve3 = Vn, e.Quaternion = n, e.QuaternionKeyframeTrack = yn, e.QuaternionLinearInterpolant = vn, e.REVISION = "105", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, e.RGB_S3TC_DXT1_Format = 33776, e.RawShaderMaterial = Ki, e.Ray = q, e.Raycaster = Nr, e.RectAreaLight = or, e.RectAreaLightHelper = Zr, e.RedFormat = 1028, e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = ki, e.RingGeometry = Fi, e.Scene = Lt, e.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    }, e.ShaderChunk = yo, e.ShaderLib = _o, e.ShaderMaterial = W, e.ShadowMaterial = $i, e.Shape = Yn, e.ShapeBufferGeometry = ji, e.ShapeGeometry = Gi, e.ShapePath = dr, e.ShapeUtils = jo, e.ShortType = 1011, e.Skeleton = Nt, e.SkeletonHelper = Xr, e.SkinnedMesh = zt, e.SmoothShading = 2, e.Sphere = p, e.SphereBufferGeometry = Bi, e.SphereGeometry = Ni, e.Spherical = kr, e.SphericalHarmonics3 = vr, e.SphericalReflectionMapping = 305, e.Spline = uo, e.SplineCurve = Wn, e.SplineCurve3 = ho, e.SpotLight = Kn, e.SpotLightHelper = Wr, e.SpotLightShadow = $n, e.Sprite = Ot, e.SpriteMaterial = Rt, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StereoCamera = wr, e.StringKeyframeTrack = bn, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = ei, e.TetrahedronGeometry = Kt, e.TextBufferGeometry = zi, e.TextGeometry = Ii, e.Texture = a, e.TextureLoader = Dn, e.TorusBufferGeometry = di, e.TorusGeometry = ui, e.TorusKnotBufferGeometry = hi, e.TorusKnotGeometry = ci, e.Triangle = X, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = li, e.TubeGeometry = si, e.UVMapping = 300, e.Uint16Attribute = function(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new R(e, t)
    }, e.Uint16BufferAttribute = R, e.Uint32Attribute = function(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new I(e, t)
    }, e.Uint32BufferAttribute = I, e.Uint8Attribute = function(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new L(e, t)
    }, e.Uint8BufferAttribute = L, e.Uint8ClampedAttribute = function(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new D(e, t)
    }, e.Uint8ClampedBufferAttribute = D, e.Uncharted2ToneMapping = 3, e.Uniform = Ir, e.UniformsLib = wo, e.UniformsUtils = bo, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.Vector2 = i, e.Vector3 = r, e.Vector4 = s, e.VectorKeyframeTrack = xn, e.Vertex = function(e, t, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(e, t, i)
    }, e.VertexColors = 2, e.VertexNormalsHelper = Vr, e.VideoTexture = Vt, e.WebGLMultisampleRenderTarget = c, e.WebGLRenderTarget = l, e.WebGLRenderTargetCube = h, e.WebGLRenderer = St, e.WebGLUtils = yt, e.WireframeGeometry = Yt, e.WireframeHelper = function(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ut(new Yt(e.geometry), new Ft({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Mn(e)
    }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", {
        value: !0
    })
})),
function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t()
}(this, (function() {
    "use strict";

    function e(e, t) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
        }
    }

    function t(t, i, n) {
        return i && e(t.prototype, i), n && e(t, n), t
    }

    function i() {
        return (i = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var i = arguments[t];
                for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
            }
            return e
        }).apply(this, arguments)
    }

    function n(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }
    var r, o, a = function(e) {
            do {
                e += Math.floor(1e6 * Math.random())
            } while (document.getElementById(e));
            return e
        },
        s = function(e) {
            var t = e.getAttribute("data-bs-target");
            if (!t || "#" === t) {
                var i = e.getAttribute("href");
                t = i && "#" !== i ? i.trim() : null
            }
            return t
        },
        l = function(e) {
            var t = s(e);
            return t && document.querySelector(t) ? t : null
        },
        c = function(e) {
            var t = s(e);
            return t ? document.querySelector(t) : null
        },
        h = function(e) {
            if (!e) return 0;
            var t = window.getComputedStyle(e),
                i = t.transitionDuration,
                n = t.transitionDelay,
                r = Number.parseFloat(i),
                o = Number.parseFloat(n);
            return r || o ? (i = i.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(i) + Number.parseFloat(n))) : 0
        },
        u = function(e) {
            e.dispatchEvent(new Event("transitionend"))
        },
        d = function(e) {
            return (e[0] || e).nodeType
        },
        p = function(e, t) {
            var i = !1,
                n = t + 5;
            e.addEventListener("transitionend", (function t() {
                i = !0, e.removeEventListener("transitionend", t)
            })), setTimeout((function() {
                i || u(e)
            }), n)
        },
        f = function(e, t, i) {
            Object.keys(i).forEach((function(n) {
                var r, o = i[n],
                    a = t[n],
                    s = a && d(a) ? "element" : null == (r = a) ? "" + r : {}.toString.call(r).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(o).test(s)) throw new Error(e.toUpperCase() + ': Option "' + n + '" provided type "' + s + '" but expected type "' + o + '".')
            }))
        },
        m = function(e) {
            if (!e) return !1;
            if (e.style && e.parentNode && e.parentNode.style) {
                var t = getComputedStyle(e),
                    i = getComputedStyle(e.parentNode);
                return "none" !== t.display && "none" !== i.display && "hidden" !== t.visibility
            }
            return !1
        },
        g = function() {
            return function() {}
        },
        v = function(e) {
            return e.offsetHeight
        },
        y = function() {
            var e = window.jQuery;
            return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null
        },
        b = function(e) {
            "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", e) : e()
        },
        x = "rtl" === document.documentElement.dir,
        w = (r = {}, o = 1, {
            set: function(e, t, i) {
                void 0 === e.bsKey && (e.bsKey = {
                    key: t,
                    id: o
                }, o++), r[e.bsKey.id] = i
            },
            get: function(e, t) {
                if (!e || void 0 === e.bsKey) return null;
                var i = e.bsKey;
                return i.key === t ? r[i.id] : null
            },
            delete: function(e, t) {
                if (void 0 !== e.bsKey) {
                    var i = e.bsKey;
                    i.key === t && (delete r[i.id], delete e.bsKey)
                }
            }
        }),
        _ = function(e, t, i) {
            w.set(e, t, i)
        },
        E = function(e, t) {
            return w.get(e, t)
        },
        M = /[^.]*(?=\..*)\.|.*/,
        T = /\..*/,
        S = /::\d+$/,
        A = {},
        C = 1,
        L = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        },
        D = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function P(e, t) {
        return t && t + "::" + C++ || e.uidEvent || C++
    }

    function R(e) {
        var t = P(e);
        return e.uidEvent = t, A[t] = A[t] || {}, A[t]
    }

    function O(e, t, i) {
        void 0 === i && (i = null);
        for (var n = Object.keys(e), r = 0, o = n.length; r < o; r++) {
            var a = e[n[r]];
            if (a.originalHandler === t && a.delegationSelector === i) return a
        }
        return null
    }

    function I(e, t, i) {
        var n = "string" == typeof t,
            r = n ? i : t,
            o = e.replace(T, ""),
            a = L[o];
        return a && (o = a), D.has(o) || (o = e), [n, r, o]
    }

    function z(e, t, i, n, r) {
        if ("string" == typeof t && e) {
            i || (i = n, n = null);
            var o = I(t, i, n),
                a = o[0],
                s = o[1],
                l = o[2],
                c = R(e),
                h = c[l] || (c[l] = {}),
                u = O(h, s, a ? i : null);
            if (u) u.oneOff = u.oneOff && r;
            else {
                var d = P(s, t.replace(M, "")),
                    p = a ? function(e, t, i) {
                        return function n(r) {
                            for (var o = e.querySelectorAll(t), a = r.target; a && a !== this; a = a.parentNode)
                                for (var s = o.length; s--;)
                                    if (o[s] === a) return r.delegateTarget = a, n.oneOff && B.off(e, r.type, i), i.apply(a, [r]);
                            return null
                        }
                    }(e, i, n) : function(e, t) {
                        return function i(n) {
                            return n.delegateTarget = e, i.oneOff && B.off(e, n.type, t), t.apply(e, [n])
                        }
                    }(e, i);
                p.delegationSelector = a ? i : null, p.originalHandler = s, p.oneOff = r, p.uidEvent = d, h[d] = p, e.addEventListener(l, p, a)
            }
        }
    }

    function N(e, t, i, n, r) {
        var o = O(t[i], n, r);
        o && (e.removeEventListener(i, o, Boolean(r)), delete t[i][o.uidEvent])
    }
    var B = {
            on: function(e, t, i, n) {
                z(e, t, i, n, !1)
            },
            one: function(e, t, i, n) {
                z(e, t, i, n, !0)
            },
            off: function(e, t, i, n) {
                if ("string" == typeof t && e) {
                    var r = I(t, i, n),
                        o = r[0],
                        a = r[1],
                        s = r[2],
                        l = s !== t,
                        c = R(e),
                        h = t.startsWith(".");
                    if (void 0 === a) {
                        h && Object.keys(c).forEach((function(i) {
                            ! function(e, t, i, n) {
                                var r = t[i] || {};
                                Object.keys(r).forEach((function(o) {
                                    if (o.includes(n)) {
                                        var a = r[o];
                                        N(e, t, i, a.originalHandler, a.delegationSelector)
                                    }
                                }))
                            }(e, c, i, t.slice(1))
                        }));
                        var u = c[s] || {};
                        Object.keys(u).forEach((function(i) {
                            var n = i.replace(S, "");
                            if (!l || t.includes(n)) {
                                var r = u[i];
                                N(e, c, s, r.originalHandler, r.delegationSelector)
                            }
                        }))
                    } else {
                        if (!c || !c[s]) return;
                        N(e, c, s, a, o ? i : null)
                    }
                }
            },
            trigger: function(e, t, i) {
                if ("string" != typeof t || !e) return null;
                var n, r = y(),
                    o = t.replace(T, ""),
                    a = t !== o,
                    s = D.has(o),
                    l = !0,
                    c = !0,
                    h = !1,
                    u = null;
                return a && r && (n = r.Event(t, i), r(e).trigger(n), l = !n.isPropagationStopped(), c = !n.isImmediatePropagationStopped(), h = n.isDefaultPrevented()), s ? (u = document.createEvent("HTMLEvents")).initEvent(o, l, !0) : u = new CustomEvent(t, {
                    bubbles: l,
                    cancelable: !0
                }), void 0 !== i && Object.keys(i).forEach((function(e) {
                    Object.defineProperty(u, e, {
                        get: function() {
                            return i[e]
                        }
                    })
                })), h && u.preventDefault(), c && e.dispatchEvent(u), u.defaultPrevented && void 0 !== n && n.preventDefault(), u
            }
        },
        F = function() {
            function e(e) {
                e && (this._element = e, _(e, this.constructor.DATA_KEY, this))
            }
            return e.prototype.dispose = function() {
                (function(e, t) {
                    w.delete(e, t)
                })(this._element, this.constructor.DATA_KEY), this._element = null
            }, e.getInstance = function(e) {
                return E(e, this.DATA_KEY)
            }, t(e, null, [{
                key: "VERSION",
                get: function() {
                    return "5.0.0-beta1"
                }
            }]), e
        }(),
        k = "alert",
        U = function(e) {
            function i() {
                return e.apply(this, arguments) || this
            }
            n(i, e);
            var r = i.prototype;
            return r.close = function(e) {
                var t = e ? this._getRootElement(e) : this._element,
                    i = this._triggerCloseEvent(t);
                null === i || i.defaultPrevented || this._removeElement(t)
            }, r._getRootElement = function(e) {
                return c(e) || e.closest(".alert")
            }, r._triggerCloseEvent = function(e) {
                return B.trigger(e, "close.bs.alert")
            }, r._removeElement = function(e) {
                var t = this;
                if (e.classList.remove("show"), e.classList.contains("fade")) {
                    var i = h(e);
                    B.one(e, "transitionend", (function() {
                        return t._destroyElement(e)
                    })), p(e, i)
                } else this._destroyElement(e)
            }, r._destroyElement = function(e) {
                e.parentNode && e.parentNode.removeChild(e), B.trigger(e, "closed.bs.alert")
            }, i.jQueryInterface = function(e) {
                return this.each((function() {
                    var t = E(this, "bs.alert");
                    t || (t = new i(this)), "close" === e && t[e](this)
                }))
            }, i.handleDismiss = function(e) {
                return function(t) {
                    t && t.preventDefault(), e.close(this)
                }
            }, t(i, null, [{
                key: "DATA_KEY",
                get: function() {
                    return "bs.alert"
                }
            }]), i
        }(F);
    B.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', U.handleDismiss(new U)), b((function() {
        var e = y();
        if (e) {
            var t = e.fn[k];
            e.fn[k] = U.jQueryInterface, e.fn[k].Constructor = U, e.fn[k].noConflict = function() {
                return e.fn[k] = t, U.jQueryInterface
            }
        }
    }));
    var H = function(e) {
        function i() {
            return e.apply(this, arguments) || this
        }
        return n(i, e), i.prototype.toggle = function() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }, i.jQueryInterface = function(e) {
            return this.each((function() {
                var t = E(this, "bs.button");
                t || (t = new i(this)), "toggle" === e && t[e]()
            }))
        }, t(i, null, [{
            key: "DATA_KEY",
            get: function() {
                return "bs.button"
            }
        }]), i
    }(F);

    function G(e) {
        return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e)
    }

    function j(e) {
        return e.replace(/[A-Z]/g, (function(e) {
            return "-" + e.toLowerCase()
        }))
    }
    B.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (function(e) {
        e.preventDefault();
        var t = e.target.closest('[data-bs-toggle="button"]'),
            i = E(t, "bs.button");
        i || (i = new H(t)), i.toggle()
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn.button;
            e.fn.button = H.jQueryInterface, e.fn.button.Constructor = H, e.fn.button.noConflict = function() {
                return e.fn.button = t, H.jQueryInterface
            }
        }
    }));
    var V = {
            setDataAttribute: function(e, t, i) {
                e.setAttribute("data-bs-" + j(t), i)
            },
            removeDataAttribute: function(e, t) {
                e.removeAttribute("data-bs-" + j(t))
            },
            getDataAttributes: function(e) {
                if (!e) return {};
                var t = {};
                return Object.keys(e.dataset).filter((function(e) {
                    return e.startsWith("bs")
                })).forEach((function(i) {
                    var n = i.replace(/^bs/, "");
                    n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = G(e.dataset[i])
                })), t
            },
            getDataAttribute: function(e, t) {
                return G(e.getAttribute("data-bs-" + j(t)))
            },
            offset: function(e) {
                var t = e.getBoundingClientRect();
                return {
                    top: t.top + document.body.scrollTop,
                    left: t.left + document.body.scrollLeft
                }
            },
            position: function(e) {
                return {
                    top: e.offsetTop,
                    left: e.offsetLeft
                }
            }
        },
        W = {
            matches: function(e, t) {
                return e.matches(t)
            },
            find: function(e, t) {
                var i;
                return void 0 === t && (t = document.documentElement), (i = []).concat.apply(i, Element.prototype.querySelectorAll.call(t, e))
            },
            findOne: function(e, t) {
                return void 0 === t && (t = document.documentElement), Element.prototype.querySelector.call(t, e)
            },
            children: function(e, t) {
                var i;
                return (i = []).concat.apply(i, e.children).filter((function(e) {
                    return e.matches(t)
                }))
            },
            parents: function(e, t) {
                for (var i = [], n = e.parentNode; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) this.matches(n, t) && i.push(n), n = n.parentNode;
                return i
            },
            prev: function(e, t) {
                for (var i = e.previousElementSibling; i;) {
                    if (i.matches(t)) return [i];
                    i = i.previousElementSibling
                }
                return []
            },
            next: function(e, t) {
                for (var i = e.nextElementSibling; i;) {
                    if (this.matches(i, t)) return [i];
                    i = i.nextElementSibling
                }
                return []
            }
        },
        q = "carousel",
        X = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: "hover",
            wrap: !0,
            touch: !0
        },
        Y = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        },
        Z = {
            TOUCH: "touch",
            PEN: "pen"
        },
        J = function(e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._items = null, n._interval = null, n._activeElement = null, n._isPaused = !1, n._isSliding = !1, n.touchTimeout = null, n.touchStartX = 0, n.touchDeltaX = 0, n._config = n._getConfig(i), n._indicatorsElement = W.findOne(".carousel-indicators", n._element), n._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, n._pointerEvent = Boolean(window.PointerEvent), n._addEventListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.next = function() {
                this._isSliding || this._slide("next")
            }, o.nextWhenVisible = function() {
                !document.hidden && m(this._element) && this.next()
            }, o.prev = function() {
                this._isSliding || this._slide("prev")
            }, o.pause = function(e) {
                e || (this._isPaused = !0), W.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (u(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
            }, o.cycle = function(e) {
                e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
            }, o.to = function(e) {
                var t = this;
                this._activeElement = W.findOne(".active.carousel-item", this._element);
                var i = this._getItemIndex(this._activeElement);
                if (!(e > this._items.length - 1 || e < 0))
                    if (this._isSliding) B.one(this._element, "slid.bs.carousel", (function() {
                        return t.to(e)
                    }));
                    else {
                        if (i === e) return this.pause(), void this.cycle();
                        var n = e > i ? "next" : "prev";
                        this._slide(n, this._items[e])
                    }
            }, o.dispose = function() {
                e.prototype.dispose.call(this), B.off(this._element, ".bs.carousel"), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
            }, o._getConfig = function(e) {
                return e = i({}, X, e), f(q, e, Y), e
            }, o._handleSwipe = function() {
                var e = Math.abs(this.touchDeltaX);
                if (!(e <= 40)) {
                    var t = e / this.touchDeltaX;
                    this.touchDeltaX = 0, t > 0 && this.prev(), t < 0 && this.next()
                }
            }, o._addEventListeners = function() {
                var e = this;
                this._config.keyboard && B.on(this._element, "keydown.bs.carousel", (function(t) {
                    return e._keydown(t)
                })), "hover" === this._config.pause && (B.on(this._element, "mouseenter.bs.carousel", (function(t) {
                    return e.pause(t)
                })), B.on(this._element, "mouseleave.bs.carousel", (function(t) {
                    return e.cycle(t)
                }))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
            }, o._addTouchEventListeners = function() {
                var e = this,
                    t = function(t) {
                        e._pointerEvent && Z[t.pointerType.toUpperCase()] ? e.touchStartX = t.clientX : e._pointerEvent || (e.touchStartX = t.touches[0].clientX)
                    },
                    i = function(t) {
                        e._pointerEvent && Z[t.pointerType.toUpperCase()] && (e.touchDeltaX = t.clientX - e.touchStartX), e._handleSwipe(), "hover" === e._config.pause && (e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout((function(t) {
                            return e.cycle(t)
                        }), 500 + e._config.interval))
                    };
                W.find(".carousel-item img", this._element).forEach((function(e) {
                    B.on(e, "dragstart.bs.carousel", (function(e) {
                        return e.preventDefault()
                    }))
                })), this._pointerEvent ? (B.on(this._element, "pointerdown.bs.carousel", (function(e) {
                    return t(e)
                })), B.on(this._element, "pointerup.bs.carousel", (function(e) {
                    return i(e)
                })), this._element.classList.add("pointer-event")) : (B.on(this._element, "touchstart.bs.carousel", (function(e) {
                    return t(e)
                })), B.on(this._element, "touchmove.bs.carousel", (function(t) {
                    return function(t) {
                        t.touches && t.touches.length > 1 ? e.touchDeltaX = 0 : e.touchDeltaX = t.touches[0].clientX - e.touchStartX
                    }(t)
                })), B.on(this._element, "touchend.bs.carousel", (function(e) {
                    return i(e)
                })))
            }, o._keydown = function(e) {
                if (!/input|textarea/i.test(e.target.tagName)) switch (e.key) {
                    case "ArrowLeft":
                        e.preventDefault(), this.prev();
                        break;
                    case "ArrowRight":
                        e.preventDefault(), this.next()
                }
            }, o._getItemIndex = function(e) {
                return this._items = e && e.parentNode ? W.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e)
            }, o._getItemByDirection = function(e, t) {
                var i = "next" === e,
                    n = "prev" === e,
                    r = this._getItemIndex(t),
                    o = this._items.length - 1;
                if ((n && 0 === r || i && r === o) && !this._config.wrap) return t;
                var a = (r + ("prev" === e ? -1 : 1)) % this._items.length;
                return -1 === a ? this._items[this._items.length - 1] : this._items[a]
            }, o._triggerSlideEvent = function(e, t) {
                var i = this._getItemIndex(e),
                    n = this._getItemIndex(W.findOne(".active.carousel-item", this._element));
                return B.trigger(this._element, "slide.bs.carousel", {
                    relatedTarget: e,
                    direction: t,
                    from: n,
                    to: i
                })
            }, o._setActiveIndicatorElement = function(e) {
                if (this._indicatorsElement) {
                    for (var t = W.find(".active", this._indicatorsElement), i = 0; i < t.length; i++) t[i].classList.remove("active");
                    var n = this._indicatorsElement.children[this._getItemIndex(e)];
                    n && n.classList.add("active")
                }
            }, o._updateInterval = function() {
                var e = this._activeElement || W.findOne(".active.carousel-item", this._element);
                if (e) {
                    var t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
                    t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval
                }
            }, o._slide = function(e, t) {
                var i, n, r, o = this,
                    a = W.findOne(".active.carousel-item", this._element),
                    s = this._getItemIndex(a),
                    l = t || a && this._getItemByDirection(e, a),
                    c = this._getItemIndex(l),
                    u = Boolean(this._interval);
                if ("next" === e ? (i = "carousel-item-start", n = "carousel-item-next", r = "left") : (i = "carousel-item-end", n = "carousel-item-prev", r = "right"), l && l.classList.contains("active")) this._isSliding = !1;
                else if (!this._triggerSlideEvent(l, r).defaultPrevented && a && l) {
                    if (this._isSliding = !0, u && this.pause(), this._setActiveIndicatorElement(l), this._activeElement = l, this._element.classList.contains("slide")) {
                        l.classList.add(n), v(l), a.classList.add(i), l.classList.add(i);
                        var d = h(a);
                        B.one(a, "transitionend", (function() {
                            l.classList.remove(i, n), l.classList.add("active"), a.classList.remove("active", n, i), o._isSliding = !1, setTimeout((function() {
                                B.trigger(o._element, "slid.bs.carousel", {
                                    relatedTarget: l,
                                    direction: r,
                                    from: s,
                                    to: c
                                })
                            }), 0)
                        })), p(a, d)
                    } else a.classList.remove("active"), l.classList.add("active"), this._isSliding = !1, B.trigger(this._element, "slid.bs.carousel", {
                        relatedTarget: l,
                        direction: r,
                        from: s,
                        to: c
                    });
                    u && this.cycle()
                }
            }, r.carouselInterface = function(e, t) {
                var n = E(e, "bs.carousel"),
                    o = i({}, X, V.getDataAttributes(e));
                "object" == typeof t && (o = i({}, o, t));
                var a = "string" == typeof t ? t : o.slide;
                if (n || (n = new r(e, o)), "number" == typeof t) n.to(t);
                else if ("string" == typeof a) {
                    if (void 0 === n[a]) throw new TypeError('No method named "' + a + '"');
                    n[a]()
                } else o.interval && o.ride && (n.pause(), n.cycle())
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    r.carouselInterface(this, e)
                }))
            }, r.dataApiClickHandler = function(e) {
                var t = c(this);
                if (t && t.classList.contains("carousel")) {
                    var n = i({}, V.getDataAttributes(t), V.getDataAttributes(this)),
                        o = this.getAttribute("data-bs-slide-to");
                    o && (n.interval = !1), r.carouselInterface(t, n), o && E(t, "bs.carousel").to(o), e.preventDefault()
                }
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return X
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.carousel"
                }
            }]), r
        }(F);
    B.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", J.dataApiClickHandler), B.on(window, "load.bs.carousel.data-api", (function() {
        for (var e = W.find('[data-bs-ride="carousel"]'), t = 0, i = e.length; t < i; t++) J.carouselInterface(e[t], E(e[t], "bs.carousel"))
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn[q];
            e.fn[q] = J.jQueryInterface, e.fn[q].Constructor = J, e.fn[q].noConflict = function() {
                return e.fn[q] = t, J.jQueryInterface
            }
        }
    }));
    var Q = "collapse",
        $ = {
            toggle: !0,
            parent: ""
        },
        K = {
            toggle: "boolean",
            parent: "(string|element)"
        },
        ee = function(e) {
            function r(t, i) {
                var n;
                (n = e.call(this, t) || this)._isTransitioning = !1, n._config = n._getConfig(i), n._triggerArray = W.find('[data-bs-toggle="collapse"][href="#' + t.id + '"],[data-bs-toggle="collapse"][data-bs-target="#' + t.id + '"]');
                for (var r = W.find('[data-bs-toggle="collapse"]'), o = 0, a = r.length; o < a; o++) {
                    var s = r[o],
                        c = l(s),
                        h = W.find(c).filter((function(e) {
                            return e === t
                        }));
                    null !== c && h.length && (n._selector = c, n._triggerArray.push(s))
                }
                return n._parent = n._config.parent ? n._getParent() : null, n._config.parent || n._addAriaAndCollapsedClass(n._element, n._triggerArray), n._config.toggle && n.toggle(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function() {
                this._element.classList.contains("show") ? this.hide() : this.show()
            }, o.show = function() {
                var e = this;
                if (!this._isTransitioning && !this._element.classList.contains("show")) {
                    var t, i;
                    this._parent && 0 === (t = W.find(".show, .collapsing", this._parent).filter((function(t) {
                        return "string" == typeof e._config.parent ? t.getAttribute("data-bs-parent") === e._config.parent : t.classList.contains("collapse")
                    }))).length && (t = null);
                    var n = W.findOne(this._selector);
                    if (t) {
                        var o = t.find((function(e) {
                            return n !== e
                        }));
                        if ((i = o ? E(o, "bs.collapse") : null) && i._isTransitioning) return
                    }
                    if (!B.trigger(this._element, "show.bs.collapse").defaultPrevented) {
                        t && t.forEach((function(e) {
                            n !== e && r.collapseInterface(e, "hide"), i || _(e, "bs.collapse", null)
                        }));
                        var a = this._getDimension();
                        this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[a] = 0, this._triggerArray.length && this._triggerArray.forEach((function(e) {
                            e.classList.remove("collapsed"), e.setAttribute("aria-expanded", !0)
                        })), this.setTransitioning(!0);
                        var s = "scroll" + (a[0].toUpperCase() + a.slice(1)),
                            l = h(this._element);
                        B.one(this._element, "transitionend", (function() {
                            e._element.classList.remove("collapsing"), e._element.classList.add("collapse", "show"), e._element.style[a] = "", e.setTransitioning(!1), B.trigger(e._element, "shown.bs.collapse")
                        })), p(this._element, l), this._element.style[a] = this._element[s] + "px"
                    }
                }
            }, o.hide = function() {
                var e = this;
                if (!this._isTransitioning && this._element.classList.contains("show") && !B.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
                    var t = this._getDimension();
                    this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", v(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
                    var i = this._triggerArray.length;
                    if (i > 0)
                        for (var n = 0; n < i; n++) {
                            var r = this._triggerArray[n],
                                o = c(r);
                            o && !o.classList.contains("show") && (r.classList.add("collapsed"), r.setAttribute("aria-expanded", !1))
                        }
                    this.setTransitioning(!0), this._element.style[t] = "";
                    var a = h(this._element);
                    B.one(this._element, "transitionend", (function() {
                        e.setTransitioning(!1), e._element.classList.remove("collapsing"), e._element.classList.add("collapse"), B.trigger(e._element, "hidden.bs.collapse")
                    })), p(this._element, a)
                }
            }, o.setTransitioning = function(e) {
                this._isTransitioning = e
            }, o.dispose = function() {
                e.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null
            }, o._getConfig = function(e) {
                return (e = i({}, $, e)).toggle = Boolean(e.toggle), f(Q, e, K), e
            }, o._getDimension = function() {
                return this._element.classList.contains("width") ? "width" : "height"
            }, o._getParent = function() {
                var e = this,
                    t = this._config.parent;
                d(t) ? void 0 === t.jquery && void 0 === t[0] || (t = t[0]) : t = W.findOne(t);
                var i = '[data-bs-toggle="collapse"][data-bs-parent="' + t + '"]';
                return W.find(i, t).forEach((function(t) {
                    var i = c(t);
                    e._addAriaAndCollapsedClass(i, [t])
                })), t
            }, o._addAriaAndCollapsedClass = function(e, t) {
                if (e && t.length) {
                    var i = e.classList.contains("show");
                    t.forEach((function(e) {
                        i ? e.classList.remove("collapsed") : e.classList.add("collapsed"), e.setAttribute("aria-expanded", i)
                    }))
                }
            }, r.collapseInterface = function(e, t) {
                var n = E(e, "bs.collapse"),
                    o = i({}, $, V.getDataAttributes(e), "object" == typeof t && t ? t : {});
                if (!n && o.toggle && "string" == typeof t && /show|hide/.test(t) && (o.toggle = !1), n || (n = new r(e, o)), "string" == typeof t) {
                    if (void 0 === n[t]) throw new TypeError('No method named "' + t + '"');
                    n[t]()
                }
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    r.collapseInterface(this, e)
                }))
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return $
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.collapse"
                }
            }]), r
        }(F);
    B.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function(e) {
        "A" === e.target.tagName && e.preventDefault();
        var t = V.getDataAttributes(this),
            i = l(this);
        W.find(i).forEach((function(e) {
            var i, n = E(e, "bs.collapse");
            n ? (null === n._parent && "string" == typeof t.parent && (n._config.parent = t.parent, n._parent = n._getParent()), i = "toggle") : i = t, ee.collapseInterface(e, i)
        }))
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn[Q];
            e.fn[Q] = ee.jQueryInterface, e.fn[Q].Constructor = ee, e.fn[Q].noConflict = function() {
                return e.fn[Q] = t, ee.jQueryInterface
            }
        }
    }));
    var te = "top",
        ie = "bottom",
        ne = "right",
        re = "left",
        oe = [te, ie, ne, re],
        ae = oe.reduce((function(e, t) {
            return e.concat([t + "-start", t + "-end"])
        }), []),
        se = [].concat(oe, ["auto"]).reduce((function(e, t) {
            return e.concat([t, t + "-start", t + "-end"])
        }), []),
        le = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

    function ce(e) {
        return e ? (e.nodeName || "").toLowerCase() : null
    }

    function he(e) {
        if ("[object Window]" !== e.toString()) {
            var t = e.ownerDocument;
            return t && t.defaultView || window
        }
        return e
    }

    function ue(e) {
        return e instanceof he(e).Element || e instanceof Element
    }

    function de(e) {
        return e instanceof he(e).HTMLElement || e instanceof HTMLElement
    }
    var pe = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(e) {
            var t = e.state;
            Object.keys(t.elements).forEach((function(e) {
                var i = t.styles[e] || {},
                    n = t.attributes[e] || {},
                    r = t.elements[e];
                de(r) && ce(r) && (Object.assign(r.style, i), Object.keys(n).forEach((function(e) {
                    var t = n[e];
                    !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t)
                })))
            }))
        },
        effect: function(e) {
            var t = e.state,
                i = {
                    popper: {
                        position: t.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            return Object.assign(t.elements.popper.style, i.popper), t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
                function() {
                    Object.keys(t.elements).forEach((function(e) {
                        var n = t.elements[e],
                            r = t.attributes[e] || {},
                            o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function(e, t) {
                                return e[t] = "", e
                            }), {});
                        de(n) && ce(n) && (Object.assign(n.style, o), Object.keys(r).forEach((function(e) {
                            n.removeAttribute(e)
                        })))
                    }))
                }
        },
        requires: ["computeStyles"]
    };

    function fe(e) {
        return e.split("-")[0]
    }

    function me(e) {
        return {
            x: e.offsetLeft,
            y: e.offsetTop,
            width: e.offsetWidth,
            height: e.offsetHeight
        }
    }

    function ge(e, t) {
        var i, n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (n && ((i = n) instanceof he(i).ShadowRoot || i instanceof ShadowRoot)) {
            var r = t;
            do {
                if (r && e.isSameNode(r)) return !0;
                r = r.parentNode || r.host
            } while (r)
        }
        return !1
    }

    function ve(e) {
        return he(e).getComputedStyle(e)
    }

    function ye(e) {
        return ["table", "td", "th"].indexOf(ce(e)) >= 0
    }

    function be(e) {
        return ((ue(e) ? e.ownerDocument : e.document) || window.document).documentElement
    }

    function xe(e) {
        return "html" === ce(e) ? e : e.assignedSlot || e.parentNode || e.host || be(e)
    }

    function we(e) {
        if (!de(e) || "fixed" === ve(e).position) return null;
        var t = e.offsetParent;
        if (t) {
            var i = be(t);
            if ("body" === ce(t) && "static" === ve(t).position && "static" !== ve(i).position) return i
        }
        return t
    }

    function _e(e) {
        for (var t = he(e), i = we(e); i && ye(i) && "static" === ve(i).position;) i = we(i);
        return i && "body" === ce(i) && "static" === ve(i).position ? t : i || function(e) {
            for (var t = xe(e); de(t) && ["html", "body"].indexOf(ce(t)) < 0;) {
                var i = ve(t);
                if ("none" !== i.transform || "none" !== i.perspective || i.willChange && "auto" !== i.willChange) return t;
                t = t.parentNode
            }
            return null
        }(e) || t
    }

    function Ee(e) {
        return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
    }

    function Me(e, t, i) {
        return Math.max(e, Math.min(t, i))
    }

    function Te(e) {
        return Object.assign(Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }), e)
    }

    function Se(e, t) {
        return t.reduce((function(t, i) {
            return t[i] = e, t
        }), {})
    }
    var Ae = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t, i = e.state,
                    n = e.name,
                    r = i.elements.arrow,
                    o = i.modifiersData.popperOffsets,
                    a = fe(i.placement),
                    s = Ee(a),
                    l = [re, ne].indexOf(a) >= 0 ? "height" : "width";
                if (r && o) {
                    var c = i.modifiersData[n + "#persistent"].padding,
                        h = me(r),
                        u = "y" === s ? te : re,
                        d = "y" === s ? ie : ne,
                        p = i.rects.reference[l] + i.rects.reference[s] - o[s] - i.rects.popper[l],
                        f = o[s] - i.rects.reference[s],
                        m = _e(r),
                        g = m ? "y" === s ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
                        v = p / 2 - f / 2,
                        y = c[u],
                        b = g - h[l] - c[d],
                        x = g / 2 - h[l] / 2 + v,
                        w = Me(y, x, b),
                        _ = s;
                    i.modifiersData[n] = ((t = {})[_] = w, t.centerOffset = w - x, t)
                }
            },
            effect: function(e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.element,
                    o = void 0 === r ? "[data-popper-arrow]" : r,
                    a = i.padding,
                    s = void 0 === a ? 0 : a;
                null != o && ("string" != typeof o || (o = t.elements.popper.querySelector(o))) && ge(t.elements.popper, o) && (t.elements.arrow = o, t.modifiersData[n + "#persistent"] = {
                    padding: Te("number" != typeof s ? s : Se(s, oe))
                })
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        },
        Ce = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

    function Le(e) {
        var t, i = e.popper,
            n = e.popperRect,
            r = e.placement,
            o = e.offsets,
            a = e.position,
            s = e.gpuAcceleration,
            l = e.adaptive,
            c = function(e) {
                var t = e.x,
                    i = e.y,
                    n = window.devicePixelRatio || 1;
                return {
                    x: Math.round(t * n) / n || 0,
                    y: Math.round(i * n) / n || 0
                }
            }(o),
            h = c.x,
            u = c.y,
            d = o.hasOwnProperty("x"),
            p = o.hasOwnProperty("y"),
            f = re,
            m = te,
            g = window;
        if (l) {
            var v = _e(i);
            v === he(i) && (v = be(i)), r === te && (m = ie, u -= v.clientHeight - n.height, u *= s ? 1 : -1), r === re && (f = ne, h -= v.clientWidth - n.width, h *= s ? 1 : -1)
        }
        var y, b = Object.assign({
            position: a
        }, l && Ce);
        return s ? Object.assign(Object.assign({}, b), {}, ((y = {})[m] = p ? "0" : "", y[f] = d ? "0" : "", y.transform = (g.devicePixelRatio || 1) < 2 ? "translate(" + h + "px, " + u + "px)" : "translate3d(" + h + "px, " + u + "px, 0)", y)) : Object.assign(Object.assign({}, b), {}, ((t = {})[m] = p ? u + "px" : "", t[f] = d ? h + "px" : "", t.transform = "", t))
    }
    var De = {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function(e) {
                var t = e.state,
                    i = e.options,
                    n = i.gpuAcceleration,
                    r = void 0 === n || n,
                    o = i.adaptive,
                    a = void 0 === o || o,
                    s = {
                        placement: fe(t.placement),
                        popper: t.elements.popper,
                        popperRect: t.rects.popper,
                        gpuAcceleration: r
                    };
                null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign(Object.assign({}, t.styles.popper), Le(Object.assign(Object.assign({}, s), {}, {
                    offsets: t.modifiersData.popperOffsets,
                    position: t.options.strategy,
                    adaptive: a
                })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign(Object.assign({}, t.styles.arrow), Le(Object.assign(Object.assign({}, s), {}, {
                    offsets: t.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1
                })))), t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
                    "data-popper-placement": t.placement
                })
            },
            data: {}
        },
        Pe = {
            passive: !0
        },
        Re = {
            name: "eventListeners",
            enabled: !0,
            phase: "write",
            fn: function() {},
            effect: function(e) {
                var t = e.state,
                    i = e.instance,
                    n = e.options,
                    r = n.scroll,
                    o = void 0 === r || r,
                    a = n.resize,
                    s = void 0 === a || a,
                    l = he(t.elements.popper),
                    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                return o && c.forEach((function(e) {
                        e.addEventListener("scroll", i.update, Pe)
                    })), s && l.addEventListener("resize", i.update, Pe),
                    function() {
                        o && c.forEach((function(e) {
                            e.removeEventListener("scroll", i.update, Pe)
                        })), s && l.removeEventListener("resize", i.update, Pe)
                    }
            },
            data: {}
        },
        Oe = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };

    function Ie(e) {
        return e.replace(/left|right|bottom|top/g, (function(e) {
            return Oe[e]
        }))
    }
    var ze = {
        start: "end",
        end: "start"
    };

    function Ne(e) {
        return e.replace(/start|end/g, (function(e) {
            return ze[e]
        }))
    }

    function Be(e) {
        var t = e.getBoundingClientRect();
        return {
            width: t.width,
            height: t.height,
            top: t.top,
            right: t.right,
            bottom: t.bottom,
            left: t.left,
            x: t.left,
            y: t.top
        }
    }

    function Fe(e) {
        var t = he(e);
        return {
            scrollLeft: t.pageXOffset,
            scrollTop: t.pageYOffset
        }
    }

    function ke(e) {
        return Be(be(e)).left + Fe(e).scrollLeft
    }

    function Ue(e) {
        var t = ve(e),
            i = t.overflow,
            n = t.overflowX,
            r = t.overflowY;
        return /auto|scroll|overlay|hidden/.test(i + r + n)
    }

    function He(e, t) {
        void 0 === t && (t = []);
        var i = function e(t) {
                return ["html", "body", "#document"].indexOf(ce(t)) >= 0 ? t.ownerDocument.body : de(t) && Ue(t) ? t : e(xe(t))
            }(e),
            n = "body" === ce(i),
            r = he(i),
            o = n ? [r].concat(r.visualViewport || [], Ue(i) ? i : []) : i,
            a = t.concat(o);
        return n ? a : a.concat(He(xe(o)))
    }

    function Ge(e) {
        return Object.assign(Object.assign({}, e), {}, {
            left: e.x,
            top: e.y,
            right: e.x + e.width,
            bottom: e.y + e.height
        })
    }

    function je(e, t) {
        return "viewport" === t ? Ge(function(e) {
            var t = he(e),
                i = be(e),
                n = t.visualViewport,
                r = i.clientWidth,
                o = i.clientHeight,
                a = 0,
                s = 0;
            return n && (r = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = n.offsetLeft, s = n.offsetTop)), {
                width: r,
                height: o,
                x: a + ke(e),
                y: s
            }
        }(e)) : de(t) ? function(e) {
            var t = Be(e);
            return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
        }(t) : Ge(function(e) {
            var t = be(e),
                i = Fe(e),
                n = e.ownerDocument.body,
                r = Math.max(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0),
                o = Math.max(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0),
                a = -i.scrollLeft + ke(e),
                s = -i.scrollTop;
            return "rtl" === ve(n || t).direction && (a += Math.max(t.clientWidth, n ? n.clientWidth : 0) - r), {
                width: r,
                height: o,
                x: a,
                y: s
            }
        }(be(e)))
    }

    function Ve(e) {
        return e.split("-")[1]
    }

    function We(e) {
        var t, i = e.reference,
            n = e.element,
            r = e.placement,
            o = r ? fe(r) : null,
            a = r ? Ve(r) : null,
            s = i.x + i.width / 2 - n.width / 2,
            l = i.y + i.height / 2 - n.height / 2;
        switch (o) {
            case te:
                t = {
                    x: s,
                    y: i.y - n.height
                };
                break;
            case ie:
                t = {
                    x: s,
                    y: i.y + i.height
                };
                break;
            case ne:
                t = {
                    x: i.x + i.width,
                    y: l
                };
                break;
            case re:
                t = {
                    x: i.x - n.width,
                    y: l
                };
                break;
            default:
                t = {
                    x: i.x,
                    y: i.y
                }
        }
        var c = o ? Ee(o) : null;
        if (null != c) {
            var h = "y" === c ? "height" : "width";
            switch (a) {
                case "start":
                    t[c] = Math.floor(t[c]) - Math.floor(i[h] / 2 - n[h] / 2);
                    break;
                case "end":
                    t[c] = Math.floor(t[c]) + Math.ceil(i[h] / 2 - n[h] / 2)
            }
        }
        return t
    }

    function qe(e, t) {
        void 0 === t && (t = {});
        var i = t,
            n = i.placement,
            r = void 0 === n ? e.placement : n,
            o = i.boundary,
            a = void 0 === o ? "clippingParents" : o,
            s = i.rootBoundary,
            l = void 0 === s ? "viewport" : s,
            c = i.elementContext,
            h = void 0 === c ? "popper" : c,
            u = i.altBoundary,
            d = void 0 !== u && u,
            p = i.padding,
            f = void 0 === p ? 0 : p,
            m = Te("number" != typeof f ? f : Se(f, oe)),
            g = "popper" === h ? "reference" : "popper",
            v = e.elements.reference,
            y = e.rects.popper,
            b = e.elements[d ? g : h],
            x = function(e, t, i) {
                var n = "clippingParents" === t ? function(e) {
                        var t = He(xe(e)),
                            i = ["absolute", "fixed"].indexOf(ve(e).position) >= 0 && de(e) ? _e(e) : e;
                        return ue(i) ? t.filter((function(e) {
                            return ue(e) && ge(e, i) && "body" !== ce(e)
                        })) : []
                    }(e) : [].concat(t),
                    r = [].concat(n, [i]),
                    o = r[0],
                    a = r.reduce((function(t, i) {
                        var n = je(e, i);
                        return t.top = Math.max(n.top, t.top), t.right = Math.min(n.right, t.right), t.bottom = Math.min(n.bottom, t.bottom), t.left = Math.max(n.left, t.left), t
                    }), je(e, o));
                return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
            }(ue(b) ? b : b.contextElement || be(e.elements.popper), a, l),
            w = Be(v),
            _ = We({
                reference: w,
                element: y,
                strategy: "absolute",
                placement: r
            }),
            E = Ge(Object.assign(Object.assign({}, y), _)),
            M = "popper" === h ? E : w,
            T = {
                top: x.top - M.top + m.top,
                bottom: M.bottom - x.bottom + m.bottom,
                left: x.left - M.left + m.left,
                right: M.right - x.right + m.right
            },
            S = e.modifiersData.offset;
        if ("popper" === h && S) {
            var A = S[r];
            Object.keys(T).forEach((function(e) {
                var t = [ne, ie].indexOf(e) >= 0 ? 1 : -1,
                    i = [te, ie].indexOf(e) >= 0 ? "y" : "x";
                T[e] += A[i] * t
            }))
        }
        return T
    }
    var Xe = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(e) {
            var t = e.state,
                i = e.options,
                n = e.name;
            if (!t.modifiersData[n]._skip) {
                for (var r = i.mainAxis, o = void 0 === r || r, a = i.altAxis, s = void 0 === a || a, l = i.fallbackPlacements, c = i.padding, h = i.boundary, u = i.rootBoundary, d = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, m = i.allowedAutoPlacements, g = t.options.placement, v = fe(g), y = l || (v !== g && f ? function(e) {
                        if ("auto" === fe(e)) return [];
                        var t = Ie(e);
                        return [Ne(e), t, Ne(t)]
                    }(g) : [Ie(g)]), b = [g].concat(y).reduce((function(e, i) {
                        return e.concat("auto" === fe(i) ? function(e, t) {
                            void 0 === t && (t = {});
                            var i = t,
                                n = i.placement,
                                r = i.boundary,
                                o = i.rootBoundary,
                                a = i.padding,
                                s = i.flipVariations,
                                l = i.allowedAutoPlacements,
                                c = void 0 === l ? se : l,
                                h = Ve(n),
                                u = h ? s ? ae : ae.filter((function(e) {
                                    return Ve(e) === h
                                })) : oe,
                                d = u.filter((function(e) {
                                    return c.indexOf(e) >= 0
                                }));
                            0 === d.length && (d = u);
                            var p = d.reduce((function(t, i) {
                                return t[i] = qe(e, {
                                    placement: i,
                                    boundary: r,
                                    rootBoundary: o,
                                    padding: a
                                })[fe(i)], t
                            }), {});
                            return Object.keys(p).sort((function(e, t) {
                                return p[e] - p[t]
                            }))
                        }(t, {
                            placement: i,
                            boundary: h,
                            rootBoundary: u,
                            padding: c,
                            flipVariations: f,
                            allowedAutoPlacements: m
                        }) : i)
                    }), []), x = t.rects.reference, w = t.rects.popper, _ = new Map, E = !0, M = b[0], T = 0; T < b.length; T++) {
                    var S = b[T],
                        A = fe(S),
                        C = "start" === Ve(S),
                        L = [te, ie].indexOf(A) >= 0,
                        D = L ? "width" : "height",
                        P = qe(t, {
                            placement: S,
                            boundary: h,
                            rootBoundary: u,
                            altBoundary: d,
                            padding: c
                        }),
                        R = L ? C ? ne : re : C ? ie : te;
                    x[D] > w[D] && (R = Ie(R));
                    var O = Ie(R),
                        I = [];
                    if (o && I.push(P[A] <= 0), s && I.push(P[R] <= 0, P[O] <= 0), I.every((function(e) {
                            return e
                        }))) {
                        M = S, E = !1;
                        break
                    }
                    _.set(S, I)
                }
                if (E)
                    for (var z = function(e) {
                            var t = b.find((function(t) {
                                var i = _.get(t);
                                if (i) return i.slice(0, e).every((function(e) {
                                    return e
                                }))
                            }));
                            if (t) return M = t, "break"
                        }, N = f ? 3 : 1; N > 0 && "break" !== z(N); N--);
                t.placement !== M && (t.modifiersData[n]._skip = !0, t.placement = M, t.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };

    function Ye(e, t, i) {
        return void 0 === i && (i = {
            x: 0,
            y: 0
        }), {
            top: e.top - t.height - i.y,
            right: e.right - t.width + i.x,
            bottom: e.bottom - t.height + i.y,
            left: e.left - t.width - i.x
        }
    }

    function Ze(e) {
        return [te, ne, ie, re].some((function(t) {
            return e[t] >= 0
        }))
    }
    var Je = {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function(e) {
                var t = e.state,
                    i = e.name,
                    n = t.rects.reference,
                    r = t.rects.popper,
                    o = t.modifiersData.preventOverflow,
                    a = qe(t, {
                        elementContext: "reference"
                    }),
                    s = qe(t, {
                        altBoundary: !0
                    }),
                    l = Ye(a, n),
                    c = Ye(s, r, o),
                    h = Ze(l),
                    u = Ze(c);
                t.modifiersData[i] = {
                    referenceClippingOffsets: l,
                    popperEscapeOffsets: c,
                    isReferenceHidden: h,
                    hasPopperEscaped: u
                }, t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
                    "data-popper-reference-hidden": h,
                    "data-popper-escaped": u
                })
            }
        },
        Qe = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.offset,
                    o = void 0 === r ? [0, 0] : r,
                    a = se.reduce((function(e, i) {
                        return e[i] = function(e, t, i) {
                            var n = fe(e),
                                r = [re, te].indexOf(n) >= 0 ? -1 : 1,
                                o = "function" == typeof i ? i(Object.assign(Object.assign({}, t), {}, {
                                    placement: e
                                })) : i,
                                a = o[0],
                                s = o[1];
                            return a = a || 0, s = (s || 0) * r, [re, ne].indexOf(n) >= 0 ? {
                                x: s,
                                y: a
                            } : {
                                x: a,
                                y: s
                            }
                        }(i, t.rects, o), e
                    }), {}),
                    s = a[t.placement],
                    l = s.x,
                    c = s.y;
                null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = a
            }
        },
        $e = {
            name: "popperOffsets",
            enabled: !0,
            phase: "read",
            fn: function(e) {
                var t = e.state,
                    i = e.name;
                t.modifiersData[i] = We({
                    reference: t.rects.reference,
                    element: t.rects.popper,
                    strategy: "absolute",
                    placement: t.placement
                })
            },
            data: {}
        },
        Ke = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.mainAxis,
                    o = void 0 === r || r,
                    a = i.altAxis,
                    s = void 0 !== a && a,
                    l = i.boundary,
                    c = i.rootBoundary,
                    h = i.altBoundary,
                    u = i.padding,
                    d = i.tether,
                    p = void 0 === d || d,
                    f = i.tetherOffset,
                    m = void 0 === f ? 0 : f,
                    g = qe(t, {
                        boundary: l,
                        rootBoundary: c,
                        padding: u,
                        altBoundary: h
                    }),
                    v = fe(t.placement),
                    y = Ve(t.placement),
                    b = !y,
                    x = Ee(v),
                    w = "x" === x ? "y" : "x",
                    _ = t.modifiersData.popperOffsets,
                    E = t.rects.reference,
                    M = t.rects.popper,
                    T = "function" == typeof m ? m(Object.assign(Object.assign({}, t.rects), {}, {
                        placement: t.placement
                    })) : m,
                    S = {
                        x: 0,
                        y: 0
                    };
                if (_) {
                    if (o) {
                        var A = "y" === x ? te : re,
                            C = "y" === x ? ie : ne,
                            L = "y" === x ? "height" : "width",
                            D = _[x],
                            P = _[x] + g[A],
                            R = _[x] - g[C],
                            O = p ? -M[L] / 2 : 0,
                            I = "start" === y ? E[L] : M[L],
                            z = "start" === y ? -M[L] : -E[L],
                            N = t.elements.arrow,
                            B = p && N ? me(N) : {
                                width: 0,
                                height: 0
                            },
                            F = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0
                            },
                            k = F[A],
                            U = F[C],
                            H = Me(0, E[L], B[L]),
                            G = b ? E[L] / 2 - O - H - k - T : I - H - k - T,
                            j = b ? -E[L] / 2 + O + H + U + T : z + H + U + T,
                            V = t.elements.arrow && _e(t.elements.arrow),
                            W = V ? "y" === x ? V.clientTop || 0 : V.clientLeft || 0 : 0,
                            q = t.modifiersData.offset ? t.modifiersData.offset[t.placement][x] : 0,
                            X = _[x] + G - q - W,
                            Y = _[x] + j - q,
                            Z = Me(p ? Math.min(P, X) : P, D, p ? Math.max(R, Y) : R);
                        _[x] = Z, S[x] = Z - D
                    }
                    if (s) {
                        var J = "x" === x ? te : re,
                            Q = "x" === x ? ie : ne,
                            $ = _[w],
                            K = Me($ + g[J], $, $ - g[Q]);
                        _[w] = K, S[w] = K - $
                    }
                    t.modifiersData[n] = S
                }
            },
            requiresIfExists: ["offset"]
        };

    function et(e, t, i) {
        void 0 === i && (i = !1);
        var n, r, o = be(t),
            a = Be(e),
            s = de(t),
            l = {
                scrollLeft: 0,
                scrollTop: 0
            },
            c = {
                x: 0,
                y: 0
            };
        return (s || !s && !i) && (("body" !== ce(t) || Ue(o)) && (l = (n = t) !== he(n) && de(n) ? {
            scrollLeft: (r = n).scrollLeft,
            scrollTop: r.scrollTop
        } : Fe(n)), de(t) ? ((c = Be(t)).x += t.clientLeft, c.y += t.clientTop) : o && (c.x = ke(o))), {
            x: a.left + l.scrollLeft - c.x,
            y: a.top + l.scrollTop - c.y,
            width: a.width,
            height: a.height
        }
    }
    var tt = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

    function it() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        return !t.some((function(e) {
            return !(e && "function" == typeof e.getBoundingClientRect)
        }))
    }

    function nt(e) {
        void 0 === e && (e = {});
        var t = e,
            i = t.defaultModifiers,
            n = void 0 === i ? [] : i,
            r = t.defaultOptions,
            o = void 0 === r ? tt : r;
        return function(e, t, i) {
            void 0 === i && (i = o);
            var r, a, s = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign(Object.assign({}, tt), o),
                    modifiersData: {},
                    elements: {
                        reference: e,
                        popper: t
                    },
                    attributes: {},
                    styles: {}
                },
                l = [],
                c = !1,
                h = {
                    state: s,
                    setOptions: function(i) {
                        u(), s.options = Object.assign(Object.assign(Object.assign({}, o), s.options), i), s.scrollParents = {
                            reference: ue(e) ? He(e) : e.contextElement ? He(e.contextElement) : [],
                            popper: He(t)
                        };
                        var r, a, c = function(e) {
                            var t = function(e) {
                                var t = new Map,
                                    i = new Set,
                                    n = [];
                                return e.forEach((function(e) {
                                    t.set(e.name, e)
                                })), e.forEach((function(e) {
                                    i.has(e.name) || function e(r) {
                                        i.add(r.name), [].concat(r.requires || [], r.requiresIfExists || []).forEach((function(n) {
                                            if (!i.has(n)) {
                                                var r = t.get(n);
                                                r && e(r)
                                            }
                                        })), n.push(r)
                                    }(e)
                                })), n
                            }(e);
                            return le.reduce((function(e, i) {
                                return e.concat(t.filter((function(e) {
                                    return e.phase === i
                                })))
                            }), [])
                        }((r = [].concat(n, s.options.modifiers), a = r.reduce((function(e, t) {
                            var i = e[t.name];
                            return e[t.name] = i ? Object.assign(Object.assign(Object.assign({}, i), t), {}, {
                                options: Object.assign(Object.assign({}, i.options), t.options),
                                data: Object.assign(Object.assign({}, i.data), t.data)
                            }) : t, e
                        }), {}), Object.keys(a).map((function(e) {
                            return a[e]
                        }))));
                        return s.orderedModifiers = c.filter((function(e) {
                            return e.enabled
                        })), s.orderedModifiers.forEach((function(e) {
                            var t = e.name,
                                i = e.options,
                                n = void 0 === i ? {} : i,
                                r = e.effect;
                            if ("function" == typeof r) {
                                var o = r({
                                    state: s,
                                    name: t,
                                    instance: h,
                                    options: n
                                });
                                l.push(o || function() {})
                            }
                        })), h.update()
                    },
                    forceUpdate: function() {
                        if (!c) {
                            var e = s.elements,
                                t = e.reference,
                                i = e.popper;
                            if (it(t, i)) {
                                s.rects = {
                                    reference: et(t, _e(i), "fixed" === s.options.strategy),
                                    popper: me(i)
                                }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach((function(e) {
                                    return s.modifiersData[e.name] = Object.assign({}, e.data)
                                }));
                                for (var n = 0; n < s.orderedModifiers.length; n++)
                                    if (!0 !== s.reset) {
                                        var r = s.orderedModifiers[n],
                                            o = r.fn,
                                            a = r.options,
                                            l = void 0 === a ? {} : a,
                                            u = r.name;
                                        "function" == typeof o && (s = o({
                                            state: s,
                                            options: l,
                                            name: u,
                                            instance: h
                                        }) || s)
                                    } else s.reset = !1, n = -1
                            }
                        }
                    },
                    update: (r = function() {
                        return new Promise((function(e) {
                            h.forceUpdate(), e(s)
                        }))
                    }, function() {
                        return a || (a = new Promise((function(e) {
                            Promise.resolve().then((function() {
                                a = void 0, e(r())
                            }))
                        }))), a
                    }),
                    destroy: function() {
                        u(), c = !0
                    }
                };
            if (!it(e, t)) return h;

            function u() {
                l.forEach((function(e) {
                    return e()
                })), l = []
            }
            return h.setOptions(i).then((function(e) {
                !c && i.onFirstUpdate && i.onFirstUpdate(e)
            })), h
        }
    }
    var rt = nt(),
        ot = nt({
            defaultModifiers: [Re, $e, De, pe]
        }),
        at = nt({
            defaultModifiers: [Re, $e, De, pe, Qe, Xe, Ke, Ae, Je]
        }),
        st = Object.freeze({
            __proto__: null,
            popperGenerator: nt,
            detectOverflow: qe,
            createPopperBase: rt,
            createPopper: at,
            createPopperLite: ot,
            top: te,
            bottom: ie,
            right: ne,
            left: re,
            auto: "auto",
            basePlacements: oe,
            start: "start",
            end: "end",
            clippingParents: "clippingParents",
            viewport: "viewport",
            popper: "popper",
            reference: "reference",
            variationPlacements: ae,
            placements: se,
            beforeRead: "beforeRead",
            read: "read",
            afterRead: "afterRead",
            beforeMain: "beforeMain",
            main: "main",
            afterMain: "afterMain",
            beforeWrite: "beforeWrite",
            write: "write",
            afterWrite: "afterWrite",
            modifierPhases: le,
            applyStyles: pe,
            arrow: Ae,
            computeStyles: De,
            eventListeners: Re,
            flip: Xe,
            hide: Je,
            offset: Qe,
            popperOffsets: $e,
            preventOverflow: Ke
        }),
        lt = "dropdown",
        ct = new RegExp("ArrowUp|ArrowDown|Escape"),
        ht = x ? "top-end" : "top-start",
        ut = x ? "top-start" : "top-end",
        dt = x ? "bottom-end" : "bottom-start",
        pt = x ? "bottom-start" : "bottom-end",
        ft = x ? "left-start" : "right-start",
        mt = x ? "right-start" : "left-start",
        gt = {
            offset: 0,
            flip: !0,
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null
        },
        vt = {
            offset: "(number|string|function)",
            flip: "boolean",
            boundary: "(string|element)",
            reference: "(string|element)",
            display: "string",
            popperConfig: "(null|object)"
        },
        yt = function(e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._popper = null, n._config = n._getConfig(i), n._menu = n._getMenuElement(), n._inNavbar = n._detectNavbar(), n._addEventListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function() {
                if (!this._element.disabled && !this._element.classList.contains("disabled")) {
                    var e = this._element.classList.contains("show");
                    r.clearMenus(), e || this.show()
                }
            }, o.show = function() {
                if (!(this._element.disabled || this._element.classList.contains("disabled") || this._menu.classList.contains("show"))) {
                    var e = r.getParentFromElement(this._element),
                        t = {
                            relatedTarget: this._element
                        };
                    if (!B.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
                        if (!this._inNavbar) {
                            if (void 0 === st) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                            var i = this._element;
                            "parent" === this._config.reference ? i = e : d(this._config.reference) && (i = this._config.reference, void 0 !== this._config.reference.jquery && (i = this._config.reference[0])), this._popper = at(i, this._menu, this._getPopperConfig())
                        }
                        var n;
                        "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && (n = []).concat.apply(n, document.body.children).forEach((function(e) {
                            return B.on(e, "mouseover", null, (function() {}))
                        })), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), B.trigger(e, "shown.bs.dropdown", t)
                    }
                }
            }, o.hide = function() {
                if (!this._element.disabled && !this._element.classList.contains("disabled") && this._menu.classList.contains("show")) {
                    var e = r.getParentFromElement(this._element),
                        t = {
                            relatedTarget: this._element
                        };
                    B.trigger(e, "hide.bs.dropdown", t).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), B.trigger(e, "hidden.bs.dropdown", t))
                }
            }, o.dispose = function() {
                e.prototype.dispose.call(this), B.off(this._element, ".bs.dropdown"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null)
            }, o.update = function() {
                this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
            }, o._addEventListeners = function() {
                var e = this;
                B.on(this._element, "click.bs.dropdown", (function(t) {
                    t.preventDefault(), t.stopPropagation(), e.toggle()
                }))
            }, o._getConfig = function(e) {
                return e = i({}, this.constructor.Default, V.getDataAttributes(this._element), e), f(lt, e, this.constructor.DefaultType), e
            }, o._getMenuElement = function() {
                return W.next(this._element, ".dropdown-menu")[0]
            }, o._getPlacement = function() {
                var e = this._element.parentNode;
                if (e.classList.contains("dropend")) return ft;
                if (e.classList.contains("dropstart")) return mt;
                var t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                return e.classList.contains("dropup") ? t ? ut : ht : t ? pt : dt
            }, o._detectNavbar = function() {
                return null !== this._element.closest(".navbar")
            }, o._getPopperConfig = function() {
                var e = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            altBoundary: this._config.flip,
                            rootBoundary: this._config.boundary
                        }
                    }]
                };
                return "static" === this._config.display && (e.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]), i({}, e, this._config.popperConfig)
            }, r.dropdownInterface = function(e, t) {
                var i = E(e, "bs.dropdown");
                if (i || (i = new r(e, "object" == typeof t ? t : null)), "string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError('No method named "' + t + '"');
                    i[t]()
                }
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    r.dropdownInterface(this, e)
                }))
            }, r.clearMenus = function(e) {
                if (!e || 2 !== e.button && ("keyup" !== e.type || "Tab" === e.key))
                    for (var t = W.find('[data-bs-toggle="dropdown"]'), i = 0, n = t.length; i < n; i++) {
                        var o = r.getParentFromElement(t[i]),
                            a = E(t[i], "bs.dropdown"),
                            s = {
                                relatedTarget: t[i]
                            };
                        if (e && "click" === e.type && (s.clickEvent = e), a) {
                            var l, c = a._menu;
                            if (t[i].classList.contains("show") && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && "Tab" === e.key) && c.contains(e.target) || B.trigger(o, "hide.bs.dropdown", s).defaultPrevented)) "ontouchstart" in document.documentElement && (l = []).concat.apply(l, document.body.children).forEach((function(e) {
                                return B.off(e, "mouseover", null, (function() {}))
                            })), t[i].setAttribute("aria-expanded", "false"), a._popper && a._popper.destroy(), c.classList.remove("show"), t[i].classList.remove("show"), B.trigger(o, "hidden.bs.dropdown", s)
                        }
                    }
            }, r.getParentFromElement = function(e) {
                return c(e) || e.parentNode
            }, r.dataApiKeydownHandler = function(e) {
                if (!(/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !ct.test(e.key)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !this.classList.contains("disabled"))) {
                    var t = r.getParentFromElement(this),
                        i = this.classList.contains("show");
                    if ("Escape" === e.key) return (this.matches('[data-bs-toggle="dropdown"]') ? this : W.prev(this, '[data-bs-toggle="dropdown"]')[0]).focus(), void r.clearMenus();
                    if (i && "Space" !== e.key) {
                        var n = W.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", t).filter(m);
                        if (n.length) {
                            var o = n.indexOf(e.target);
                            "ArrowUp" === e.key && o > 0 && o--, "ArrowDown" === e.key && o < n.length - 1 && o++, n[o = -1 === o ? 0 : o].focus()
                        }
                    } else r.clearMenus()
                }
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return gt
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return vt
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.dropdown"
                }
            }]), r
        }(F);
    B.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', yt.dataApiKeydownHandler), B.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", yt.dataApiKeydownHandler), B.on(document, "click.bs.dropdown.data-api", yt.clearMenus), B.on(document, "keyup.bs.dropdown.data-api", yt.clearMenus), B.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function(e) {
        e.preventDefault(), e.stopPropagation(), yt.dropdownInterface(this, "toggle")
    })), B.on(document, "click.bs.dropdown.data-api", ".dropdown form", (function(e) {
        return e.stopPropagation()
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn[lt];
            e.fn[lt] = yt.jQueryInterface, e.fn[lt].Constructor = yt, e.fn[lt].noConflict = function() {
                return e.fn[lt] = t, yt.jQueryInterface
            }
        }
    }));
    var bt = {
            backdrop: !0,
            keyboard: !0,
            focus: !0
        },
        xt = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean"
        },
        wt = function(e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._config = n._getConfig(i), n._dialog = W.findOne(".modal-dialog", t), n._backdrop = null, n._isShown = !1, n._isBodyOverflowing = !1, n._ignoreBackdropClick = !1, n._isTransitioning = !1, n._scrollbarWidth = 0, n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function(e) {
                return this._isShown ? this.hide() : this.show(e)
            }, o.show = function(e) {
                var t = this;
                if (!this._isShown && !this._isTransitioning) {
                    this._element.classList.contains("fade") && (this._isTransitioning = !0);
                    var i = B.trigger(this._element, "show.bs.modal", {
                        relatedTarget: e
                    });
                    this._isShown || i.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), B.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (function(e) {
                        return t.hide(e)
                    })), B.on(this._dialog, "mousedown.dismiss.bs.modal", (function() {
                        B.one(t._element, "mouseup.dismiss.bs.modal", (function(e) {
                            e.target === t._element && (t._ignoreBackdropClick = !0)
                        }))
                    })), this._showBackdrop((function() {
                        return t._showElement(e)
                    })))
                }
            }, o.hide = function(e) {
                var t = this;
                if (e && e.preventDefault(), this._isShown && !this._isTransitioning && !B.trigger(this._element, "hide.bs.modal").defaultPrevented) {
                    this._isShown = !1;
                    var i = this._element.classList.contains("fade");
                    if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), B.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), B.off(this._element, "click.dismiss.bs.modal"), B.off(this._dialog, "mousedown.dismiss.bs.modal"), i) {
                        var n = h(this._element);
                        B.one(this._element, "transitionend", (function(e) {
                            return t._hideModal(e)
                        })), p(this._element, n)
                    } else this._hideModal()
                }
            }, o.dispose = function() {
                [window, this._element, this._dialog].forEach((function(e) {
                    return B.off(e, ".bs.modal")
                })), e.prototype.dispose.call(this), B.off(document, "focusin.bs.modal"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
            }, o.handleUpdate = function() {
                this._adjustDialog()
            }, o._getConfig = function(e) {
                return e = i({}, bt, e), f("modal", e, xt), e
            }, o._showElement = function(e) {
                var t = this,
                    i = this._element.classList.contains("fade"),
                    n = W.findOne(".modal-body", this._dialog);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), i && v(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus();
                var r = function() {
                    t._config.focus && t._element.focus(), t._isTransitioning = !1, B.trigger(t._element, "shown.bs.modal", {
                        relatedTarget: e
                    })
                };
                if (i) {
                    var o = h(this._dialog);
                    B.one(this._dialog, "transitionend", r), p(this._dialog, o)
                } else r()
            }, o._enforceFocus = function() {
                var e = this;
                B.off(document, "focusin.bs.modal"), B.on(document, "focusin.bs.modal", (function(t) {
                    document === t.target || e._element === t.target || e._element.contains(t.target) || e._element.focus()
                }))
            }, o._setEscapeEvent = function() {
                var e = this;
                this._isShown ? B.on(this._element, "keydown.dismiss.bs.modal", (function(t) {
                    e._config.keyboard && "Escape" === t.key ? (t.preventDefault(), e.hide()) : e._config.keyboard || "Escape" !== t.key || e._triggerBackdropTransition()
                })) : B.off(this._element, "keydown.dismiss.bs.modal")
            }, o._setResizeEvent = function() {
                var e = this;
                this._isShown ? B.on(window, "resize.bs.modal", (function() {
                    return e._adjustDialog()
                })) : B.off(window, "resize.bs.modal")
            }, o._hideModal = function() {
                var e = this;
                this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function() {
                    document.body.classList.remove("modal-open"), e._resetAdjustments(), e._resetScrollbar(), B.trigger(e._element, "hidden.bs.modal")
                }))
            }, o._removeBackdrop = function() {
                this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null
            }, o._showBackdrop = function(e) {
                var t = this,
                    i = this._element.classList.contains("fade") ? "fade" : "";
                if (this._isShown && this._config.backdrop) {
                    if (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", i && this._backdrop.classList.add(i), document.body.appendChild(this._backdrop), B.on(this._element, "click.dismiss.bs.modal", (function(e) {
                            t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && ("static" === t._config.backdrop ? t._triggerBackdropTransition() : t.hide())
                        })), i && v(this._backdrop), this._backdrop.classList.add("show"), !i) return void e();
                    var n = h(this._backdrop);
                    B.one(this._backdrop, "transitionend", e), p(this._backdrop, n)
                } else if (!this._isShown && this._backdrop) {
                    this._backdrop.classList.remove("show");
                    var r = function() {
                        t._removeBackdrop(), e()
                    };
                    if (this._element.classList.contains("fade")) {
                        var o = h(this._backdrop);
                        B.one(this._backdrop, "transitionend", r), p(this._backdrop, o)
                    } else r()
                } else e()
            }, o._triggerBackdropTransition = function() {
                var e = this;
                if (!B.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
                    var t = this._element.scrollHeight > document.documentElement.clientHeight;
                    t || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static");
                    var i = h(this._dialog);
                    B.off(this._element, "transitionend"), B.one(this._element, "transitionend", (function() {
                        e._element.classList.remove("modal-static"), t || (B.one(e._element, "transitionend", (function() {
                            e._element.style.overflowY = ""
                        })), p(e._element, i))
                    })), p(this._element, i), this._element.focus()
                }
            }, o._adjustDialog = function() {
                var e = this._element.scrollHeight > document.documentElement.clientHeight;
                (!this._isBodyOverflowing && e && !x || this._isBodyOverflowing && !e && x) && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), (this._isBodyOverflowing && !e && !x || !this._isBodyOverflowing && e && x) && (this._element.style.paddingRight = this._scrollbarWidth + "px")
            }, o._resetAdjustments = function() {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
            }, o._checkScrollbar = function() {
                var e = document.body.getBoundingClientRect();
                this._isBodyOverflowing = Math.round(e.left + e.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
            }, o._setScrollbar = function() {
                var e = this;
                if (this._isBodyOverflowing) {
                    W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(t) {
                        var i = t.style.paddingRight,
                            n = window.getComputedStyle(t)["padding-right"];
                        V.setDataAttribute(t, "padding-right", i), t.style.paddingRight = Number.parseFloat(n) + e._scrollbarWidth + "px"
                    })), W.find(".sticky-top").forEach((function(t) {
                        var i = t.style.marginRight,
                            n = window.getComputedStyle(t)["margin-right"];
                        V.setDataAttribute(t, "margin-right", i), t.style.marginRight = Number.parseFloat(n) - e._scrollbarWidth + "px"
                    }));
                    var t = document.body.style.paddingRight,
                        i = window.getComputedStyle(document.body)["padding-right"];
                    V.setDataAttribute(document.body, "padding-right", t), document.body.style.paddingRight = Number.parseFloat(i) + this._scrollbarWidth + "px"
                }
                document.body.classList.add("modal-open")
            }, o._resetScrollbar = function() {
                W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(e) {
                    var t = V.getDataAttribute(e, "padding-right");
                    void 0 !== t && (V.removeDataAttribute(e, "padding-right"), e.style.paddingRight = t)
                })), W.find(".sticky-top").forEach((function(e) {
                    var t = V.getDataAttribute(e, "margin-right");
                    void 0 !== t && (V.removeDataAttribute(e, "margin-right"), e.style.marginRight = t)
                }));
                var e = V.getDataAttribute(document.body, "padding-right");
                void 0 === e ? document.body.style.paddingRight = "" : (V.removeDataAttribute(document.body, "padding-right"), document.body.style.paddingRight = e)
            }, o._getScrollbarWidth = function() {
                var e = document.createElement("div");
                e.className = "modal-scrollbar-measure", document.body.appendChild(e);
                var t = e.getBoundingClientRect().width - e.clientWidth;
                return document.body.removeChild(e), t
            }, r.jQueryInterface = function(e, t) {
                return this.each((function() {
                    var n = E(this, "bs.modal"),
                        o = i({}, bt, V.getDataAttributes(this), "object" == typeof e && e ? e : {});
                    if (n || (n = new r(this, o)), "string" == typeof e) {
                        if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"');
                        n[e](t)
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return bt
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.modal"
                }
            }]), r
        }(F);
    B.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function(e) {
        var t = this,
            n = c(this);
        "A" !== this.tagName && "AREA" !== this.tagName || e.preventDefault(), B.one(n, "show.bs.modal", (function(e) {
            e.defaultPrevented || B.one(n, "hidden.bs.modal", (function() {
                m(t) && t.focus()
            }))
        }));
        var r = E(n, "bs.modal");
        if (!r) {
            var o = i({}, V.getDataAttributes(n), V.getDataAttributes(this));
            r = new wt(n, o)
        }
        r.show(this)
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn.modal;
            e.fn.modal = wt.jQueryInterface, e.fn.modal.Constructor = wt, e.fn.modal.noConflict = function() {
                return e.fn.modal = t, wt.jQueryInterface
            }
        }
    }));
    var _t = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        Et = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
        Mt = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

    function Tt(e, t, i) {
        var n;
        if (!e.length) return e;
        if (i && "function" == typeof i) return i(e);
        for (var r = (new window.DOMParser).parseFromString(e, "text/html"), o = Object.keys(t), a = (n = []).concat.apply(n, r.body.querySelectorAll("*")), s = function(e, i) {
                var n, r = a[e],
                    s = r.nodeName.toLowerCase();
                if (!o.includes(s)) return r.parentNode.removeChild(r), "continue";
                var l = (n = []).concat.apply(n, r.attributes),
                    c = [].concat(t["*"] || [], t[s] || []);
                l.forEach((function(e) {
                    (function(e, t) {
                        var i = e.nodeName.toLowerCase();
                        if (t.includes(i)) return !_t.has(i) || Boolean(e.nodeValue.match(Et) || e.nodeValue.match(Mt));
                        for (var n = t.filter((function(e) {
                                return e instanceof RegExp
                            })), r = 0, o = n.length; r < o; r++)
                            if (i.match(n[r])) return !0;
                        return !1
                    })(e, c) || r.removeAttribute(e.nodeName)
                }))
            }, l = 0, c = a.length; l < c; l++) s(l);
        return r.body.innerHTML
    }
    var St = "tooltip",
        At = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
        Ct = new Set(["sanitize", "allowList", "sanitizeFn"]),
        Lt = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "(null|array)",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object)"
        },
        Dt = {
            AUTO: "auto",
            TOP: "top",
            RIGHT: x ? "left" : "right",
            BOTTOM: "bottom",
            LEFT: x ? "right" : "left"
        },
        Pt = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            selector: !1,
            placement: "top",
            container: !1,
            fallbackPlacements: null,
            boundary: "clippingParents",
            customClass: "",
            sanitize: !0,
            sanitizeFn: null,
            allowList: {
                "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            },
            popperConfig: null
        },
        Rt = {
            HIDE: "hide.bs.tooltip",
            HIDDEN: "hidden.bs.tooltip",
            SHOW: "show.bs.tooltip",
            SHOWN: "shown.bs.tooltip",
            INSERTED: "inserted.bs.tooltip",
            CLICK: "click.bs.tooltip",
            FOCUSIN: "focusin.bs.tooltip",
            FOCUSOUT: "focusout.bs.tooltip",
            MOUSEENTER: "mouseenter.bs.tooltip",
            MOUSELEAVE: "mouseleave.bs.tooltip"
        },
        Ot = function(e) {
            function r(t, i) {
                var n;
                if (void 0 === st) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                return (n = e.call(this, t) || this)._isEnabled = !0, n._timeout = 0, n._hoverState = "", n._activeTrigger = {}, n._popper = null, n.config = n._getConfig(i), n.tip = null, n._setListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.enable = function() {
                this._isEnabled = !0
            }, o.disable = function() {
                this._isEnabled = !1
            }, o.toggleEnabled = function() {
                this._isEnabled = !this._isEnabled
            }, o.toggle = function(e) {
                if (this._isEnabled)
                    if (e) {
                        var t = this.constructor.DATA_KEY,
                            i = E(e.delegateTarget, t);
                        i || (i = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, t, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i)
                    } else {
                        if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
                        this._enter(null, this)
                    }
            }, o.dispose = function() {
                clearTimeout(this._timeout), B.off(this._element, this.constructor.EVENT_KEY), B.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, e.prototype.dispose.call(this)
            }, o.show = function() {
                var e = this;
                if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                if (this.isWithContent() && this._isEnabled) {
                    var t = B.trigger(this._element, this.constructor.Event.SHOW),
                        i = function e(t) {
                            if (!document.documentElement.attachShadow) return null;
                            if ("function" == typeof t.getRootNode) {
                                var i = t.getRootNode();
                                return i instanceof ShadowRoot ? i : null
                            }
                            return t instanceof ShadowRoot ? t : t.parentNode ? e(t.parentNode) : null
                        }(this._element),
                        n = null === i ? this._element.ownerDocument.documentElement.contains(this._element) : i.contains(this._element);
                    if (t.defaultPrevented || !n) return;
                    var r = this.getTipElement(),
                        o = a(this.constructor.NAME);
                    r.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this.setContent(), this.config.animation && r.classList.add("fade");
                    var s = "function" == typeof this.config.placement ? this.config.placement.call(this, r, this._element) : this.config.placement,
                        l = this._getAttachment(s);
                    this._addAttachmentClass(l);
                    var c = this._getContainer();
                    _(r, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || c.appendChild(r), B.trigger(this._element, this.constructor.Event.INSERTED), this._popper = at(this._element, r, this._getPopperConfig(l)), r.classList.add("show");
                    var u, d, f = "function" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass;
                    f && (u = r.classList).add.apply(u, f.split(" ")), "ontouchstart" in document.documentElement && (d = []).concat.apply(d, document.body.children).forEach((function(e) {
                        B.on(e, "mouseover", (function() {}))
                    }));
                    var m = function() {
                        var t = e._hoverState;
                        e._hoverState = null, B.trigger(e._element, e.constructor.Event.SHOWN), "out" === t && e._leave(null, e)
                    };
                    if (this.tip.classList.contains("fade")) {
                        var g = h(this.tip);
                        B.one(this.tip, "transitionend", m), p(this.tip, g)
                    } else m()
                }
            }, o.hide = function() {
                var e = this;
                if (this._popper) {
                    var t = this.getTipElement(),
                        i = function() {
                            "show" !== e._hoverState && t.parentNode && t.parentNode.removeChild(t), e._cleanTipClass(), e._element.removeAttribute("aria-describedby"), B.trigger(e._element, e.constructor.Event.HIDDEN), e._popper && (e._popper.destroy(), e._popper = null)
                        };
                    if (!B.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {
                        var n;
                        if (t.classList.remove("show"), "ontouchstart" in document.documentElement && (n = []).concat.apply(n, document.body.children).forEach((function(e) {
                                return B.off(e, "mouseover", g)
                            })), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains("fade")) {
                            var r = h(t);
                            B.one(t, "transitionend", i), p(t, r)
                        } else i();
                        this._hoverState = ""
                    }
                }
            }, o.update = function() {
                null !== this._popper && this._popper.update()
            }, o.isWithContent = function() {
                return Boolean(this.getTitle())
            }, o.getTipElement = function() {
                if (this.tip) return this.tip;
                var e = document.createElement("div");
                return e.innerHTML = this.config.template, this.tip = e.children[0], this.tip
            }, o.setContent = function() {
                var e = this.getTipElement();
                this.setElementContent(W.findOne(".tooltip-inner", e), this.getTitle()), e.classList.remove("fade", "show")
            }, o.setElementContent = function(e, t) {
                if (null !== e) return "object" == typeof t && d(t) ? (t.jquery && (t = t[0]), void(this.config.html ? t.parentNode !== e && (e.innerHTML = "", e.appendChild(t)) : e.textContent = t.textContent)) : void(this.config.html ? (this.config.sanitize && (t = Tt(t, this.config.allowList, this.config.sanitizeFn)), e.innerHTML = t) : e.textContent = t)
            }, o.getTitle = function() {
                var e = this._element.getAttribute("data-bs-original-title");
                return e || (e = "function" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), e
            }, o.updateAttachment = function(e) {
                return "right" === e ? "end" : "left" === e ? "start" : e
            }, o._getPopperConfig = function(e) {
                var t = this,
                    n = {
                        name: "flip",
                        options: {
                            altBoundary: !0
                        }
                    };
                return this.config.fallbackPlacements && (n.options.fallbackPlacements = this.config.fallbackPlacements), i({}, {
                    placement: e,
                    modifiers: [n, {
                        name: "preventOverflow",
                        options: {
                            rootBoundary: this.config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: "." + this.constructor.NAME + "-arrow"
                        }
                    }, {
                        name: "onChange",
                        enabled: !0,
                        phase: "afterWrite",
                        fn: function(e) {
                            return t._handlePopperPlacementChange(e)
                        }
                    }],
                    onFirstUpdate: function(e) {
                        e.options.placement !== e.placement && t._handlePopperPlacementChange(e)
                    }
                }, this.config.popperConfig)
            }, o._addAttachmentClass = function(e) {
                this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(e))
            }, o._getContainer = function() {
                return !1 === this.config.container ? document.body : d(this.config.container) ? this.config.container : W.findOne(this.config.container)
            }, o._getAttachment = function(e) {
                return Dt[e.toUpperCase()]
            }, o._setListeners = function() {
                var e = this;
                this.config.trigger.split(" ").forEach((function(t) {
                    if ("click" === t) B.on(e._element, e.constructor.Event.CLICK, e.config.selector, (function(t) {
                        return e.toggle(t)
                    }));
                    else if ("manual" !== t) {
                        var i = "hover" === t ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN,
                            n = "hover" === t ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;
                        B.on(e._element, i, e.config.selector, (function(t) {
                            return e._enter(t)
                        })), B.on(e._element, n, e.config.selector, (function(t) {
                            return e._leave(t)
                        }))
                    }
                })), this._hideModalHandler = function() {
                    e._element && e.hide()
                }, B.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = i({}, this.config, {
                    trigger: "manual",
                    selector: ""
                }) : this._fixTitle()
            }, o._fixTitle = function() {
                var e = this._element.getAttribute("title"),
                    t = typeof this._element.getAttribute("data-bs-original-title");
                (e || "string" !== t) && (this._element.setAttribute("data-bs-original-title", e || ""), !e || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.setAttribute("title", ""))
            }, o._enter = function(e, t) {
                var i = this.constructor.DATA_KEY;
                (t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusin" === e.type ? "focus" : "hover"] = !0), t.getTipElement().classList.contains("show") || "show" === t._hoverState ? t._hoverState = "show" : (clearTimeout(t._timeout), t._hoverState = "show", t.config.delay && t.config.delay.show ? t._timeout = setTimeout((function() {
                    "show" === t._hoverState && t.show()
                }), t.config.delay.show) : t.show())
            }, o._leave = function(e, t) {
                var i = this.constructor.DATA_KEY;
                (t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusout" === e.type ? "focus" : "hover"] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = "out", t.config.delay && t.config.delay.hide ? t._timeout = setTimeout((function() {
                    "out" === t._hoverState && t.hide()
                }), t.config.delay.hide) : t.hide())
            }, o._isWithActiveTrigger = function() {
                for (var e in this._activeTrigger)
                    if (this._activeTrigger[e]) return !0;
                return !1
            }, o._getConfig = function(e) {
                var t = V.getDataAttributes(this._element);
                return Object.keys(t).forEach((function(e) {
                    Ct.has(e) && delete t[e]
                })), e && "object" == typeof e.container && e.container.jquery && (e.container = e.container[0]), "number" == typeof(e = i({}, this.constructor.Default, t, "object" == typeof e && e ? e : {})).delay && (e.delay = {
                    show: e.delay,
                    hide: e.delay
                }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), f(St, e, this.constructor.DefaultType), e.sanitize && (e.template = Tt(e.template, e.allowList, e.sanitizeFn)), e
            }, o._getDelegateConfig = function() {
                var e = {};
                if (this.config)
                    for (var t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]);
                return e
            }, o._cleanTipClass = function() {
                var e = this.getTipElement(),
                    t = e.getAttribute("class").match(At);
                null !== t && t.length > 0 && t.map((function(e) {
                    return e.trim()
                })).forEach((function(t) {
                    return e.classList.remove(t)
                }))
            }, o._handlePopperPlacementChange = function(e) {
                var t = e.state;
                t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement)))
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    var t = E(this, "bs.tooltip"),
                        i = "object" == typeof e && e;
                    if ((t || !/dispose|hide/.test(e)) && (t || (t = new r(this, i)), "string" == typeof e)) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return Pt
                }
            }, {
                key: "NAME",
                get: function() {
                    return St
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.tooltip"
                }
            }, {
                key: "Event",
                get: function() {
                    return Rt
                }
            }, {
                key: "EVENT_KEY",
                get: function() {
                    return ".bs.tooltip"
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return Lt
                }
            }]), r
        }(F);
    b((function() {
        var e = y();
        if (e) {
            var t = e.fn[St];
            e.fn[St] = Ot.jQueryInterface, e.fn[St].Constructor = Ot, e.fn[St].noConflict = function() {
                return e.fn[St] = t, Ot.jQueryInterface
            }
        }
    }));
    var It = "popover",
        zt = new RegExp("(^|\\s)bs-popover\\S+", "g"),
        Nt = i({}, Ot.Default, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }),
        Bt = i({}, Ot.DefaultType, {
            content: "(string|element|function)"
        }),
        Ft = {
            HIDE: "hide.bs.popover",
            HIDDEN: "hidden.bs.popover",
            SHOW: "show.bs.popover",
            SHOWN: "shown.bs.popover",
            INSERTED: "inserted.bs.popover",
            CLICK: "click.bs.popover",
            FOCUSIN: "focusin.bs.popover",
            FOCUSOUT: "focusout.bs.popover",
            MOUSEENTER: "mouseenter.bs.popover",
            MOUSELEAVE: "mouseleave.bs.popover"
        },
        kt = function(e) {
            function i() {
                return e.apply(this, arguments) || this
            }
            n(i, e);
            var r = i.prototype;
            return r.isWithContent = function() {
                return this.getTitle() || this._getContent()
            }, r.setContent = function() {
                var e = this.getTipElement();
                this.setElementContent(W.findOne(".popover-header", e), this.getTitle());
                var t = this._getContent();
                "function" == typeof t && (t = t.call(this._element)), this.setElementContent(W.findOne(".popover-body", e), t), e.classList.remove("fade", "show")
            }, r._addAttachmentClass = function(e) {
                this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(e))
            }, r._getContent = function() {
                return this._element.getAttribute("data-bs-content") || this.config.content
            }, r._cleanTipClass = function() {
                var e = this.getTipElement(),
                    t = e.getAttribute("class").match(zt);
                null !== t && t.length > 0 && t.map((function(e) {
                    return e.trim()
                })).forEach((function(t) {
                    return e.classList.remove(t)
                }))
            }, i.jQueryInterface = function(e) {
                return this.each((function() {
                    var t = E(this, "bs.popover"),
                        n = "object" == typeof e ? e : null;
                    if ((t || !/dispose|hide/.test(e)) && (t || (t = new i(this, n), _(this, "bs.popover", t)), "string" == typeof e)) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(i, null, [{
                key: "Default",
                get: function() {
                    return Nt
                }
            }, {
                key: "NAME",
                get: function() {
                    return It
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.popover"
                }
            }, {
                key: "Event",
                get: function() {
                    return Ft
                }
            }, {
                key: "EVENT_KEY",
                get: function() {
                    return ".bs.popover"
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return Bt
                }
            }]), i
        }(Ot);
    b((function() {
        var e = y();
        if (e) {
            var t = e.fn[It];
            e.fn[It] = kt.jQueryInterface, e.fn[It].Constructor = kt, e.fn[It].noConflict = function() {
                return e.fn[It] = t, kt.jQueryInterface
            }
        }
    }));
    var Ut = "scrollspy",
        Ht = {
            offset: 10,
            method: "auto",
            target: ""
        },
        Gt = {
            offset: "number",
            method: "string",
            target: "(string|element)"
        },
        jt = function(e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._scrollElement = "BODY" === t.tagName ? window : t, n._config = n._getConfig(i), n._selector = n._config.target + " .nav-link, " + n._config.target + " .list-group-item, " + n._config.target + " .dropdown-item", n._offsets = [], n._targets = [], n._activeTarget = null, n._scrollHeight = 0, B.on(n._scrollElement, "scroll.bs.scrollspy", (function(e) {
                    return n._process(e)
                })), n.refresh(), n._process(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.refresh = function() {
                var e = this,
                    t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
                    i = "auto" === this._config.method ? t : this._config.method,
                    n = "position" === i ? this._getScrollTop() : 0;
                this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), W.find(this._selector).map((function(e) {
                    var t = l(e),
                        r = t ? W.findOne(t) : null;
                    if (r) {
                        var o = r.getBoundingClientRect();
                        if (o.width || o.height) return [V[i](r).top + n, t]
                    }
                    return null
                })).filter((function(e) {
                    return e
                })).sort((function(e, t) {
                    return e[0] - t[0]
                })).forEach((function(t) {
                    e._offsets.push(t[0]), e._targets.push(t[1])
                }))
            }, o.dispose = function() {
                e.prototype.dispose.call(this), B.off(this._scrollElement, ".bs.scrollspy"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
            }, o._getConfig = function(e) {
                if ("string" != typeof(e = i({}, Ht, "object" == typeof e && e ? e : {})).target && d(e.target)) {
                    var t = e.target.id;
                    t || (t = a(Ut), e.target.id = t), e.target = "#" + t
                }
                return f(Ut, e, Gt), e
            }, o._getScrollTop = function() {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
            }, o._getScrollHeight = function() {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }, o._getOffsetHeight = function() {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
            }, o._process = function() {
                var e = this._getScrollTop() + this._config.offset,
                    t = this._getScrollHeight(),
                    i = this._config.offset + t - this._getOffsetHeight();
                if (this._scrollHeight !== t && this.refresh(), e >= i) {
                    var n = this._targets[this._targets.length - 1];
                    this._activeTarget !== n && this._activate(n)
                } else {
                    if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
                    for (var r = this._offsets.length; r--;) this._activeTarget !== this._targets[r] && e >= this._offsets[r] && (void 0 === this._offsets[r + 1] || e < this._offsets[r + 1]) && this._activate(this._targets[r])
                }
            }, o._activate = function(e) {
                this._activeTarget = e, this._clear();
                var t = this._selector.split(",").map((function(t) {
                        return t + '[data-bs-target="' + e + '"],' + t + '[href="' + e + '"]'
                    })),
                    i = W.findOne(t.join(","));
                i.classList.contains("dropdown-item") ? (W.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active"), i.classList.add("active")) : (i.classList.add("active"), W.parents(i, ".nav, .list-group").forEach((function(e) {
                    W.prev(e, ".nav-link, .list-group-item").forEach((function(e) {
                        return e.classList.add("active")
                    })), W.prev(e, ".nav-item").forEach((function(e) {
                        W.children(e, ".nav-link").forEach((function(e) {
                            return e.classList.add("active")
                        }))
                    }))
                }))), B.trigger(this._scrollElement, "activate.bs.scrollspy", {
                    relatedTarget: e
                })
            }, o._clear = function() {
                W.find(this._selector).filter((function(e) {
                    return e.classList.contains("active")
                })).forEach((function(e) {
                    return e.classList.remove("active")
                }))
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    var t = E(this, "bs.scrollspy");
                    if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function() {
                    return Ht
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.scrollspy"
                }
            }]), r
        }(F);
    B.on(window, "load.bs.scrollspy.data-api", (function() {
        W.find('[data-bs-spy="scroll"]').forEach((function(e) {
            return new jt(e, V.getDataAttributes(e))
        }))
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn[Ut];
            e.fn[Ut] = jt.jQueryInterface, e.fn[Ut].Constructor = jt, e.fn[Ut].noConflict = function() {
                return e.fn[Ut] = t, jt.jQueryInterface
            }
        }
    }));
    var Vt = function(e) {
        function i() {
            return e.apply(this, arguments) || this
        }
        n(i, e);
        var r = i.prototype;
        return r.show = function() {
            var e = this;
            if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active") || this._element.classList.contains("disabled"))) {
                var t, i = c(this._element),
                    n = this._element.closest(".nav, .list-group");
                if (n) {
                    var r = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active";
                    t = (t = W.find(r, n))[t.length - 1]
                }
                var o = null;
                if (t && (o = B.trigger(t, "hide.bs.tab", {
                        relatedTarget: this._element
                    })), !(B.trigger(this._element, "show.bs.tab", {
                        relatedTarget: t
                    }).defaultPrevented || null !== o && o.defaultPrevented)) {
                    this._activate(this._element, n);
                    var a = function() {
                        B.trigger(t, "hidden.bs.tab", {
                            relatedTarget: e._element
                        }), B.trigger(e._element, "shown.bs.tab", {
                            relatedTarget: t
                        })
                    };
                    i ? this._activate(i, i.parentNode, a) : a()
                }
            }
        }, r._activate = function(e, t, i) {
            var n = this,
                r = (!t || "UL" !== t.nodeName && "OL" !== t.nodeName ? W.children(t, ".active") : W.find(":scope > li > .active", t))[0],
                o = i && r && r.classList.contains("fade"),
                a = function() {
                    return n._transitionComplete(e, r, i)
                };
            if (r && o) {
                var s = h(r);
                r.classList.remove("show"), B.one(r, "transitionend", a), p(r, s)
            } else a()
        }, r._transitionComplete = function(e, t, i) {
            if (t) {
                t.classList.remove("active");
                var n = W.findOne(":scope > .dropdown-menu .active", t.parentNode);
                n && n.classList.remove("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !1)
            }
            e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), v(e), e.classList.contains("fade") && e.classList.add("show"), e.parentNode && e.parentNode.classList.contains("dropdown-menu") && (e.closest(".dropdown") && W.find(".dropdown-toggle").forEach((function(e) {
                return e.classList.add("active")
            })), e.setAttribute("aria-expanded", !0)), i && i()
        }, i.jQueryInterface = function(e) {
            return this.each((function() {
                var t = E(this, "bs.tab") || new i(this);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                    t[e]()
                }
            }))
        }, t(i, null, [{
            key: "DATA_KEY",
            get: function() {
                return "bs.tab"
            }
        }]), i
    }(F);
    B.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function(e) {
        e.preventDefault(), (E(this, "bs.tab") || new Vt(this)).show()
    })), b((function() {
        var e = y();
        if (e) {
            var t = e.fn.tab;
            e.fn.tab = Vt.jQueryInterface, e.fn.tab.Constructor = Vt, e.fn.tab.noConflict = function() {
                return e.fn.tab = t, Vt.jQueryInterface
            }
        }
    }));
    var Wt = {
            animation: "boolean",
            autohide: "boolean",
            delay: "number"
        },
        qt = {
            animation: !0,
            autohide: !0,
            delay: 5e3
        },
        Xt = function(e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._config = n._getConfig(i), n._timeout = null, n._setListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.show = function() {
                var e = this;
                if (!B.trigger(this._element, "show.bs.toast").defaultPrevented) {
                    this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
                    var t = function() {
                        e._element.classList.remove("showing"), e._element.classList.add("show"), B.trigger(e._element, "shown.bs.toast"), e._config.autohide && (e._timeout = setTimeout((function() {
                            e.hide()
                        }), e._config.delay))
                    };
                    if (this._element.classList.remove("hide"), v(this._element), this._element.classList.add("showing"), this._config.animation) {
                        var i = h(this._element);
                        B.one(this._element, "transitionend", t), p(this._element, i)
                    } else t()
                }
            }, o.hide = function() {
                var e = this;
                if (this._element.classList.contains("show") && !B.trigger(this._element, "hide.bs.toast").defaultPrevented) {
                    var t = function() {
                        e._element.classList.add("hide"), B.trigger(e._element, "hidden.bs.toast")
                    };
                    if (this._element.classList.remove("show"), this._config.animation) {
                        var i = h(this._element);
                        B.one(this._element, "transitionend", t), p(this._element, i)
                    } else t()
                }
            }, o.dispose = function() {
                this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), B.off(this._element, "click.dismiss.bs.toast"), e.prototype.dispose.call(this), this._config = null
            }, o._getConfig = function(e) {
                return e = i({}, qt, V.getDataAttributes(this._element), "object" == typeof e && e ? e : {}), f("toast", e, this.constructor.DefaultType), e
            }, o._setListeners = function() {
                var e = this;
                B.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', (function() {
                    return e.hide()
                }))
            }, o._clearTimeout = function() {
                clearTimeout(this._timeout), this._timeout = null
            }, r.jQueryInterface = function(e) {
                return this.each((function() {
                    var t = E(this, "bs.toast");
                    if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e](this)
                    }
                }))
            }, t(r, null, [{
                key: "DefaultType",
                get: function() {
                    return Wt
                }
            }, {
                key: "Default",
                get: function() {
                    return qt
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.toast"
                }
            }]), r
        }(F);
    return b((function() {
        var e = y();
        if (e) {
            var t = e.fn.toast;
            e.fn.toast = Xt.jQueryInterface, e.fn.toast.Constructor = Xt, e.fn.toast.noConflict = function() {
                return e.fn.toast = t, Xt.jQueryInterface
            }
        }
    })), {
        Alert: U,
        Button: H,
        Carousel: J,
        Collapse: ee,
        Dropdown: yt,
        Modal: wt,
        Popover: kt,
        ScrollSpy: jt,
        Tab: Vt,
        Toast: Xt,
        Tooltip: Ot
    }
})),
/**
 * jquery-circle-progress - jQuery Plugin to draw animated circular progress bars:
 * {@link http://kottenator.github.io/jquery-circle-progress/}
 *
 * @author Rostyslav Bryzgunov <kottenator@gmail.com>
 * @version 1.2.2
 * @licence MIT
 * @preserve
 */
function(e) {
    if ("function" == typeof define && define.amd) define(["jquery"], e);
    else if ("object" == typeof module && module.exports) {
        var t = require("jquery");
        e(t), module.exports = t
    } else e(jQuery)
}((function(e) {
    function t(e) {
        this.init(e)
    }
    t.prototype = {
        value: 0,
        size: 100,
        startAngle: -Math.PI,
        thickness: "auto",
        fill: {
            gradient: ["#3aeabb", "#fdd250"]
        },
        emptyFill: "rgba(0, 0, 0, .1)",
        animation: {
            duration: 1200,
            easing: "circleProgressEasing"
        },
        animationStartValue: 0,
        reverse: !1,
        lineCap: "butt",
        insertMode: "prepend",
        constructor: t,
        el: null,
        canvas: null,
        ctx: null,
        radius: 0,
        arcFill: null,
        lastFrameValue: 0,
        init: function(t) {
            e.extend(this, t), this.radius = this.size / 2, this.initWidget(), this.initFill(), this.draw(), this.el.trigger("circle-inited")
        },
        initWidget: function() {
            this.canvas || (this.canvas = e("<canvas>")["prepend" == this.insertMode ? "prependTo" : "appendTo"](this.el)[0]);
            var t = this.canvas;
            if (t.width = this.size, t.height = this.size, this.ctx = t.getContext("2d"), window.devicePixelRatio > 1) {
                var i = window.devicePixelRatio;
                t.style.width = t.style.height = this.size + "px", t.width = t.height = this.size * i, this.ctx.scale(i, i)
            }
        },
        initFill: function() {
            var t, i = this,
                n = this.fill,
                r = this.ctx,
                o = this.size;
            if (!n) throw Error("The fill is not specified!");
            if ("string" == typeof n && (n = {
                    color: n
                }), n.color && (this.arcFill = n.color), n.gradient) {
                var a = n.gradient;
                if (1 == a.length) this.arcFill = a[0];
                else if (a.length > 1) {
                    for (var s = n.gradientAngle || 0, l = n.gradientDirection || [o / 2 * (1 - Math.cos(s)), o / 2 * (1 + Math.sin(s)), o / 2 * (1 + Math.cos(s)), o / 2 * (1 - Math.sin(s))], c = r.createLinearGradient.apply(r, l), h = 0; h < a.length; h++) {
                        var u = a[h],
                            d = h / (a.length - 1);
                        e.isArray(u) && (d = u[1], u = u[0]), c.addColorStop(d, u)
                    }
                    this.arcFill = c
                }
            }
            n.image && (n.image instanceof Image ? t = n.image : (t = new Image).src = n.image, t.complete ? p() : t.onload = p);

            function p() {
                var n = e("<canvas>")[0];
                n.width = i.size, n.height = i.size, n.getContext("2d").drawImage(t, 0, 0, o, o), i.arcFill = i.ctx.createPattern(n, "no-repeat"), i.drawFrame(i.lastFrameValue)
            }
        },
        draw: function() {
            this.animation ? this.drawAnimated(this.value) : this.drawFrame(this.value)
        },
        drawFrame: function(e) {
            this.lastFrameValue = e, this.ctx.clearRect(0, 0, this.size, this.size), this.drawEmptyArc(e), this.drawArc(e)
        },
        drawArc: function(e) {
            if (0 !== e) {
                var t = this.ctx,
                    i = this.radius,
                    n = this.getThickness(),
                    r = this.startAngle;
                t.save(), t.beginPath(), this.reverse ? t.arc(i, i, i - n / 2, r - 2 * Math.PI * e, r) : t.arc(i, i, i - n / 2, r, r + 2 * Math.PI * e), t.lineWidth = n, t.lineCap = this.lineCap, t.strokeStyle = this.arcFill, t.stroke(), t.restore()
            }
        },
        drawEmptyArc: function(e) {
            var t = this.ctx,
                i = this.radius,
                n = this.getThickness(),
                r = this.startAngle;
            e < 1 && (t.save(), t.beginPath(), e <= 0 ? t.arc(i, i, i - n / 2, 0, 2 * Math.PI) : this.reverse ? t.arc(i, i, i - n / 2, r, r - 2 * Math.PI * e) : t.arc(i, i, i - n / 2, r + 2 * Math.PI * e, r), t.lineWidth = n, t.strokeStyle = this.emptyFill, t.stroke(), t.restore())
        },
        drawAnimated: function(t) {
            var i = this,
                n = this.el,
                r = e(this.canvas);
            r.stop(!0, !1), n.trigger("circle-animation-start"), r.css({
                animationProgress: 0
            }).animate({
                animationProgress: 1
            }, e.extend({}, this.animation, {
                step: function(e) {
                    var r = i.animationStartValue * (1 - e) + t * e;
                    i.drawFrame(r), n.trigger("circle-animation-progress", [e, r])
                }
            })).promise().always((function() {
                n.trigger("circle-animation-end")
            }))
        },
        getThickness: function() {
            return e.isNumeric(this.thickness) ? this.thickness : this.size / 14
        },
        getValue: function() {
            return this.value
        },
        setValue: function(e) {
            this.animation && (this.animationStartValue = this.lastFrameValue), this.value = e, this.draw()
        }
    }, e.circleProgress = {
        defaults: t.prototype
    }, e.easing.circleProgressEasing = function(e) {
        return e < .5 ? .5 * (e *= 2) * e * e : 1 - .5 * (e = 2 - 2 * e) * e * e
    }, e.fn.circleProgress = function(i, n) {
        var r = "circle-progress",
            o = this.data(r);
        if ("widget" == i) {
            if (!o) throw Error('Calling "widget" method on not initialized instance is forbidden');
            return o.canvas
        }
        if ("value" == i) {
            if (!o) throw Error('Calling "value" method on not initialized instance is forbidden');
            if (void 0 === n) return o.getValue();
            var a = arguments[1];
            return this.each((function() {
                e(this).data(r).setValue(a)
            }))
        }
        return this.each((function() {
            var n = e(this),
                o = n.data(r),
                a = e.isPlainObject(i) ? i : {};
            if (o) o.init(a);
            else {
                var s = e.extend({}, n.data());
                "string" == typeof s.fill && (s.fill = JSON.parse(s.fill)), "string" == typeof s.animation && (s.animation = JSON.parse(s.animation)), (a = e.extend(s, a)).el = n, o = new t(a), n.data(r, o)
            }
        }))
    }
})),
function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {})
}(this, (function(e) {
    "use strict";

    function t(e, t) {
        e.prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t
    }

    function i(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function n(e) {
        return "string" == typeof e
    }

    function r(e) {
        return "function" == typeof e
    }

    function o(e) {
        return "number" == typeof e
    }

    function a(e) {
        return void 0 === e
    }

    function s(e) {
        return "object" == typeof e
    }

    function l(e) {
        return !1 !== e
    }

    function c() {
        return "undefined" != typeof window
    }

    function h(e) {
        return r(e) || n(e)
    }

    function u(e) {
        return (ye = pt(e, rt)) && pi
    }

    function d(e, t) {
        return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
    }

    function p(e, t) {
        return !t && console.warn(e)
    }

    function f(e, t) {
        return e && (rt[e] = t) && ye && (ye[e] = t) || rt
    }

    function m() {
        return 0
    }

    function g(e) {
        var t, i, n = e[0];
        if (s(n) || r(n) || (e = [e]), !(t = (n._gsap || {}).harness)) {
            for (i = ut.length; i-- && !ut[i].targetTest(n););
            t = ut[i]
        }
        for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new Bt(e[i], t))) || e.splice(i, 1);
        return e
    }

    function v(e) {
        return e._gsap || g(xt(e))[0]._gsap
    }

    function y(e, t, i) {
        return (i = e[t]) && r(i) ? e[t]() : a(i) && e.getAttribute && e.getAttribute(t) || i
    }

    function b(e, t) {
        return (e = e.split(",")).forEach(t) || e
    }

    function x(e) {
        return Math.round(1e5 * e) / 1e5 || 0
    }

    function w(e, t) {
        for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i;);
        return n < i
    }

    function _() {
        var e, t, i = at.length,
            n = at.slice(0);
        for (st = {}, e = at.length = 0; e < i; e++)(t = n[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
    }

    function E(e, t, i, n) {
        at.length && _(), e.render(t, i, n), at.length && _()
    }

    function M(e) {
        var t = parseFloat(e);
        return (t || 0 === t) && (e + "").match(it).length < 2 ? t : n(e) ? e.trim() : e
    }

    function T(e) {
        return e
    }

    function S(e, t) {
        for (var i in t) i in e || (e[i] = t[i]);
        return e
    }

    function A(e, t) {
        for (var i in t) i in e || "duration" === i || "ease" === i || (e[i] = t[i])
    }

    function C(e, t) {
        for (var i in t) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = s(t[i]) ? C(e[i] || (e[i] = {}), t[i]) : t[i]);
        return e
    }

    function L(e, t) {
        var i, n = {};
        for (i in e) i in t || (n[i] = e[i]);
        return n
    }

    function D(e) {
        var t = e.parent || fe,
            i = e.keyframes ? A : S;
        if (l(e.inherit))
            for (; t;) i(e, t.vars.defaults), t = t.parent || t._dp;
        return e
    }

    function P(e, t, i, n) {
        void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
        var r = t._prev,
            o = t._next;
        r ? r._next = o : e[i] === t && (e[i] = o), o ? o._prev = r : e[n] === t && (e[n] = r), t._next = t._prev = t.parent = null
    }

    function R(e, t) {
        !e.parent || t && !e.parent.autoRemoveChildren || e.parent.remove(e), e._act = 0
    }

    function O(e, t) {
        if (e && (!t || t._end > e._dur || t._start < 0))
            for (var i = e; i;) i._dirty = 1, i = i.parent;
        return e
    }

    function I(e) {
        return e._repeat ? ft(e._tTime, e = e.duration() + e._rDelay) * e : 0
    }

    function z(e, t) {
        return (e - t._start) * t._ts + (0 <= t._ts ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    }

    function N(e) {
        return e._end = x(e._start + (e._tDur / Math.abs(e._ts || e._rts || Ge) || 0))
    }

    function B(e, t) {
        var i = e._dp;
        return i && i.smoothChildTiming && e._ts && (e._start = x(i._time - (0 < e._ts ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), N(e), i._dirty || O(i, e)), e
    }

    function F(e, t) {
        var i;
        if ((t._time || t._initted && !t._dur) && (i = z(e.rawTime(), t), (!t._dur || yt(0, t.totalDuration(), i) - t._tTime > Ge) && t.render(i, !0)), O(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
                for (i = e; i._dp;) 0 <= i.rawTime() && i.totalTime(i._tTime), i = i._dp;
            e._zTime = -Ge
        }
    }

    function k(e, t, i, n) {
        return t.parent && R(t), t._start = x((o(i) ? i : i || e !== fe ? vt(e, i, t) : e._time) + t._delay), t._end = x(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
            function(e, t, i, n, r) {
                void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                var o, a = e[n];
                if (r)
                    for (o = t[r]; a && a[r] > o;) a = a._prev;
                a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[n] = t, t._prev = a, t.parent = t._dp = e
            }(e, t, "_first", "_last", e._sort ? "_start" : 0), mt(t) || (e._recent = t), n || F(e, t), e
    }

    function U(e, t) {
        return (rt.ScrollTrigger || d("scrollTrigger", t)) && rt.ScrollTrigger.create(t, e)
    }

    function H(e, t, i, n) {
        return Vt(e, t), e._initted ? !i && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && xe !== At.frame ? (at.push(e), e._lazy = [t, n], 1) : void 0 : 1
    }

    function G(e, t, i, n) {
        var r = e._repeat,
            o = x(t) || 0,
            a = e._tTime / e._tDur;
        return a && !n && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : x(o * (r + 1) + e._rDelay * r) : o, a && !n ? B(e, e._tTime = e._tDur * a) : e.parent && N(e), i || O(e.parent, e), e
    }

    function j(e) {
        return e instanceof Ut ? O(e) : G(e, e._dur)
    }

    function V(e, t, i) {
        var n, r, a = o(t[1]),
            s = (a ? 2 : 1) + (e < 2 ? 0 : 1),
            c = t[s];
        if (a && (c.duration = t[1]), c.parent = i, e) {
            for (n = c, r = i; r && !("immediateRender" in n);) n = r.vars.defaults || {}, r = l(r.vars.inherit) && r.parent;
            c.immediateRender = l(n.immediateRender), e < 2 ? c.runBackwards = 1 : c.startAt = t[s - 1]
        }
        return new Yt(t[0], c, t[1 + s])
    }

    function W(e, t) {
        return e || 0 === e ? t(e) : t
    }

    function q(e) {
        if ("string" != typeof e) return "";
        var t = nt.exec(e);
        return t ? e.substr(t.index + t[0].length) : ""
    }

    function X(e, t) {
        return e && s(e) && "length" in e && (!t && !e.length || e.length - 1 in e && s(e[0])) && !e.nodeType && e !== me
    }

    function Y(e) {
        return e.sort((function() {
            return .5 - Math.random()
        }))
    }

    function Z(e) {
        if (r(e)) return e;
        var t = s(e) ? e : {
                each: e
            },
            i = Ot(t.ease),
            o = t.from || 0,
            a = parseFloat(t.base) || 0,
            l = {},
            c = 0 < o && o < 1,
            h = isNaN(o) || c,
            u = t.axis,
            d = o,
            p = o;
        return n(o) ? d = p = {
                center: .5,
                edges: .5,
                end: 1
            } [o] || 0 : !c && h && (d = o[0], p = o[1]),
            function(e, n, r) {
                var s, c, f, m, g, v, y, b, w, _ = (r || t).length,
                    E = l[_];
                if (!E) {
                    if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, He])[1])) {
                        for (y = -He; y < (y = r[w++].getBoundingClientRect().left) && w < _;);
                        w--
                    }
                    for (E = l[_] = [], s = h ? Math.min(w, _) * d - .5 : o % w, c = h ? _ * p / w - .5 : o / w | 0, b = He, v = y = 0; v < _; v++) f = v % w - s, m = c - (v / w | 0), E[v] = g = u ? Math.abs("y" === u ? m : f) : qe(f * f + m * m), y < g && (y = g), g < b && (b = g);
                    "random" === o && Y(E), E.max = y - b, E.min = b, E.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (_ < w ? _ - 1 : u ? "y" === u ? _ / w : w : Math.max(w, _ / w)) || 0) * ("edges" === o ? -1 : 1), E.b = _ < 0 ? a - _ : a, E.u = q(t.amount || t.each) || 0, i = i && _ < 0 ? Rt(i) : i
                }
                return _ = (E[e] - E.min) / E.max || 0, x(E.b + (i ? i(_) : _) * E.v) + E.u
            }
    }

    function J(e) {
        var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
        return function(i) {
            var n = Math.round(parseFloat(i) / e) * e * t;
            return (n - n % 1) / t + (o(i) ? 0 : q(i))
        }
    }

    function Q(e, t) {
        var i, n, a = Je(e);
        return !a && s(e) && (i = a = e.radius || He, e.values ? (e = xt(e.values), (n = !o(e[0])) && (i *= i)) : e = J(e.increment)), W(t, a ? r(e) ? function(t) {
            return n = e(t), Math.abs(n - t) <= i ? n : t
        } : function(t) {
            for (var r, a, s = parseFloat(n ? t.x : t), l = parseFloat(n ? t.y : 0), c = He, h = 0, u = e.length; u--;)(r = n ? (r = e[u].x - s) * r + (a = e[u].y - l) * a : Math.abs(e[u] - s)) < c && (c = r, h = u);
            return h = !i || c <= i ? e[h] : t, n || h === t || o(t) ? h : h + q(t)
        } : J(e))
    }

    function $(e, t, i, n) {
        return W(Je(e) ? !t : !0 === i ? !!(i = 0) : !n, (function() {
            return Je(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + .99 * i)) / i) * i * n) / n
        }))
    }

    function K(e, t, i) {
        return W(i, (function(i) {
            return e[~~t(i)]
        }))
    }

    function ee(e) {
        for (var t, i, n, r, o = 0, a = ""; ~(t = e.indexOf("random(", o));) n = e.indexOf(")", t), r = "[" === e.charAt(t + 7), i = e.substr(t + 7, n - t - 7).match(r ? it : Qe), a += e.substr(o, t - o) + $(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), o = n + 1;
        return a + e.substr(o, e.length - o)
    }

    function te(e, t, i) {
        var n, r, o, a = e.labels,
            s = He;
        for (n in a)(r = a[n] - t) < 0 == !!i && r && s > (r = Math.abs(r)) && (o = n, s = r);
        return o
    }

    function ie(e) {
        return R(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && _t(e, "onInterrupt"), e
    }

    function ne(e, t, i) {
        return (6 * (e = e < 0 ? e + 1 : 1 < e ? e - 1 : e) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Et + .5 | 0
    }

    function re(e, t, i) {
        var n, r, a, s, l, c, h, u, d, p, f = e ? o(e) ? [e >> 16, e >> 8 & Et, e & Et] : 0 : Mt.black;
        if (!f) {
            if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Mt[e]) f = Mt[e];
            else if ("#" === e.charAt(0)) {
                if (e.length < 6 && (e = "#" + (n = e.charAt(1)) + n + (r = e.charAt(2)) + r + (a = e.charAt(3)) + a + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(f = parseInt(e.substr(1, 6), 16)) >> 16, f >> 8 & Et, f & Et, parseInt(e.substr(7), 16) / 255];
                f = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & Et, e & Et]
            } else if ("hsl" === e.substr(0, 3))
                if (f = p = e.match(Qe), t) {
                    if (~e.indexOf("=")) return f = e.match($e), i && f.length < 4 && (f[3] = 1), f
                } else s = +f[0] % 360 / 360, l = f[1] / 100, n = 2 * (c = f[2] / 100) - (r = c <= .5 ? c * (l + 1) : c + l - c * l), 3 < f.length && (f[3] *= 1), f[0] = ne(s + 1 / 3, n, r), f[1] = ne(s, n, r), f[2] = ne(s - 1 / 3, n, r);
            else f = e.match(Qe) || Mt.transparent;
            f = f.map(Number)
        }
        return t && !p && (n = f[0] / Et, r = f[1] / Et, a = f[2] / Et, c = ((h = Math.max(n, r, a)) + (u = Math.min(n, r, a))) / 2, h === u ? s = l = 0 : (d = h - u, l = .5 < c ? d / (2 - h - u) : d / (h + u), s = h === n ? (r - a) / d + (r < a ? 6 : 0) : h === r ? (a - n) / d + 2 : (n - r) / d + 4, s *= 60), f[0] = ~~(s + .5), f[1] = ~~(100 * l + .5), f[2] = ~~(100 * c + .5)), i && f.length < 4 && (f[3] = 1), f
    }

    function oe(e) {
        var t = [],
            i = [],
            n = -1;
        return e.split(Tt).forEach((function(e) {
            var r = e.match(Ke) || [];
            t.push.apply(t, r), i.push(n += r.length + 1)
        })), t.c = i, t
    }

    function ae(e, t, i) {
        var n, r, o, a, s = "",
            l = (e + s).match(Tt),
            c = t ? "hsla(" : "rgba(",
            h = 0;
        if (!l) return e;
        if (l = l.map((function(e) {
                return (e = re(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
            })), i && (o = oe(e), (n = i.c).join(s) !== o.c.join(s)))
            for (a = (r = e.replace(Tt, "1").split(Ke)).length - 1; h < a; h++) s += r[h] + (~n.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : i).shift());
        if (!r)
            for (a = (r = e.split(Tt)).length - 1; h < a; h++) s += r[h] + l[h];
        return s + r[a]
    }

    function se(e) {
        var t, i = e.join(" ");
        if (Tt.lastIndex = 0, Tt.test(i)) return t = St.test(i), e[1] = ae(e[1], t), e[0] = ae(e[0], t, oe(e[1])), !0
    }

    function le(e, t) {
        for (var i, n = e._first; n;) n instanceof Ut ? le(n, t) : !n.vars.yoyoEase || n._yoyo && n._repeat || n._yoyo === t || (n.timeline ? le(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
    }

    function ce(e, t, i, n) {
        void 0 === i && (i = function(e) {
            return 1 - t(1 - e)
        }), void 0 === n && (n = function(e) {
            return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
        });
        var r, o = {
            easeIn: t,
            easeOut: i,
            easeInOut: n
        };
        return b(e, (function(e) {
            for (var t in Lt[e] = rt[e] = o, Lt[r = e.toLowerCase()] = i, o) Lt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Lt[e + "." + t] = o[t]
        })), o
    }

    function he(e) {
        return function(t) {
            return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
        }
    }

    function ue(e, t, i) {
        function n(e) {
            return 1 === e ? 1 : r * Math.pow(2, -10 * e) * Ye((e - a) * o) + 1
        }
        var r = 1 <= t ? t : 1,
            o = (i || (e ? .3 : .45)) / (t < 1 ? t : 1),
            a = o / je * (Math.asin(1 / r) || 0),
            s = "out" === e ? n : "in" === e ? function(e) {
                return 1 - n(1 - e)
            } : he(n);
        return o = je / o, s.config = function(t, i) {
            return ue(e, t, i)
        }, s
    }

    function de(e, t) {
        function i(e) {
            return e ? --e * e * ((t + 1) * e + t) + 1 : 0
        }
        void 0 === t && (t = 1.70158);
        var n = "out" === e ? i : "in" === e ? function(e) {
            return 1 - i(1 - e)
        } : he(i);
        return n.config = function(t) {
            return de(e, t)
        }, n
    }
    var pe, fe, me, ge, ve, ye, be, xe, we, _e, Ee, Me, Te, Se, Ae, Ce, Le, De, Pe, Re, Oe, Ie, ze, Ne, Be, Fe, ke = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Ue = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        He = 1e8,
        Ge = 1 / He,
        je = 2 * Math.PI,
        Ve = je / 4,
        We = 0,
        qe = Math.sqrt,
        Xe = Math.cos,
        Ye = Math.sin,
        Ze = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
        Je = Array.isArray,
        Qe = /(?:-?\.?\d|\.)+/gi,
        $e = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        Ke = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        et = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        tt = /[+-]=-?[.\d]+/,
        it = /[^,'"\[\]\s]+/gi,
        nt = /[\d.+\-=]+(?:e[-+]\d*)*/i,
        rt = {},
        ot = {},
        at = [],
        st = {},
        lt = {},
        ct = {},
        ht = 30,
        ut = [],
        dt = "",
        pt = function(e, t) {
            for (var i in t) e[i] = t[i];
            return e
        },
        ft = function(e, t) {
            var i = Math.floor(e /= t);
            return e && i === e ? i - 1 : i
        },
        mt = function(e) {
            var t = e.data;
            return "isFromStart" === t || "isStart" === t
        },
        gt = {
            _start: 0,
            endTime: m,
            totalDuration: m
        },
        vt = function e(t, i, r) {
            var o, a, s, l = t.labels,
                c = t._recent || gt,
                h = t.duration() >= He ? c.endTime(!1) : t._dur;
            return n(i) && (isNaN(i) || i in l) ? (a = i.charAt(0), s = "%" === i.substr(-1), o = i.indexOf("="), "<" === a || ">" === a ? (0 <= o && (i = i.replace(/=/, "")), ("<" === a ? c._start : c.endTime(0 <= c._repeat)) + (parseFloat(i.substr(1)) || 0) * (s ? (o < 0 ? c : r).totalDuration() / 100 : 1)) : o < 0 ? (i in l || (l[i] = h), l[i]) : (a = parseFloat(i.charAt(o - 1) + i.substr(o + 1)), s && r && (a = a / 100 * (Je(r) ? r[0] : r).totalDuration()), 1 < o ? e(t, i.substr(0, o - 1), r) + a : h + a)) : null == i ? h : +i
        },
        yt = function(e, t, i) {
            return i < e ? e : t < i ? t : i
        },
        bt = [].slice,
        xt = function(e, t, i) {
            return !n(e) || i || !ge && Ct() ? Je(e) ? function(e, t, i) {
                return void 0 === i && (i = []), e.forEach((function(e) {
                    return n(e) && !t || X(e, 1) ? i.push.apply(i, xt(e)) : i.push(e)
                })) || i
            }(e, i) : X(e) ? bt.call(e, 0) : e ? [e] : [] : bt.call((t || ve).querySelectorAll(e), 0)
        },
        wt = function(e, t, i, n, r) {
            var o = t - e,
                a = n - i;
            return W(r, (function(t) {
                return i + ((t - e) / o * a || 0)
            }))
        },
        _t = function(e, t, i) {
            var n, r, o = e.vars,
                a = o[t];
            if (a) return n = o[t + "Params"], r = o.callbackScope || e, i && at.length && _(), n ? a.apply(r, n) : a.call(r)
        },
        Et = 255,
        Mt = {
            aqua: [0, Et, Et],
            lime: [0, Et, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, Et],
            navy: [0, 0, 128],
            white: [Et, Et, Et],
            olive: [128, 128, 0],
            yellow: [Et, Et, 0],
            orange: [Et, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [Et, 0, 0],
            pink: [Et, 192, 203],
            cyan: [0, Et, Et],
            transparent: [Et, Et, Et, 0]
        },
        Tt = function() {
            var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (e in Mt) t += "|" + e + "\\b";
            return new RegExp(t + ")", "gi")
        }(),
        St = /hsl[a]?\(/,
        At = (Le = Date.now, De = 500, Pe = 33, Re = Le(), Oe = Re, ze = Ie = 1e3 / 240, Se = {
            time: 0,
            frame: 0,
            tick: function() {
                It(!0)
            },
            deltaRatio: function(e) {
                return Ae / (1e3 / (e || 60))
            },
            wake: function() {
                be && (!ge && c() && (me = ge = window, ve = me.document || {}, rt.gsap = pi, (me.gsapVersions || (me.gsapVersions = [])).push(pi.version), u(ye || me.GreenSockGlobals || !me.gsap && me || {}), Te = me.requestAnimationFrame), Ee && Se.sleep(), Me = Te || function(e) {
                    return setTimeout(e, ze - 1e3 * Se.time + 1 | 0)
                }, _e = 1, It(2))
            },
            sleep: function() {
                (Te ? me.cancelAnimationFrame : clearTimeout)(Ee), _e = 0, Me = m
            },
            lagSmoothing: function(e, t) {
                De = e || 1e8, Pe = Math.min(t, De, 0)
            },
            fps: function(e) {
                Ie = 1e3 / (e || 240), ze = 1e3 * Se.time + Ie
            },
            add: function(e) {
                Ne.indexOf(e) < 0 && Ne.push(e), Ct()
            },
            remove: function(e) {
                var t;
                ~(t = Ne.indexOf(e)) && Ne.splice(t, 1) && t <= Ce && Ce--
            },
            _listeners: Ne = []
        }),
        Ct = function() {
            return !_e && At.wake()
        },
        Lt = {},
        Dt = /^[\d.\-M][\d.\-,\s]/,
        Pt = /["']/g,
        Rt = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        Ot = function(e, t) {
            return e && (r(e) ? e : Lt[e] || function(e) {
                var t = (e + "").split("("),
                    i = Lt[t[0]];
                return i && 1 < t.length && i.config ? i.config.apply(null, ~e.indexOf("{") ? [function(e) {
                    for (var t, i, n, r = {}, o = e.substr(1, e.length - 3).split(":"), a = o[0], s = 1, l = o.length; s < l; s++) i = o[s], t = s !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, t), r[a] = isNaN(n) ? n.replace(Pt, "").trim() : +n, a = i.substr(t + 1).trim();
                    return r
                }(t[1])] : function(e) {
                    var t = e.indexOf("(") + 1,
                        i = e.indexOf(")"),
                        n = e.indexOf("(", t);
                    return e.substring(t, ~n && n < i ? e.indexOf(")", i + 1) : i)
                }(e).split(",").map(M)) : Lt._CE && Dt.test(e) ? Lt._CE("", e) : i
            }(e)) || t
        };

    function It(e) {
        var t, i, n, r, o = Le() - Oe,
            a = !0 === e;
        if (De < o && (Re += o - Pe), (0 < (t = (n = (Oe += o) - Re) - ze) || a) && (r = ++Se.frame, Ae = n - 1e3 * Se.time, Se.time = n /= 1e3, ze += t + (Ie <= t ? 4 : Ie - t), i = 1), a || (Ee = Me(It)), i)
            for (Ce = 0; Ce < Ne.length; Ce++) Ne[Ce](n, Ae, r, e)
    }

    function zt(e) {
        return e < Fe ? Be * e * e : e < .7272727272727273 ? Be * Math.pow(e - 1.5 / 2.75, 2) + .75 : e < .9090909090909092 ? Be * (e -= 2.25 / 2.75) * e + .9375 : Be * Math.pow(e - 2.625 / 2.75, 2) + .984375
    }
    b("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
        var i = t < 5 ? t + 1 : t;
        ce(e + ",Power" + (i - 1), t ? function(e) {
            return Math.pow(e, i)
        } : function(e) {
            return e
        }, (function(e) {
            return 1 - Math.pow(1 - e, i)
        }), (function(e) {
            return e < .5 ? Math.pow(2 * e, i) / 2 : 1 - Math.pow(2 * (1 - e), i) / 2
        }))
    })), Lt.Linear.easeNone = Lt.none = Lt.Linear.easeIn, ce("Elastic", ue("in"), ue("out"), ue()), Be = 7.5625, Fe = 1 / 2.75, ce("Bounce", (function(e) {
        return 1 - zt(1 - e)
    }), zt), ce("Expo", (function(e) {
        return e ? Math.pow(2, 10 * (e - 1)) : 0
    })), ce("Circ", (function(e) {
        return -(qe(1 - e * e) - 1)
    })), ce("Sine", (function(e) {
        return 1 === e ? 1 : 1 - Xe(e * Ve)
    })), ce("Back", de("in"), de("out"), de()), Lt.SteppedEase = Lt.steps = rt.SteppedEase = {
        config: function(e, t) {
            void 0 === e && (e = 1);
            var i = 1 / e,
                n = e + (t ? 0 : 1),
                r = t ? 1 : 0;
            return function(e) {
                return ((n * yt(0, .99999999, e) | 0) + r) * i
            }
        }
    }, Ue.ease = Lt["quad.out"], b("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
        return dt += e + "," + e + "Params,"
    }));
    var Nt, Bt = function(e, t) {
            this.id = We++, (e._gsap = this).target = e, this.harness = t, this.get = t ? t.get : y, this.set = t ? t.getSetter : ei
        },
        Ft = ((Nt = kt.prototype).delay = function(e) {
            return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
        }, Nt.duration = function(e) {
            return arguments.length ? this.totalDuration(0 < this._repeat ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
        }, Nt.totalDuration = function(e) {
            return arguments.length ? (this._dirty = 0, G(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, Nt.totalTime = function(e, t) {
            if (Ct(), !arguments.length) return this._tTime;
            var i = this._dp;
            if (i && i.smoothChildTiming && this._ts) {
                for (B(this, e), !i._dp || i.parent || F(i, this); i.parent;) i.parent._time !== i._start + (0 <= i._ts ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && e < this._tDur || this._ts < 0 && 0 < e || !this._tDur && !e) && k(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === Ge || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), E(this, e, t)), this
        }, Nt.time = function(e, t) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + I(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
        }, Nt.totalProgress = function(e, t) {
            return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }, Nt.progress = function(e, t) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + I(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }, Nt.iteration = function(e, t) {
            var i = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (e - 1) * i, t) : this._repeat ? ft(this._tTime, i) + 1 : 1
        }, Nt.timeScale = function(e) {
            if (!arguments.length) return this._rts === -Ge ? 0 : this._rts;
            if (this._rts === e) return this;
            var t = this.parent && this._ts ? z(this.parent._time, this) : this._tTime;
            return this._rts = +e || 0, this._ts = this._ps || e === -Ge ? 0 : this._rts,
                function(e) {
                    for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                    return e
                }(this.totalTime(yt(-this._delay, this._tDur, t), !0))
        }, Nt.paused = function(e) {
            return arguments.length ? (this._ps !== e && ((this._ps = e) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ct(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Ge && (this._tTime -= Ge)))), this) : this._ps
        }, Nt.startTime = function(e) {
            if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return !t || !t._sort && this.parent || k(t, this, e - this._delay), this
            }
            return this._start
        }, Nt.endTime = function(e) {
            return this._start + (l(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
        }, Nt.rawTime = function(e) {
            var t = this.parent || this._dp;
            return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? z(t.rawTime(e), this) : this._tTime : this._tTime
        }, Nt.globalTime = function(e) {
            for (var t = this, i = arguments.length ? e : t.rawTime(); t;) i = t._start + i / (t._ts || 1), t = t._dp;
            return i
        }, Nt.repeat = function(e) {
            return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, j(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }, Nt.repeatDelay = function(e) {
            if (arguments.length) {
                var t = this._time;
                return this._rDelay = e, j(this), t ? this.time(t) : this
            }
            return this._rDelay
        }, Nt.yoyo = function(e) {
            return arguments.length ? (this._yoyo = e, this) : this._yoyo
        }, Nt.seek = function(e, t) {
            return this.totalTime(vt(this, e), l(t))
        }, Nt.restart = function(e, t) {
            return this.play().totalTime(e ? -this._delay : 0, l(t))
        }, Nt.play = function(e, t) {
            return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
        }, Nt.reverse = function(e, t) {
            return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
        }, Nt.pause = function(e, t) {
            return null != e && this.seek(e, t), this.paused(!0)
        }, Nt.resume = function() {
            return this.paused(!1)
        }, Nt.reversed = function(e) {
            return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -Ge : 0)), this) : this._rts < 0
        }, Nt.invalidate = function() {
            return this._initted = this._act = 0, this._zTime = -Ge, this
        }, Nt.isActive = function() {
            var e, t = this.parent || this._dp,
                i = this._start;
            return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= i && e < this.endTime(!0) - Ge))
        }, Nt.eventCallback = function(e, t, i) {
            var n = this.vars;
            return 1 < arguments.length ? (t ? (n[e] = t, i && (n[e + "Params"] = i), "onUpdate" === e && (this._onUpdate = t)) : delete n[e], this) : n[e]
        }, Nt.then = function(e) {
            var t = this;
            return new Promise((function(i) {
                function n() {
                    var e = t.then;
                    t.then = null, r(o) && (o = o(t)) && (o.then || o === t) && (t.then = e), i(o), t.then = e
                }
                var o = r(e) ? e : T;
                t._initted && 1 === t.totalProgress() && 0 <= t._ts || !t._tTime && t._ts < 0 ? n() : t._prom = n
            }))
        }, Nt.kill = function() {
            ie(this)
        }, kt);

    function kt(e) {
        this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, G(this, +e.duration, 1, 1), this.data = e.data, _e || At.wake()
    }
    S(Ft.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -Ge,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Ut = function(e) {
        function a(t, n) {
            var r;
            return void 0 === t && (t = {}), (r = e.call(this, t) || this).labels = {}, r.smoothChildTiming = !!t.smoothChildTiming, r.autoRemoveChildren = !!t.autoRemoveChildren, r._sort = l(t.sortChildren), fe && k(t.parent || fe, i(r), n), t.reversed && r.reverse(), t.paused && r.paused(!0), t.scrollTrigger && U(i(r), t.scrollTrigger), r
        }
        t(a, e);
        var s = a.prototype;
        return s.to = function(e, t, i) {
            return V(0, arguments, this), this
        }, s.from = function(e, t, i) {
            return V(1, arguments, this), this
        }, s.fromTo = function(e, t, i, n) {
            return V(2, arguments, this), this
        }, s.set = function(e, t, i) {
            return t.duration = 0, t.parent = this, D(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new Yt(e, t, vt(this, i), 1), this
        }, s.call = function(e, t, i) {
            return k(this, Yt.delayedCall(0, e, t), i)
        }, s.staggerTo = function(e, t, i, n, r, o, a) {
            return i.duration = t, i.stagger = i.stagger || n, i.onComplete = o, i.onCompleteParams = a, i.parent = this, new Yt(e, i, vt(this, r)), this
        }, s.staggerFrom = function(e, t, i, n, r, o, a) {
            return i.runBackwards = 1, D(i).immediateRender = l(i.immediateRender), this.staggerTo(e, t, i, n, r, o, a)
        }, s.staggerFromTo = function(e, t, i, n, r, o, a, s) {
            return n.startAt = i, D(n).immediateRender = l(n.immediateRender), this.staggerTo(e, t, n, r, o, a, s)
        }, s.render = function(e, t, i) {
            var n, r, o, a, s, l, c, h, u, d, p, f, m = this._time,
                g = this._dirty ? this.totalDuration() : this._tDur,
                v = this._dur,
                y = this !== fe && g - Ge < e && 0 <= e ? g : e < Ge ? 0 : e,
                b = this._zTime < 0 != e < 0 && (this._initted || !v);
            if (y !== this._tTime || i || b) {
                if (m !== this._time && v && (y += this._time - m, e += this._time - m), n = y, u = this._start, l = !(h = this._ts), b && (v || (m = this._zTime), !e && t || (this._zTime = e)), this._repeat) {
                    if (p = this._yoyo, s = v + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * s + e, t, i);
                    if (n = x(y % s), y === g ? (a = this._repeat, n = v) : ((a = ~~(y / s)) && a === y / s && (n = v, a--), v < n && (n = v)), d = ft(this._tTime, s), !m && this._tTime && d !== a && (d = a), p && 1 & a && (n = v - n, f = 1), a !== d && !this._lock) {
                        var w = p && 1 & d,
                            _ = w === (p && 1 & a);
                        if (a < d && (w = !w), m = w ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : x(a * s)), t, !v)._lock = 0, this._tTime = y, !t && this.parent && _t(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l != !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (v = this._dur, g = this._tDur, _ && (this._lock = 2, m = w ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        le(this, f)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, i) {
                        var n;
                        if (t < i)
                            for (n = e._first; n && n._start <= i;) {
                                if (!n._dur && "isPause" === n.data && n._start > t) return n;
                                n = n._next
                            } else
                                for (n = e._last; n && n._start >= i;) {
                                    if (!n._dur && "isPause" === n.data && n._start < t) return n;
                                    n = n._prev
                                }
                    }(this, x(m), x(n))) && (y -= n - (n = c._start)), this._tTime = y, this._time = n, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, m = 0), !m && n && !t && (_t(this, "onStart"), this._tTime !== y)) return this;
                if (m <= n && 0 <= e)
                    for (r = this._first; r;) {
                        if (o = r._next, (r._act || n >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this) return this.render(e, t, i);
                            if (r.render(0 < r._ts ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, t, i), n !== this._time || !this._ts && !l) {
                                c = 0, o && (y += this._zTime = -Ge);
                                break
                            }
                        }
                        r = o
                    } else {
                        r = this._last;
                        for (var E = e < 0 ? e : n; r;) {
                            if (o = r._prev, (r._act || E <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(e, t, i);
                                if (r.render(0 < r._ts ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, i), n !== this._time || !this._ts && !l) {
                                    c = 0, o && (y += this._zTime = E ? -Ge : Ge);
                                    break
                                }
                            }
                            r = o
                        }
                    }
                if (c && !t && (this.pause(), c.render(m <= n ? 0 : -Ge)._zTime = m <= n ? 1 : -1, this._ts)) return this._start = u, N(this), this.render(e, t, i);
                this._onUpdate && !t && _t(this, "onUpdate", !0), (y === g && g >= this.totalDuration() || !y && m) && (u !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || (!e && v || !(y === g && 0 < this._ts || !y && this._ts < 0) || R(this, 1), t || e < 0 && !m || !y && !m && g || (_t(this, y === g && 0 <= e ? "onComplete" : "onReverseComplete", !0), !this._prom || y < g && 0 < this.timeScale() || this._prom())))
            }
            return this
        }, s.add = function(e, t) {
            var i = this;
            if (o(t) || (t = vt(this, t, e)), !(e instanceof Ft)) {
                if (Je(e)) return e.forEach((function(e) {
                    return i.add(e, t)
                })), this;
                if (n(e)) return this.addLabel(e, t);
                if (!r(e)) return this;
                e = Yt.delayedCall(0, e)
            }
            return this !== e ? k(this, e, t) : this
        }, s.getChildren = function(e, t, i, n) {
            void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === i && (i = !0), void 0 === n && (n = -He);
            for (var r = [], o = this._first; o;) o._start >= n && (o instanceof Yt ? t && r.push(o) : (i && r.push(o), e && r.push.apply(r, o.getChildren(!0, t, i)))), o = o._next;
            return r
        }, s.getById = function(e) {
            for (var t = this.getChildren(1, 1, 1), i = t.length; i--;)
                if (t[i].vars.id === e) return t[i]
        }, s.remove = function(e) {
            return n(e) ? this.removeLabel(e) : r(e) ? this.killTweensOf(e) : (P(this, e), e === this._recent && (this._recent = this._last), O(this))
        }, s.totalTime = function(t, i) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = x(At.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, i), this._forcing = 0, this) : this._tTime
        }, s.addLabel = function(e, t) {
            return this.labels[e] = vt(this, t), this
        }, s.removeLabel = function(e) {
            return delete this.labels[e], this
        }, s.addPause = function(e, t, i) {
            var n = Yt.delayedCall(0, t || m, i);
            return n.data = "isPause", this._hasPause = 1, k(this, n, vt(this, e))
        }, s.removePause = function(e) {
            var t = this._first;
            for (e = vt(this, e); t;) t._start === e && "isPause" === t.data && R(t), t = t._next
        }, s.killTweensOf = function(e, t, i) {
            for (var n = this.getTweensOf(e, i), r = n.length; r--;) Gt !== n[r] && n[r].kill(e, t);
            return this
        }, s.getTweensOf = function(e, t) {
            for (var i, n = [], r = xt(e), a = this._first, s = o(t); a;) a instanceof Yt ? w(a._targets, r) && (s ? (!Gt || a._initted && a._ts) && a.globalTime(0) <= t && a.globalTime(a.totalDuration()) > t : !t || a.isActive()) && n.push(a) : (i = a.getTweensOf(r, t)).length && n.push.apply(n, i), a = a._next;
            return n
        }, s.tweenTo = function(e, t) {
            t = t || {};
            var i, n = this,
                r = vt(n, e),
                o = t.startAt,
                a = t.onStart,
                s = t.onStartParams,
                l = t.immediateRender,
                c = Yt.to(n, S({
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: t.duration || Math.abs((r - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || Ge,
                    onStart: function() {
                        if (n.pause(), !i) {
                            var e = t.duration || Math.abs((r - (o && "time" in o ? o.time : n._time)) / n.timeScale());
                            c._dur !== e && G(c, e, 0, 1).render(c._time, !0, !0), i = 1
                        }
                        a && a.apply(c, s || [])
                    }
                }, t));
            return l ? c.render(0) : c
        }, s.tweenFromTo = function(e, t, i) {
            return this.tweenTo(t, S({
                startAt: {
                    time: vt(this, e)
                }
            }, i))
        }, s.recent = function() {
            return this._recent
        }, s.nextLabel = function(e) {
            return void 0 === e && (e = this._time), te(this, vt(this, e))
        }, s.previousLabel = function(e) {
            return void 0 === e && (e = this._time), te(this, vt(this, e), 1)
        }, s.currentLabel = function(e) {
            return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + Ge)
        }, s.shiftChildren = function(e, t, i) {
            void 0 === i && (i = 0);
            for (var n, r = this._first, o = this.labels; r;) r._start >= i && (r._start += e, r._end += e), r = r._next;
            if (t)
                for (n in o) o[n] >= i && (o[n] += e);
            return O(this)
        }, s.invalidate = function() {
            var t = this._first;
            for (this._lock = 0; t;) t.invalidate(), t = t._next;
            return e.prototype.invalidate.call(this)
        }, s.clear = function(e) {
            void 0 === e && (e = !0);
            for (var t, i = this._first; i;) t = i._next, this.remove(i), i = t;
            return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), O(this)
        }, s.totalDuration = function(e) {
            var t, i, n, r = 0,
                o = this,
                a = o._last,
                s = He;
            if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -e : e));
            if (o._dirty) {
                for (n = o.parent; a;) t = a._prev, a._dirty && a.totalDuration(), s < (i = a._start) && o._sort && a._ts && !o._lock ? (o._lock = 1, k(o, a, i - a._delay, 1)._lock = 0) : s = i, i < 0 && a._ts && (r -= i, (!n && !o._dp || n && n.smoothChildTiming) && (o._start += i / o._ts, o._time -= i, o._tTime -= i), o.shiftChildren(-i, !1, -1 / 0), s = 0), a._end > r && a._ts && (r = a._end), a = t;
                G(o, o === fe && o._time > r ? o._time : r, 1, 1), o._dirty = 0
            }
            return o._tDur
        }, a.updateRoot = function(e) {
            if (fe._ts && (E(fe, z(e, fe)), xe = At.frame), At.frame >= ht) {
                ht += ke.autoSleep || 120;
                var t = fe._first;
                if ((!t || !t._ts) && ke.autoSleep && At._listeners.length < 2) {
                    for (; t && !t._ts;) t = t._next;
                    t || At.sleep()
                }
            }
        }, a
    }(Ft);

    function Ht(e, t, i, o, a, l) {
        var c, h, u, d;
        if (lt[e] && !1 !== (c = new lt[e]).init(a, c.rawVars ? t[e] : function(e, t, i, o, a) {
                if (r(e) && (e = Wt(e, a, t, i, o)), !s(e) || e.style && e.nodeType || Je(e) || Ze(e)) return n(e) ? Wt(e, a, t, i, o) : e;
                var l, c = {};
                for (l in e) c[l] = Wt(e[l], a, t, i, o);
                return c
            }(t[e], o, a, l, i), i, o, l) && (i._pt = h = new li(i._pt, a, e, 0, 1, c.render, c, 0, c.priority), i !== we))
            for (u = i._ptLookup[i._targets.indexOf(a)], d = c._props.length; d--;) u[c._props[d]] = h;
        return c
    }
    S(Ut.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var Gt, jt = function(e, t, i, o, a, s, l, c, h) {
            r(o) && (o = o(a || 0, e, s));
            var u, p = e[t],
                f = "get" !== i ? i : r(p) ? h ? e[t.indexOf("set") || !r(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](h) : e[t]() : p,
                m = r(p) ? h ? Kt : $t : Qt;
            if (n(o) && (~o.indexOf("random(") && (o = ee(o)), "=" === o.charAt(1) && (!(u = parseFloat(f) + parseFloat(o.substr(2)) * ("-" === o.charAt(0) ? -1 : 1) + (q(f) || 0)) && 0 !== u || (o = u))), f !== o) return isNaN(f * o) || "" === o ? (p || t in e || d(t, o), function(e, t, i, n, r, o, a) {
                var s, l, c, h, u, d, p, f, m = new li(this._pt, e, t, 0, 1, ni, null, r),
                    g = 0,
                    v = 0;
                for (m.b = i, m.e = n, i += "", (p = ~(n += "").indexOf("random(")) && (n = ee(n)), o && (o(f = [i, n], e, t), i = f[0], n = f[1]), l = i.match(et) || []; s = et.exec(n);) h = s[0], u = n.substring(g, s.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: u || 1 === v ? u : ",",
                    s: d,
                    c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = et.lastIndex);
                return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = a, (tt.test(n) || p) && (m.e = 0), this._pt = m
            }.call(this, e, t, f, o, m, c || ke.stringFilter, h)) : (u = new li(this._pt, e, t, +f || 0, o - (f || 0), "boolean" == typeof p ? ii : ti, 0, m), h && (u.fp = h), l && u.modifier(l, this, e), this._pt = u)
        },
        Vt = function e(t, i) {
            var n, r, o, a, s, c, h, u, d, p, f, m, y, b = t.vars,
                x = b.ease,
                w = b.startAt,
                E = b.immediateRender,
                M = b.lazy,
                T = b.onUpdate,
                A = b.onUpdateParams,
                C = b.callbackScope,
                D = b.runBackwards,
                P = b.yoyoEase,
                O = b.keyframes,
                I = b.autoRevert,
                z = t._dur,
                N = t._startAt,
                B = t._targets,
                F = t.parent,
                k = F && "nested" === F.data ? F.parent._targets : B,
                U = "auto" === t._overwrite && !pe,
                H = t.timeline;
            if (!H || O && x || (x = "none"), t._ease = Ot(x, Ue.ease), t._yEase = P ? Rt(Ot(!0 === P ? x : P, Ue.ease)) : 0, P && t._yoyo && !t._repeat && (P = t._yEase, t._yEase = t._ease, t._ease = P), t._from = !H && !!b.runBackwards, !H) {
                if (m = (u = B[0] ? v(B[0]).harness : 0) && b[u.prop], n = L(b, ot), N && N.render(-1, !0).kill(), w)
                    if (R(t._startAt = Yt.set(B, S({
                            data: "isStart",
                            overwrite: !1,
                            parent: F,
                            immediateRender: !0,
                            lazy: l(M),
                            startAt: null,
                            delay: 0,
                            onUpdate: T,
                            onUpdateParams: A,
                            callbackScope: C,
                            stagger: 0
                        }, w))), i < 0 && !E && !I && t._startAt.render(-1, !0), E) {
                        if (0 < i && !I && (t._startAt = 0), z && i <= 0) return void(i && (t._zTime = i))
                    } else !1 === I && (t._startAt = 0);
                else if (D && z)
                    if (N) I || (t._startAt = 0);
                    else if (i && (E = !1), o = S({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: E && l(M),
                        immediateRender: E,
                        stagger: 0,
                        parent: F
                    }, n), m && (o[u.prop] = m), R(t._startAt = Yt.set(B, o)), i < 0 && t._startAt.render(-1, !0), E) {
                    if (!i) return
                } else e(t._startAt, Ge);
                for (t._pt = 0, M = z && l(M) || M && !z, r = 0; r < B.length; r++) {
                    if (h = (s = B[r])._gsap || g(B)[r]._gsap, t._ptLookup[r] = p = {}, st[h.id] && at.length && _(), f = k === B ? r : k.indexOf(s), u && !1 !== (d = new u).init(s, m || n, t, f, k) && (t._pt = a = new li(t._pt, s, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function(e) {
                            p[e] = a
                        })), d.priority && (c = 1)), !u || m)
                        for (o in n) lt[o] && (d = Ht(o, n, t, f, s, k)) ? d.priority && (c = 1) : p[o] = a = jt.call(t, s, o, "get", n[o], f, k, 0, b.stringFilter);
                    t._op && t._op[r] && t.kill(s, t._op[r]), U && t._pt && (Gt = t, fe.killTweensOf(s, p, t.globalTime(0)), y = !t.parent, Gt = 0), t._pt && M && (st[h.id] = 1)
                }
                c && si(t), t._onInit && t._onInit(t)
            }
            t._onUpdate = T, t._initted = (!t._op || t._pt) && !y
        },
        Wt = function(e, t, i, o, a) {
            return r(e) ? e.call(t, i, o, a) : n(e) && ~e.indexOf("random(") ? ee(e) : e
        },
        qt = dt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        Xt = (qt + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
        Yt = function(e) {
            function r(t, n, r, a) {
                var c;
                "number" == typeof n && (r.duration = n, n = r, r = null);
                var u, d, f, v, y, b, w, _, E = (c = e.call(this, a ? n : D(n)) || this).vars,
                    M = E.duration,
                    T = E.delay,
                    A = E.immediateRender,
                    C = E.stagger,
                    L = E.overwrite,
                    P = E.keyframes,
                    R = E.defaults,
                    O = E.scrollTrigger,
                    I = E.yoyoEase,
                    z = n.parent || fe,
                    N = (Je(t) || Ze(t) ? o(t[0]) : "length" in n) ? [t] : xt(t);
                if (c._targets = N.length ? g(N) : p("GSAP target " + t + " not found. https://greensock.com", !ke.nullTargetWarn) || [], c._ptLookup = [], c._overwrite = L, P || C || h(M) || h(T)) {
                    if (n = c.vars, (u = c.timeline = new Ut({
                            data: "nested",
                            defaults: R || {}
                        })).kill(), u.parent = u._dp = i(c), u._start = 0, P) S(u.vars.defaults, {
                        ease: "none"
                    }), C ? N.forEach((function(e, t) {
                        return P.forEach((function(i, n) {
                            return u.to(e, i, n ? ">" : t * C)
                        }))
                    })) : P.forEach((function(e) {
                        return u.to(N, e, ">")
                    }));
                    else {
                        if (v = N.length, w = C ? Z(C) : m, s(C))
                            for (y in C) ~qt.indexOf(y) && ((_ = _ || {})[y] = C[y]);
                        for (d = 0; d < v; d++) {
                            for (y in f = {}, n) Xt.indexOf(y) < 0 && (f[y] = n[y]);
                            f.stagger = 0, I && (f.yoyoEase = I), _ && pt(f, _), b = N[d], f.duration = +Wt(M, i(c), d, b, N), f.delay = (+Wt(T, i(c), d, b, N) || 0) - c._delay, !C && 1 === v && f.delay && (c._delay = T = f.delay, c._start += T, f.delay = 0), u.to(b, f, w(d, b, N))
                        }
                        u.duration() ? M = T = 0 : c.timeline = 0
                    }
                    M || c.duration(M = u.duration())
                } else c.timeline = 0;
                return !0 !== L || pe || (Gt = i(c), fe.killTweensOf(N), Gt = 0), k(z, i(c), r), n.reversed && c.reverse(), n.paused && c.paused(!0), (A || !M && !P && c._start === x(z._time) && l(A) && function e(t) {
                    return !t || t._ts && e(t.parent)
                }(i(c)) && "nested" !== z.data) && (c._tTime = -Ge, c.render(Math.max(0, -T))), O && U(i(c), O), c
            }
            t(r, e);
            var a = r.prototype;
            return a.render = function(e, t, i) {
                var n, r, o, a, s, l, c, h, u, d = this._time,
                    p = this._tDur,
                    f = this._dur,
                    m = p - Ge < e && 0 <= e ? p : e < Ge ? 0 : e;
                if (f) {
                    if (m !== this._tTime || !e || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) {
                        if (n = m, h = this.timeline, this._repeat) {
                            if (a = f + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, i);
                            if (n = x(m % a), m === p ? (o = this._repeat, n = f) : ((o = ~~(m / a)) && o === m / a && (n = f, o--), f < n && (n = f)), (l = this._yoyo && 1 & o) && (u = this._yEase, n = f - n), s = ft(this._tTime, a), n === d && !i && this._initted) return this;
                            o !== s && (h && this._yEase && le(h, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = i = 1, this.render(x(a * o), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (H(this, e < 0 ? e : n, i, t)) return this._tTime = 0, this;
                            if (f !== this._dur) return this.render(e, t, i)
                        }
                        if (this._tTime = m, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(n / f), this._from && (this.ratio = c = 1 - c), n && !d && !t && (_t(this, "onStart"), this._tTime !== m)) return this;
                        for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                        h && h.render(e < 0 ? e : !n && l ? -Ge : h._dur * c, t, i) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, i), _t(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !t && this.parent && _t(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0), !e && f || !(m === this._tDur && 0 < this._ts || !m && this._ts < 0) || R(this, 1), t || e < 0 && !d || !m && !d || (_t(this, m === p ? "onComplete" : "onReverseComplete", !0), !this._prom || m < p && 0 < this.timeScale() || this._prom()))
                    }
                } else ! function(e, t, i, n) {
                    var r, o, a, s = e.ratio,
                        l = t < 0 || !t && (!e._start && function e(t) {
                            var i = t.parent;
                            return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || e(i))
                        }(e) && (e._initted || !mt(e)) || (e._ts < 0 || e._dp._ts < 0) && !mt(e)) ? 0 : 1,
                        c = e._rDelay,
                        h = 0;
                    if (c && e._repeat && (h = yt(0, e._tDur, t), o = ft(h, c), a = ft(e._tTime, c), e._yoyo && 1 & o && (l = 1 - l), o !== a && (s = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== s || n || e._zTime === Ge || !t && e._zTime) {
                        if (!e._initted && H(e, t, n, i)) return;
                        for (a = e._zTime, e._zTime = t || (i ? Ge : 0), i = i || t && !a, e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = h, r = e._pt; r;) r.r(l, r.d), r = r._next;
                        e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !i && _t(e, "onUpdate"), h && e._repeat && !i && e.parent && _t(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && R(e, 1), i || (_t(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                    } else e._zTime || (e._zTime = t)
                }(this, e, t, i);
                return this
            }, a.targets = function() {
                return this._targets
            }, a.invalidate = function() {
                return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), e.prototype.invalidate.call(this)
            }, a.kill = function(e, t) {
                if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? ie(this) : this;
                if (this.timeline) {
                    var i = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(e, t, Gt && !0 !== Gt.vars.overwrite)._first || ie(this), this.parent && i !== this.timeline.totalDuration() && G(this, this._dur * this.timeline._tDur / i, 0, 1), this
                }
                var r, o, a, s, l, c, h, u = this._targets,
                    d = e ? xt(e) : u,
                    p = this._ptLookup,
                    f = this._pt;
                if ((!t || "all" === t) && function(e, t) {
                        for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i];);
                        return i < 0
                    }(u, d)) return "all" === t && (this._pt = 0), ie(this);
                for (r = this._op = this._op || [], "all" !== t && (n(t) && (l = {}, b(t, (function(e) {
                        return l[e] = 1
                    })), t = l), t = function(e, t) {
                        var i, n, r, o, a = e[0] ? v(e[0]).harness : 0,
                            s = a && a.aliases;
                        if (!s) return t;
                        for (n in i = pt({}, t), s)
                            if (n in i)
                                for (r = (o = s[n].split(",")).length; r--;) i[o[r]] = i[n];
                        return i
                    }(u, t)), h = u.length; h--;)
                    if (~d.indexOf(u[h]))
                        for (l in o = p[h], "all" === t ? (r[h] = t, s = o, a = {}) : (a = r[h] = r[h] || {}, s = t), s)(c = o && o[l]) && ("kill" in c.d && !0 !== c.d.kill(l) || P(this, c, "_pt"), delete o[l]), "all" !== a && (a[l] = 1);
                return this._initted && !this._pt && f && ie(this), this
            }, r.to = function(e, t, i) {
                return new r(e, t, i)
            }, r.from = function(e, t) {
                return V(1, arguments)
            }, r.delayedCall = function(e, t, i, n) {
                return new r(t, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: e,
                    onComplete: t,
                    onReverseComplete: t,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: n
                })
            }, r.fromTo = function(e, t, i) {
                return V(2, arguments)
            }, r.set = function(e, t) {
                return t.duration = 0, t.repeatDelay || (t.repeat = 0), new r(e, t)
            }, r.killTweensOf = function(e, t, i) {
                return fe.killTweensOf(e, t, i)
            }, r
        }(Ft);

    function Zt(e, t, i) {
        return e.setAttribute(t, i)
    }

    function Jt(e, t, i, n) {
        n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
    }
    S(Yt.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), b("staggerTo,staggerFrom,staggerFromTo", (function(e) {
        Yt[e] = function() {
            var t = new Ut,
                i = bt.call(arguments, 0);
            return i.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, i)
        }
    }));
    var Qt = function(e, t, i) {
            return e[t] = i
        },
        $t = function(e, t, i) {
            return e[t](i)
        },
        Kt = function(e, t, i, n) {
            return e[t](n.fp, i)
        },
        ei = function(e, t) {
            return r(e[t]) ? $t : a(e[t]) && e.setAttribute ? Zt : Qt
        },
        ti = function(e, t) {
            return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
        },
        ii = function(e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        },
        ni = function(e, t) {
            var i = t._pt,
                n = "";
            if (!e && t.b) n = t.b;
            else if (1 === e && t.e) n = t.e;
            else {
                for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round(1e4 * (i.s + i.c * e)) / 1e4) + n, i = i._next;
                n += t.c
            }
            t.set(t.t, t.p, n, t)
        },
        ri = function(e, t) {
            for (var i = t._pt; i;) i.r(e, i.d), i = i._next
        },
        oi = function(e, t, i, n) {
            for (var r, o = this._pt; o;) r = o._next, o.p === n && o.modifier(e, t, i), o = r
        },
        ai = function(e) {
            for (var t, i, n = this._pt; n;) i = n._next, n.p === e && !n.op || n.op === e ? P(this, n, "_pt") : n.dep || (t = 1), n = i;
            return !t
        },
        si = function(e) {
            for (var t, i, n, r, o = e._pt; o;) {
                for (t = o._next, i = n; i && i.pr > o.pr;) i = i._next;
                (o._prev = i ? i._prev : r) ? o._prev._next = o: n = o, (o._next = i) ? i._prev = o : r = o, o = t
            }
            e._pt = n
        },
        li = (ci.prototype.modifier = function(e, t, i) {
            this.mSet = this.mSet || this.set, this.set = Jt, this.m = e, this.mt = i, this.tween = t
        }, ci);

    function ci(e, t, i, n, r, o, a, s, l) {
        this.t = t, this.s = n, this.c = r, this.p = i, this.r = o || ti, this.d = a || this, this.set = s || Qt, this.pr = l || 0, (this._next = e) && (e._prev = this)
    }
    b(dt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
        return ot[e] = 1
    })), rt.TweenMax = rt.TweenLite = Yt, rt.TimelineLite = rt.TimelineMax = Ut, fe = new Ut({
        sortChildren: !1,
        defaults: Ue,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), ke.stringFilter = se;
    var hi = {
        registerPlugin: function() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            t.forEach((function(e) {
                return function(e) {
                    var t = (e = !e.name && e.default || e).name,
                        i = r(e),
                        n = t && !i && e.init ? function() {
                            this._props = []
                        } : e,
                        o = {
                            init: m,
                            render: ri,
                            add: jt,
                            kill: ai,
                            modifier: oi,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: ei,
                            aliases: {},
                            register: 0
                        };
                    if (Ct(), e !== n) {
                        if (lt[t]) return;
                        S(n, S(L(e, o), a)), pt(n.prototype, pt(o, L(e, a))), lt[n.prop = t] = n, e.targetTest && (ut.push(n), ot[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    f(t, n), e.register && e.register(pi, n, li)
                }(e)
            }))
        },
        timeline: function(e) {
            return new Ut(e)
        },
        getTweensOf: function(e, t) {
            return fe.getTweensOf(e, t)
        },
        getProperty: function(e, t, i, r) {
            n(e) && (e = xt(e)[0]);
            var o = v(e || {}).get,
                a = i ? T : M;
            return "native" === i && (i = ""), e ? t ? a((lt[t] && lt[t].get || o)(e, t, i, r)) : function(t, i, n) {
                return a((lt[t] && lt[t].get || o)(e, t, i, n))
            } : e
        },
        quickSetter: function(e, t, i) {
            if (1 < (e = xt(e)).length) {
                var n = e.map((function(e) {
                        return pi.quickSetter(e, t, i)
                    })),
                    r = n.length;
                return function(e) {
                    for (var t = r; t--;) n[t](e)
                }
            }
            e = e[0] || {};
            var o = lt[t],
                a = v(e),
                s = a.harness && (a.harness.aliases || {})[t] || t,
                l = o ? function(t) {
                    var n = new o;
                    we._pt = 0, n.init(e, i ? t + i : t, we, 0, [e]), n.render(1, n), we._pt && ri(1, we)
                } : a.set(e, s);
            return o ? l : function(t) {
                return l(e, s, i ? t + i : t, a, 1)
            }
        },
        isTweening: function(e) {
            return 0 < fe.getTweensOf(e, !0).length
        },
        defaults: function(e) {
            return e && e.ease && (e.ease = Ot(e.ease, Ue.ease)), C(Ue, e || {})
        },
        config: function(e) {
            return C(ke, e || {})
        },
        registerEffect: function(e) {
            var t = e.name,
                i = e.effect,
                n = e.plugins,
                r = e.defaults,
                o = e.extendTimeline;
            (n || "").split(",").forEach((function(e) {
                return e && !lt[e] && !rt[e] && p(t + " effect requires " + e + " plugin.")
            })), ct[t] = function(e, t, n) {
                return i(xt(e), S(t || {}, r), n)
            }, o && (Ut.prototype[t] = function(e, i, n) {
                return this.add(ct[t](e, s(i) ? i : (n = i) && {}, this), n)
            })
        },
        registerEase: function(e, t) {
            Lt[e] = Ot(t)
        },
        parseEase: function(e, t) {
            return arguments.length ? Ot(e, t) : Lt
        },
        getById: function(e) {
            return fe.getById(e)
        },
        exportRoot: function(e, t) {
            void 0 === e && (e = {});
            var i, n, r = new Ut(e);
            for (r.smoothChildTiming = l(e.smoothChildTiming), fe.remove(r), r._dp = 0, r._time = r._tTime = fe._time, i = fe._first; i;) n = i._next, !t && !i._dur && i instanceof Yt && i.vars.onComplete === i._targets[0] || k(r, i, i._start - i._delay), i = n;
            return k(fe, r, 0), r
        },
        utils: {
            wrap: function e(t, i, n) {
                var r = i - t;
                return Je(t) ? K(t, e(0, t.length), i) : W(n, (function(e) {
                    return (r + (e - t) % r) % r + t
                }))
            },
            wrapYoyo: function e(t, i, n) {
                var r = i - t,
                    o = 2 * r;
                return Je(t) ? K(t, e(0, t.length - 1), i) : W(n, (function(e) {
                    return t + (r < (e = (o + (e - t) % o) % o || 0) ? o - e : e)
                }))
            },
            distribute: Z,
            random: $,
            snap: Q,
            normalize: function(e, t, i) {
                return wt(e, t, 0, 1, i)
            },
            getUnit: q,
            clamp: function(e, t, i) {
                return W(i, (function(i) {
                    return yt(e, t, i)
                }))
            },
            splitColor: re,
            toArray: xt,
            selector: function(e) {
                return e = xt(e)[0] || p("Invalid scope") || {},
                    function(t) {
                        var i = e.current || e.nativeElement || e;
                        return xt(t, i.querySelectorAll ? i : i === e ? p("Invalid scope") || ve.createElement("div") : e)
                    }
            },
            mapRange: wt,
            pipe: function() {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                return function(e) {
                    return t.reduce((function(e, t) {
                        return t(e)
                    }), e)
                }
            },
            unitize: function(e, t) {
                return function(i) {
                    return e(parseFloat(i)) + (t || q(i))
                }
            },
            interpolate: function e(t, i, r, o) {
                var a = isNaN(t + i) ? 0 : function(e) {
                    return (1 - e) * t + e * i
                };
                if (!a) {
                    var s, l, c, h, u, d = n(t),
                        p = {};
                    if (!0 === r && (o = 1) && (r = null), d) t = {
                        p: t
                    }, i = {
                        p: i
                    };
                    else if (Je(t) && !Je(i)) {
                        for (c = [], h = t.length, u = h - 2, l = 1; l < h; l++) c.push(e(t[l - 1], t[l]));
                        h--, a = function(e) {
                            e *= h;
                            var t = Math.min(u, ~~e);
                            return c[t](e - t)
                        }, r = i
                    } else o || (t = pt(Je(t) ? [] : {}, t));
                    if (!c) {
                        for (s in i) jt.call(p, t, s, "get", i[s]);
                        a = function(e) {
                            return ri(e, p) || (d ? t.p : t)
                        }
                    }
                }
                return W(r, a)
            },
            shuffle: Y
        },
        install: u,
        effects: ct,
        ticker: At,
        updateRoot: Ut.updateRoot,
        plugins: lt,
        globalTimeline: fe,
        core: {
            PropTween: li,
            globals: f,
            Tween: Yt,
            Timeline: Ut,
            Animation: Ft,
            getCache: v,
            _removeLinkedListItem: P,
            suppressOverwrites: function(e) {
                return pe = e
            }
        }
    };

    function ui(e, t) {
        for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
        return i
    }

    function di(e, t) {
        return {
            name: e,
            rawVars: 1,
            init: function(e, i, r) {
                r._onInit = function(e) {
                    var r, o;
                    if (n(i) && (r = {}, b(i, (function(e) {
                            return r[e] = 1
                        })), i = r), t) {
                        for (o in r = {}, i) r[o] = t(i[o]);
                        i = r
                    }! function(e, t) {
                        var i, n, r, o = e._targets;
                        for (i in t)
                            for (n = o.length; n--;)(r = (r = e._ptLookup[n][i]) && r.d) && (r._pt && (r = ui(r, i)), r && r.modifier && r.modifier(t[i], e, o[n], i))
                    }(e, i)
                }
            }
        }
    }
    b("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
        return hi[e] = Yt[e]
    })), At.add(Ut.updateRoot), we = hi.to({}, {
        duration: 0
    });
    var pi = hi.registerPlugin({
        name: "attr",
        init: function(e, t, i, n, r) {
            var o, a;
            for (o in t)(a = this.add(e, "setAttribute", (e.getAttribute(o) || 0) + "", t[o], n, r, 0, 0, o)) && (a.op = o), this._props.push(o)
        }
    }, {
        name: "endArray",
        init: function(e, t) {
            for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i])
        }
    }, di("roundProps", J), di("modifiers"), di("snap", Q)) || hi;

    function fi(e, t) {
        return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
    }

    function mi(e, t) {
        return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
    }

    function gi(e, t) {
        return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
    }

    function vi(e, t) {
        var i = t.s + t.c * e;
        t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
    }

    function yi(e, t) {
        return t.set(t.t, t.p, e ? t.e : t.b, t)
    }

    function bi(e, t) {
        return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
    }

    function xi(e, t, i) {
        return e.style[t] = i
    }

    function wi(e, t, i) {
        return e.style.setProperty(t, i)
    }

    function _i(e, t, i) {
        return e._gsap[t] = i
    }

    function Ei(e, t, i) {
        return e._gsap.scaleX = e._gsap.scaleY = i
    }

    function Mi(e, t, i, n, r) {
        var o = e._gsap;
        o.scaleX = o.scaleY = i, o.renderTransform(r, o)
    }

    function Ti(e, t, i, n, r) {
        var o = e._gsap;
        o[t] = i, o.renderTransform(r, o)
    }

    function Si(e, t) {
        var i = Zi.createElementNS ? Zi.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Zi.createElement(e);
        return i.style ? i : Zi.createElement(e)
    }

    function Ai(e, t, i) {
        var n = getComputedStyle(e);
        return n[t] || n.getPropertyValue(t.replace(Mn, "-$1").toLowerCase()) || n.getPropertyValue(t) || !i && Ai(e, Pn(t) || t, 1) || ""
    }

    function Ci() {
        "undefined" != typeof window && window.document && (Yi = window, Zi = Yi.document, Ji = Zi.documentElement, $i = Si("div") || {
            style: {}
        }, Si("div"), Cn = Pn(Cn), Ln = Cn + "Origin", $i.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", en = !!Pn("perspective"), Qi = 1)
    }

    function Li(e) {
        var t, i = Si("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            n = this.parentNode,
            r = this.nextSibling,
            o = this.style.cssText;
        if (Ji.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
            t = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = Li
        } catch (e) {} else this._gsapBBox && (t = this._gsapBBox());
        return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), Ji.removeChild(i), this.style.cssText = o, t
    }

    function Di(e, t) {
        for (var i = t.length; i--;)
            if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
    }

    function Pi(e) {
        var t;
        try {
            t = e.getBBox()
        } catch (i) {
            t = Li.call(e, !0)
        }
        return t && (t.width || t.height) || e.getBBox === Li || (t = Li.call(e, !0)), !t || t.width || t.x || t.y ? t : {
            x: +Di(e, ["x", "cx", "x1"]) || 0,
            y: +Di(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }

    function Ri(e) {
        return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !Pi(e))
    }

    function Oi(e, t) {
        if (t) {
            var i = e.style;
            t in xn && t !== Ln && (t = Cn), i.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), i.removeProperty(t.replace(Mn, "-$1").toLowerCase())) : i.removeAttribute(t)
        }
    }

    function Ii(e, t, i, n, r, o) {
        var a = new li(e._pt, t, i, 0, 1, o ? bi : yi);
        return (e._pt = a).b = n, a.e = r, e._props.push(i), a
    }

    function zi(e, t, i, n) {
        var r, o, a, s, l = parseFloat(i) || 0,
            c = (i + "").trim().substr((l + "").length) || "px",
            h = $i.style,
            u = Tn.test(t),
            d = "svg" === e.tagName.toLowerCase(),
            p = (d ? "client" : "offset") + (u ? "Width" : "Height"),
            f = "px" === n,
            m = "%" === n;
        return n === c || !l || Rn[n] || Rn[c] ? l : ("px" === c || f || (l = zi(e, t, i, "px")), s = e.getCTM && Ri(e), !m && "%" !== c || !xn[t] && !~t.indexOf("adius") ? (h[u ? "width" : "height"] = 100 + (f ? c : n), o = ~t.indexOf("adius") || "em" === n && e.appendChild && !d ? e : e.parentNode, s && (o = (e.ownerSVGElement || {}).parentNode), o && o !== Zi && o.appendChild || (o = Zi.body), (a = o._gsap) && m && a.width && u && a.time === At.time ? x(l / a.width * 100) : (!m && "%" !== c || (h.position = Ai(e, "position")), o === e && (h.position = "static"), o.appendChild($i), r = $i[p], o.removeChild($i), h.position = "absolute", u && m && ((a = v(o)).time = At.time, a.width = o[p]), x(f ? r * l / 100 : r && l ? 100 / r * l : 0))) : (r = s ? e.getBBox()[u ? "width" : "height"] : e[p], x(m ? l / r * 100 : l / 100 * r)))
    }

    function Ni(e, t, i, n) {
        var r;
        return Qi || Ci(), t in An && "transform" !== t && ~(t = An[t]).indexOf(",") && (t = t.split(",")[0]), xn[t] && "transform" !== t ? (r = Bn(e, n), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : Fn(Ai(e, Ln)) + " " + r.zOrigin + "px") : (r = e.style[t]) && "auto" !== r && !n && !~(r + "").indexOf("calc(") || (r = In[t] && In[t](e, t, i) || Ai(e, t) || y(e, t) || ("opacity" === t ? 1 : 0)), i && !~(r + "").trim().indexOf(" ") ? zi(e, t, r, i) + i : r
    }

    function Bi(e, t, i, n) {
        if (!i || "none" === i) {
            var r = Pn(t, e, 1),
                o = r && Ai(e, r, 1);
            o && o !== i ? (t = r, i = o) : "borderColor" === t && (i = Ai(e, "borderTopColor"))
        }
        var a, s, l, c, h, u, d, p, f, m, g, v, y = new li(this._pt, e.style, t, 0, 1, ni),
            b = 0,
            x = 0;
        if (y.b = i, y.e = n, i += "", "auto" == (n += "") && (e.style[t] = n, n = Ai(e, t) || n, e.style[t] = i), se(a = [i, n]), n = a[1], l = (i = a[0]).match(Ke) || [], (n.match(Ke) || []).length) {
            for (; s = Ke.exec(n);) d = s[0], f = n.substring(b, s.index), h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1), d !== (u = l[x++] || "") && (c = parseFloat(u) || 0, g = u.substr((c + "").length), (v = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), m = d.substr((p + "").length), b = Ke.lastIndex - m.length, m || (m = m || ke.units[t] || g, b === n.length && (n += m, y.e += m)), g !== m && (c = zi(e, t, u, m) || 0), y._pt = {
                _next: y._pt,
                p: f || 1 === x ? f : ",",
                s: c,
                c: v ? v * p : p - c,
                m: h && h < 4 || "zIndex" === t ? Math.round : 0
            });
            y.c = b < n.length ? n.substring(b, n.length) : ""
        } else y.r = "display" === t && "none" === n ? bi : yi;
        return tt.test(n) && (y.e = 0), this._pt = y
    }

    function Fi(e) {
        var t = e.split(" "),
            i = t[0],
            n = t[1] || "50%";
        return "top" !== i && "bottom" !== i && "left" !== n && "right" !== n || (e = i, i = n, n = e), t[0] = On[i] || i, t[1] = On[n] || n, t.join(" ")
    }

    function ki(e, t) {
        if (t.tween && t.tween._time === t.tween._dur) {
            var i, n, r, o = t.t,
                a = o.style,
                s = t.u,
                l = o._gsap;
            if ("all" === s || !0 === s) a.cssText = "", n = 1;
            else
                for (r = (s = s.split(",")).length; - 1 < --r;) i = s[r], xn[i] && (n = 1, i = "transformOrigin" === i ? Ln : Cn), Oi(o, i);
            n && (Oi(o, Cn), l && (l.svg && o.removeAttribute("transform"), Bn(o, 1), l.uncache = 1))
        }
    }

    function Ui(e) {
        return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
    }

    function Hi(e) {
        var t = Ai(e, Cn);
        return Ui(t) ? zn : t.substr(7).match($e).map(x)
    }

    function Gi(e, t) {
        var i, n, r, o, a = e._gsap || v(e),
            s = e.style,
            l = Hi(e);
        return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? zn : l : (l !== zn || e.offsetParent || e === Ji || a.svg || (r = s.display, s.display = "block", (i = e.parentNode) && e.offsetParent || (o = 1, n = e.nextSibling, Ji.appendChild(e)), l = Hi(e), r ? s.display = r : Oi(e, "display"), o && (n ? i.insertBefore(e, n) : i ? i.appendChild(e) : Ji.removeChild(e))), t && 6 < l.length ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
    }

    function ji(e, t, i, n, r, o) {
        var a, s, l, c = e._gsap,
            h = r || Gi(e, !0),
            u = c.xOrigin || 0,
            d = c.yOrigin || 0,
            p = c.xOffset || 0,
            f = c.yOffset || 0,
            m = h[0],
            g = h[1],
            v = h[2],
            y = h[3],
            b = h[4],
            x = h[5],
            w = t.split(" "),
            _ = parseFloat(w[0]) || 0,
            E = parseFloat(w[1]) || 0;
        i ? h !== zn && (s = m * y - g * v) && (l = _ * (-g / s) + E * (m / s) - (m * x - g * b) / s, _ = _ * (y / s) + E * (-v / s) + (v * x - y * b) / s, E = l) : (_ = (a = Pi(e)).x + (~w[0].indexOf("%") ? _ / 100 * a.width : _), E = a.y + (~(w[1] || w[0]).indexOf("%") ? E / 100 * a.height : E)), n || !1 !== n && c.smooth ? (b = _ - u, x = E - d, c.xOffset = p + (b * m + x * v) - b, c.yOffset = f + (b * g + x * y) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = _, c.yOrigin = E, c.smooth = !!n, c.origin = t, c.originIsAbsolute = !!i, e.style[Ln] = "0px 0px", o && (Ii(o, c, "xOrigin", u, _), Ii(o, c, "yOrigin", d, E), Ii(o, c, "xOffset", p, c.xOffset), Ii(o, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", _ + " " + E)
    }

    function Vi(e, t, i) {
        var n = q(t);
        return x(parseFloat(t) + parseFloat(zi(e, "x", i + "px", n))) + n
    }

    function Wi(e, t, i, r, o, a) {
        var s, l, c = 360,
            h = n(o),
            u = parseFloat(o) * (h && ~o.indexOf("rad") ? wn : 1),
            d = a ? u * a : u - r,
            p = r + d + "deg";
        return h && ("short" === (s = o.split("_")[1]) && (d %= c) !== d % 180 && (d += d < 0 ? c : -c), "cw" === s && d < 0 ? d = (d + 36e9) % c - ~~(d / c) * c : "ccw" === s && 0 < d && (d = (d - 36e9) % c - ~~(d / c) * c)), e._pt = l = new li(e._pt, t, i, r, d, mi), l.e = p, l.u = "deg", e._props.push(i), l
    }

    function qi(e, t) {
        for (var i in t) e[i] = t[i];
        return e
    }

    function Xi(e, t, i) {
        var n, r, o, a, s, l, c, h = qi({}, i._gsap),
            u = i.style;
        for (r in h.svg ? (o = i.getAttribute("transform"), i.setAttribute("transform", ""), u[Cn] = t, n = Bn(i, 1), Oi(i, Cn), i.setAttribute("transform", o)) : (o = getComputedStyle(i)[Cn], u[Cn] = t, n = Bn(i, 1), u[Cn] = o), xn)(o = h[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (s = q(o) !== (c = q(a)) ? zi(i, r, o, c) : parseFloat(o), l = parseFloat(a), e._pt = new li(e._pt, n, r, s, l - s, fi), e._pt.u = c || 0, e._props.push(r));
        qi(n, h)
    }
    Yt.version = Ut.version = pi.version = "3.7.1", be = 1, c() && Ct();
    var Yi, Zi, Ji, Qi, $i, Ki, en, tn = Lt.Power0,
        nn = Lt.Power1,
        rn = Lt.Power2,
        on = Lt.Power3,
        an = Lt.Power4,
        sn = Lt.Linear,
        ln = Lt.Quad,
        cn = Lt.Cubic,
        hn = Lt.Quart,
        un = Lt.Quint,
        dn = Lt.Strong,
        pn = Lt.Elastic,
        fn = Lt.Back,
        mn = Lt.SteppedEase,
        gn = Lt.Bounce,
        vn = Lt.Sine,
        yn = Lt.Expo,
        bn = Lt.Circ,
        xn = {},
        wn = 180 / Math.PI,
        _n = Math.PI / 180,
        En = Math.atan2,
        Mn = /([A-Z])/g,
        Tn = /(?:left|right|width|margin|padding|x)/i,
        Sn = /[\s,\(]\S/,
        An = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        Cn = "transform",
        Ln = Cn + "Origin",
        Dn = "O,Moz,ms,Ms,Webkit".split(","),
        Pn = function(e, t, i) {
            var n = (t || $i).style,
                r = 5;
            if (e in n && !i) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(Dn[r] + e in n););
            return r < 0 ? null : (3 === r ? "ms" : 0 <= r ? Dn[r] : "") + e
        },
        Rn = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        On = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        In = {
            clearProps: function(e, t, i, n, r) {
                if ("isFromStart" !== r.data) {
                    var o = e._pt = new li(e._pt, t, i, 0, 0, ki);
                    return o.u = n, o.pr = -10, o.tween = r, e._props.push(i), 1
                }
            }
        },
        zn = [1, 0, 0, 1, 0, 0],
        Nn = {},
        Bn = function(e, t) {
            var i = e._gsap || new Bt(e);
            if ("x" in i && !t && !i.uncache) return i;
            var n, r, o, a, s, l, c, h, u, d, p, f, m, g, v, y, b, w, _, E, M, T, S, A, C, L, D, P, R, O, I, z, N = e.style,
                B = i.scaleX < 0,
                F = "deg",
                k = Ai(e, Ln) || "0";
            return n = r = o = l = c = h = u = d = p = 0, a = s = 1, i.svg = !(!e.getCTM || !Ri(e)), g = Gi(e, i.svg), i.svg && (A = (!i.uncache || "0px 0px" === k) && !t && e.getAttribute("data-svg-origin"), ji(e, A || k, !!A || i.originIsAbsolute, !1 !== i.smooth, g)), f = i.xOrigin || 0, m = i.yOrigin || 0, g !== zn && (w = g[0], _ = g[1], E = g[2], M = g[3], n = T = g[4], r = S = g[5], 6 === g.length ? (a = Math.sqrt(w * w + _ * _), s = Math.sqrt(M * M + E * E), l = w || _ ? En(_, w) * wn : 0, (u = E || M ? En(E, M) * wn + l : 0) && (s *= Math.abs(Math.cos(u * _n))), i.svg && (n -= f - (f * w + m * E), r -= m - (f * _ + m * M))) : (z = g[6], O = g[7], D = g[8], P = g[9], R = g[10], I = g[11], n = g[12], r = g[13], o = g[14], c = (v = En(z, R)) * wn, v && (A = T * (y = Math.cos(-v)) + D * (b = Math.sin(-v)), C = S * y + P * b, L = z * y + R * b, D = T * -b + D * y, P = S * -b + P * y, R = z * -b + R * y, I = O * -b + I * y, T = A, S = C, z = L), h = (v = En(-E, R)) * wn, v && (y = Math.cos(-v), I = M * (b = Math.sin(-v)) + I * y, w = A = w * y - D * b, _ = C = _ * y - P * b, E = L = E * y - R * b), l = (v = En(_, w)) * wn, v && (A = w * (y = Math.cos(v)) + _ * (b = Math.sin(v)), C = T * y + S * b, _ = _ * y - w * b, S = S * y - T * b, w = A, T = C), c && 359.9 < Math.abs(c) + Math.abs(l) && (c = l = 0, h = 180 - h), a = x(Math.sqrt(w * w + _ * _ + E * E)), s = x(Math.sqrt(S * S + z * z)), v = En(T, S), u = 2e-4 < Math.abs(v) ? v * wn : 0, p = I ? 1 / (I < 0 ? -I : I) : 0), i.svg && (A = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !Ui(Ai(e, Cn)), A && e.setAttribute("transform", A))), 90 < Math.abs(u) && Math.abs(u) < 270 && (B ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, u += u <= 0 ? 180 : -180)), i.x = n - ((i.xPercent = n && (i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + "px", i.y = r - ((i.yPercent = r && (i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + "px", i.z = o + "px", i.scaleX = x(a), i.scaleY = x(s), i.rotation = x(l) + F, i.rotationX = x(c) + F, i.rotationY = x(h) + F, i.skewX = u + F, i.skewY = d + F, i.transformPerspective = p + "px", (i.zOrigin = parseFloat(k.split(" ")[2]) || 0) && (N[Ln] = Fn(k)), i.xOffset = i.yOffset = 0, i.force3D = ke.force3D, i.renderTransform = i.svg ? Vn : en ? jn : kn, i.uncache = 0, i
        },
        Fn = function(e) {
            return (e = e.split(" "))[0] + " " + e[1]
        },
        kn = function(e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, jn(e, t)
        },
        Un = "0deg",
        Hn = "0px",
        Gn = ") ",
        jn = function(e, t) {
            var i = t || this,
                n = i.xPercent,
                r = i.yPercent,
                o = i.x,
                a = i.y,
                s = i.z,
                l = i.rotation,
                c = i.rotationY,
                h = i.rotationX,
                u = i.skewX,
                d = i.skewY,
                p = i.scaleX,
                f = i.scaleY,
                m = i.transformPerspective,
                g = i.force3D,
                v = i.target,
                y = i.zOrigin,
                b = "",
                x = "auto" === g && e && 1 !== e || !0 === g;
            if (y && (h !== Un || c !== Un)) {
                var w, _ = parseFloat(c) * _n,
                    E = Math.sin(_),
                    M = Math.cos(_);
                _ = parseFloat(h) * _n, o = Vi(v, o, E * (w = Math.cos(_)) * -y), a = Vi(v, a, -Math.sin(_) * -y), s = Vi(v, s, M * w * -y + y)
            }
            m !== Hn && (b += "perspective(" + m + Gn), (n || r) && (b += "translate(" + n + "%, " + r + "%) "), !x && o === Hn && a === Hn && s === Hn || (b += s !== Hn || x ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + Gn), l !== Un && (b += "rotate(" + l + Gn), c !== Un && (b += "rotateY(" + c + Gn), h !== Un && (b += "rotateX(" + h + Gn), u === Un && d === Un || (b += "skew(" + u + ", " + d + Gn), 1 === p && 1 === f || (b += "scale(" + p + ", " + f + Gn), v.style[Cn] = b || "translate(0, 0)"
        },
        Vn = function(e, t) {
            var i, n, r, o, a, s = t || this,
                l = s.xPercent,
                c = s.yPercent,
                h = s.x,
                u = s.y,
                d = s.rotation,
                p = s.skewX,
                f = s.skewY,
                m = s.scaleX,
                g = s.scaleY,
                v = s.target,
                y = s.xOrigin,
                b = s.yOrigin,
                w = s.xOffset,
                _ = s.yOffset,
                E = s.forceCSS,
                M = parseFloat(h),
                T = parseFloat(u);
            d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= _n, p *= _n, i = Math.cos(d) * m, n = Math.sin(d) * m, r = Math.sin(d - p) * -g, o = Math.cos(d - p) * g, p && (f *= _n, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), o *= a, f && (a = Math.tan(f), i *= a = Math.sqrt(1 + a * a), n *= a)), i = x(i), n = x(n), r = x(r), o = x(o)) : (i = m, o = g, n = r = 0), (M && !~(h + "").indexOf("px") || T && !~(u + "").indexOf("px")) && (M = zi(v, "x", h, "px"), T = zi(v, "y", u, "px")), (y || b || w || _) && (M = x(M + y - (y * i + b * r) + w), T = x(T + b - (y * n + b * o) + _)), (l || c) && (M = x(M + l / 100 * (a = v.getBBox()).width), T = x(T + c / 100 * a.height)), a = "matrix(" + i + "," + n + "," + r + "," + o + "," + M + "," + T + ")", v.setAttribute("transform", a), E && (v.style[Cn] = a)
        };
    b("padding,margin,Width,Radius", (function(e, t) {
        var i = "Right",
            n = "Bottom",
            r = "Left",
            o = (t < 3 ? ["Top", i, n, r] : ["Top" + r, "Top" + i, n + i, n + r]).map((function(i) {
                return t < 2 ? e + i : "border" + i + e
            }));
        In[1 < t ? "border" + e : e] = function(e, t, i, n, r) {
            var a, s;
            if (arguments.length < 4) return a = o.map((function(t) {
                return Ni(e, t, i)
            })), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s;
            a = (n + "").split(" "), s = {}, o.forEach((function(e, t) {
                return s[e] = a[t] = a[t] || a[(t - 1) / 2 | 0]
            })), e.init(t, s, r)
        }
    }));
    var Wn, qn, Xn = {
        name: "css",
        register: Ci,
        targetTest: function(e) {
            return e.style && e.nodeType
        },
        init: function(e, t, i, n, r) {
            var o, a, s, l, c, h, u, p, f, m, g, v, y, b, x, w = this._props,
                _ = e.style,
                E = i.vars.startAt;
            for (u in Qi || Ci(), t)
                if ("autoRound" !== u && (a = t[u], !lt[u] || !Ht(u, t, i, n, e, r)))
                    if (c = typeof a, h = In[u], "function" === c && (c = typeof(a = a.call(i, n, e, r))), "string" === c && ~a.indexOf("random(") && (a = ee(a)), h) h(this, e, u, a, i) && (x = 1);
                    else if ("--" === u.substr(0, 2)) o = (getComputedStyle(e).getPropertyValue(u) + "").trim(), a += "", Tt.lastIndex = 0, Tt.test(o) || (p = q(o), f = q(a)), f ? p !== f && (o = zi(e, u, o, f) + f) : p && (a += p), this.add(_, "setProperty", o, a, n, r, 0, 0, u), w.push(u);
            else if ("undefined" !== c) {
                if (E && u in E ? (o = "function" == typeof E[u] ? E[u].call(i, n, e, r) : E[u], u in ke.units && !q(o) && (o += ke.units[u]), "=" === (o + "").charAt(1) && (o = Ni(e, u))) : o = Ni(e, u), l = parseFloat(o), (m = "string" === c && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), s = parseFloat(a), u in An && ("autoAlpha" === u && (1 === l && "hidden" === Ni(e, "visibility") && s && (l = 0), Ii(this, _, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== u && "transform" !== u && ~(u = An[u]).indexOf(",") && (u = u.split(",")[0])), g = u in xn)
                    if (v || ((y = e._gsap).renderTransform && !t.parseTransform || Bn(e, t.parseTransform), b = !1 !== t.smoothOrigin && y.smooth, (v = this._pt = new li(this._pt, _, Cn, 0, 1, y.renderTransform, y, 0, -1)).dep = 1), "scale" === u) this._pt = new li(this._pt, y, "scaleY", y.scaleY, (m ? m * s : s - y.scaleY) || 0), w.push("scaleY", u), u += "X";
                    else {
                        if ("transformOrigin" === u) {
                            a = Fi(a), y.svg ? ji(e, a, 0, b, 0, this) : ((f = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && Ii(this, y, "zOrigin", y.zOrigin, f), Ii(this, _, u, Fn(o), Fn(a)));
                            continue
                        }
                        if ("svgOrigin" === u) {
                            ji(e, a, 1, b, 0, this);
                            continue
                        }
                        if (u in Nn) {
                            Wi(this, y, u, l, a, m);
                            continue
                        }
                        if ("smoothOrigin" === u) {
                            Ii(this, y, "smooth", y.smooth, a);
                            continue
                        }
                        if ("force3D" === u) {
                            y[u] = a;
                            continue
                        }
                        if ("transform" === u) {
                            Xi(this, a, e);
                            continue
                        }
                    }
                else u in _ || (u = Pn(u) || u);
                if (g || (s || 0 === s) && (l || 0 === l) && !Sn.test(a) && u in _) s = s || 0, (p = (o + "").substr((l + "").length)) !== (f = q(a) || (u in ke.units ? ke.units[u] : p)) && (l = zi(e, u, o, f)), this._pt = new li(this._pt, g ? y : _, u, l, m ? m * s : s - l, g || "px" !== f && "zIndex" !== u || !1 === t.autoRound ? fi : vi), this._pt.u = f || 0, p !== f && (this._pt.b = o, this._pt.r = gi);
                else if (u in _) Bi.call(this, e, u, o, a);
                else {
                    if (!(u in e)) {
                        d(u, a);
                        continue
                    }
                    this.add(e, u, o || e[u], a, n, r)
                }
                w.push(u)
            }
            x && si(this)
        },
        get: Ni,
        aliases: An,
        getSetter: function(e, t, i) {
            var n = An[t];
            return n && n.indexOf(",") < 0 && (t = n), t in xn && t !== Ln && (e._gsap.x || Ni(e, "x")) ? i && Ki === i ? "scale" === t ? Ei : _i : (Ki = i || {}) && ("scale" === t ? Mi : Ti) : e.style && !a(e.style[t]) ? xi : ~t.indexOf("-") ? wi : ei(e, t)
        },
        core: {
            _removeProperty: Oi,
            _getMatrix: Gi
        }
    };
    pi.utils.checkPrefix = Pn, qn = b("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (Wn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
        xn[e] = 1
    })), b(Wn, (function(e) {
        ke.units[e] = "deg", Nn[e] = 1
    })), An[qn[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Wn, b("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
        var t = e.split(":");
        An[t[1]] = qn[t[0]]
    })), b("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
        ke.units[e] = "px"
    })), pi.registerPlugin(Xn);
    var Yn = pi.registerPlugin(Xn) || pi,
        Zn = Yn.core.Tween;
    e.Back = fn, e.Bounce = gn, e.CSSPlugin = Xn, e.Circ = bn, e.Cubic = cn, e.Elastic = pn, e.Expo = yn, e.Linear = sn, e.Power0 = tn, e.Power1 = nn, e.Power2 = rn, e.Power3 = on, e.Power4 = an, e.Quad = ln, e.Quart = hn, e.Quint = un, e.Sine = vn, e.SteppedEase = mn, e.Strong = dn, e.TimelineLite = Ut, e.TimelineMax = Ut, e.TweenLite = Yt, e.TweenMax = Zn, e.default = Yn, e.gsap = Yn, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
        value: !0
    }) : delete e.default
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function() {
    function e() {}
    var t = e.prototype;
    return t.on = function(e, t) {
        if (e && t) {
            var i = this._events = this._events || {},
                n = i[e] = i[e] || [];
            return -1 == n.indexOf(t) && n.push(t), this
        }
    }, t.once = function(e, t) {
        if (e && t) {
            this.on(e, t);
            var i = this._onceEvents = this._onceEvents || {};
            return (i[e] = i[e] || {})[t] = !0, this
        }
    }, t.off = function(e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            var n = i.indexOf(t);
            return -1 != n && i.splice(n, 1), this
        }
    }, t.emitEvent = function(e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            i = i.slice(0), t = t || [];
            for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
                var o = i[r];
                n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
            }
            return this
        }
    }, t.allOff = function() {
        delete this._events, delete this._onceEvents
    }, e
})),
function(e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], (function(i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter)
}("undefined" != typeof window ? window : this, (function(e, t) {
    function i(e, t) {
        for (var i in t) e[i] = t[i];
        return e
    }

    function n(e, t, r) {
        if (!(this instanceof n)) return new n(e, t, r);
        var o, c = e;
        return "string" == typeof e && (c = document.querySelectorAll(e)), c ? (this.elements = (o = c, Array.isArray(o) ? o : "object" == typeof o && "number" == typeof o.length ? l.call(o) : [o]), this.options = i({}, this.options), "function" == typeof t ? r = t : i(this.options, t), r && this.on("always", r), this.getImages(), a && (this.jqDeferred = new a.Deferred), void setTimeout(this.check.bind(this))) : void s.error("Bad element for imagesLoaded " + (c || e))
    }

    function r(e) {
        this.img = e
    }

    function o(e, t) {
        this.url = e, this.element = t, this.img = new Image
    }
    var a = e.jQuery,
        s = e.console,
        l = Array.prototype.slice;
    (n.prototype = Object.create(t.prototype)).options = {}, n.prototype.getImages = function() {
        this.images = [], this.elements.forEach(this.addElementImages, this)
    }, n.prototype.addElementImages = function(e) {
        "IMG" == e.nodeName && this.addImage(e), !0 === this.options.background && this.addElementBackgroundImages(e);
        var t = e.nodeType;
        if (t && c[t]) {
            for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) {
                var r = i[n];
                this.addImage(r)
            }
            if ("string" == typeof this.options.background) {
                var o = e.querySelectorAll(this.options.background);
                for (n = 0; n < o.length; n++) {
                    var a = o[n];
                    this.addElementBackgroundImages(a)
                }
            }
        }
    };
    var c = {
        1: !0,
        9: !0,
        11: !0
    };
    return n.prototype.addElementBackgroundImages = function(e) {
        var t = getComputedStyle(e);
        if (t)
            for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) {
                var r = n && n[2];
                r && this.addBackground(r, e), n = i.exec(t.backgroundImage)
            }
    }, n.prototype.addImage = function(e) {
        var t = new r(e);
        this.images.push(t)
    }, n.prototype.addBackground = function(e, t) {
        var i = new o(e, t);
        this.images.push(i)
    }, n.prototype.check = function() {
        function e(e, i, n) {
            setTimeout((function() {
                t.progress(e, i, n)
            }))
        }
        var t = this;
        return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function(t) {
            t.once("progress", e), t.check()
        })) : void this.complete()
    }, n.prototype.progress = function(e, t, i) {
        this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && s && s.log("progress: " + i, e, t)
    }, n.prototype.complete = function() {
        var e = this.hasAnyBroken ? "fail" : "done";
        if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
            var t = this.hasAnyBroken ? "reject" : "resolve";
            this.jqDeferred[t](this)
        }
    }, (r.prototype = Object.create(t.prototype)).check = function() {
        return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void(this.proxyImage.src = this.img.src))
    }, r.prototype.getIsImageComplete = function() {
        return this.img.complete && this.img.naturalWidth
    }, r.prototype.confirm = function(e, t) {
        this.isLoaded = e, this.emitEvent("progress", [this, this.img, t])
    }, r.prototype.handleEvent = function(e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, r.prototype.onload = function() {
        this.confirm(!0, "onload"), this.unbindEvents()
    }, r.prototype.onerror = function() {
        this.confirm(!1, "onerror"), this.unbindEvents()
    }, r.prototype.unbindEvents = function() {
        this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
    }, (o.prototype = Object.create(r.prototype)).check = function() {
        this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents())
    }, o.prototype.unbindEvents = function() {
        this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
    }, o.prototype.confirm = function(e, t) {
        this.isLoaded = e, this.emitEvent("progress", [this, this.element, t])
    }, n.makeJQueryPlugin = function(t) {
        (t = t || e.jQuery) && ((a = t).fn.imagesLoaded = function(e, t) {
            return new n(this, e, t).jqDeferred.promise(a(this))
        })
    }, n.makeJQueryPlugin(), n
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], (function(i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) : e.jQueryBridget = t(e, e.jQuery)
}(window, (function(e, t) {
    "use strict";

    function i(i, o, s) {
        (s = s || t || e.jQuery) && (o.prototype.option || (o.prototype.option = function(e) {
            s.isPlainObject(e) && (this.options = s.extend(!0, this.options, e))
        }), s.fn[i] = function(e) {
            if ("string" != typeof e) return u = e, this.each((function(e, t) {
                var n = s.data(t, i);
                n ? (n.option(u), n._init()) : (n = new o(t, u), s.data(t, i, n))
            })), this;
            var t, n, l, c, h, u, d = r.call(arguments, 1);
            return l = d, h = "$()." + i + '("' + (n = e) + '")', (t = this).each((function(e, t) {
                var r = s.data(t, i);
                if (r) {
                    var o = r[n];
                    if (o && "_" != n.charAt(0)) {
                        var u = o.apply(r, l);
                        c = void 0 === c ? u : c
                    } else a(h + " is not a valid method")
                } else a(i + " not initialized. Cannot call methods, i.e. " + h)
            })), void 0 !== c ? c : t
        }, n(s))
    }

    function n(e) {
        !e || e && e.bridget || (e.bridget = i)
    }
    var r = Array.prototype.slice,
        o = e.console,
        a = void 0 === o ? function() {} : function(e) {
            o.error(e)
        };
    return n(t || e.jQuery), i
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function() {
    function e() {}
    var t = e.prototype;
    return t.on = function(e, t) {
        if (e && t) {
            var i = this._events = this._events || {},
                n = i[e] = i[e] || [];
            return -1 == n.indexOf(t) && n.push(t), this
        }
    }, t.once = function(e, t) {
        if (e && t) {
            this.on(e, t);
            var i = this._onceEvents = this._onceEvents || {};
            return (i[e] = i[e] || {})[t] = !0, this
        }
    }, t.off = function(e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            var n = i.indexOf(t);
            return -1 != n && i.splice(n, 1), this
        }
    }, t.emitEvent = function(e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            i = i.slice(0), t = t || [];
            for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
                var o = i[r];
                n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
            }
            return this
        }
    }, t.allOff = function() {
        delete this._events, delete this._onceEvents
    }, e
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" == typeof module && module.exports ? module.exports = t() : e.getSize = t()
}(window, (function() {
    "use strict";

    function e(e) {
        var t = parseFloat(e);
        return -1 == e.indexOf("%") && !isNaN(t) && t
    }

    function t(e) {
        var t = getComputedStyle(e);
        return t || n("Style returned " + t + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), t
    }
    var i, n = "undefined" == typeof console ? function() {} : function(e) {
            console.error(e)
        },
        r = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
        o = r.length,
        a = !1;
    return function n(s) {
        if (function() {
                if (!a) {
                    a = !0;
                    var r = document.createElement("div");
                    r.style.width = "200px", r.style.padding = "1px 2px 3px 4px", r.style.borderStyle = "solid", r.style.borderWidth = "1px 2px 3px 4px", r.style.boxSizing = "border-box";
                    var o = document.body || document.documentElement;
                    o.appendChild(r);
                    var s = t(r);
                    i = 200 == Math.round(e(s.width)), n.isBoxSizeOuter = i, o.removeChild(r)
                }
            }(), "string" == typeof s && (s = document.querySelector(s)), s && "object" == typeof s && s.nodeType) {
            var l = t(s);
            if ("none" == l.display) return function() {
                for (var e = {
                        width: 0,
                        height: 0,
                        innerWidth: 0,
                        innerHeight: 0,
                        outerWidth: 0,
                        outerHeight: 0
                    }, t = 0; t < o; t++) e[r[t]] = 0;
                return e
            }();
            var c = {};
            c.width = s.offsetWidth, c.height = s.offsetHeight;
            for (var h = c.isBorderBox = "border-box" == l.boxSizing, u = 0; u < o; u++) {
                var d = r[u],
                    p = l[d],
                    f = parseFloat(p);
                c[d] = isNaN(f) ? 0 : f
            }
            var m = c.paddingLeft + c.paddingRight,
                g = c.paddingTop + c.paddingBottom,
                v = c.marginLeft + c.marginRight,
                y = c.marginTop + c.marginBottom,
                b = c.borderLeftWidth + c.borderRightWidth,
                x = c.borderTopWidth + c.borderBottomWidth,
                w = h && i,
                _ = e(l.width);
            !1 !== _ && (c.width = _ + (w ? 0 : m + b));
            var E = e(l.height);
            return !1 !== E && (c.height = E + (w ? 0 : g + x)), c.innerWidth = c.width - (m + b), c.innerHeight = c.height - (g + x), c.outerWidth = c.width + v, c.outerHeight = c.height + y, c
        }
    }
})),
function(e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) : "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t()
}(window, (function() {
    "use strict";
    var e = function() {
        var e = window.Element.prototype;
        if (e.matches) return "matches";
        if (e.matchesSelector) return "matchesSelector";
        for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) {
            var n = t[i] + "MatchesSelector";
            if (e[n]) return n
        }
    }();
    return function(t, i) {
        return t[e](i)
    }
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], (function(i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector)
}(window, (function(e, t) {
    var i = {
            extend: function(e, t) {
                for (var i in t) e[i] = t[i];
                return e
            },
            modulo: function(e, t) {
                return (e % t + t) % t
            }
        },
        n = Array.prototype.slice;
    i.makeArray = function(e) {
        return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? n.call(e) : [e]
    }, i.removeFrom = function(e, t) {
        var i = e.indexOf(t); - 1 != i && e.splice(i, 1)
    }, i.getParent = function(e, i) {
        for (; e.parentNode && e != document.body;)
            if (e = e.parentNode, t(e, i)) return e
    }, i.getQueryElement = function(e) {
        return "string" == typeof e ? document.querySelector(e) : e
    }, i.handleEvent = function(e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, i.filterFindElements = function(e, n) {
        e = i.makeArray(e);
        var r = [];
        return e.forEach((function(e) {
            if (e instanceof HTMLElement) {
                if (!n) return void r.push(e);
                t(e, n) && r.push(e);
                for (var i = e.querySelectorAll(n), o = 0; o < i.length; o++) r.push(i[o])
            }
        })), r
    }, i.debounceMethod = function(e, t, i) {
        i = i || 100;
        var n = e.prototype[t],
            r = t + "Timeout";
        e.prototype[t] = function() {
            var e = this[r];
            clearTimeout(e);
            var t = arguments,
                o = this;
            this[r] = setTimeout((function() {
                n.apply(o, t), delete o[r]
            }), i)
        }
    }, i.docReady = function(e) {
        var t = document.readyState;
        "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e)
    }, i.toDashed = function(e) {
        return e.replace(/(.)([A-Z])/g, (function(e, t, i) {
            return t + "-" + i
        })).toLowerCase()
    };
    var r = e.console;
    return i.htmlInit = function(t, n) {
        i.docReady((function() {
            var o = i.toDashed(n),
                a = "data-" + o,
                s = document.querySelectorAll("[" + a + "]"),
                l = document.querySelectorAll(".js-" + o),
                c = i.makeArray(s).concat(i.makeArray(l)),
                h = a + "-options",
                u = e.jQuery;
            c.forEach((function(e) {
                var i, o = e.getAttribute(a) || e.getAttribute(h);
                try {
                    i = o && JSON.parse(o)
                } catch (i) {
                    return void(r && r.error("Error parsing " + a + " on " + e.className + ": " + i))
                }
                var s = new t(e, i);
                u && u.data(e, n, s)
            }))
        }))
    }, i
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e.EvEmitter, e.getSize))
}(window, (function(e, t) {
    "use strict";

    function i(e, t) {
        e && (this.element = e, this.layout = t, this.position = {
            x: 0,
            y: 0
        }, this._create())
    }
    var n = document.documentElement.style,
        r = "string" == typeof n.transition ? "transition" : "WebkitTransition",
        o = "string" == typeof n.transform ? "transform" : "WebkitTransform",
        a = {
            WebkitTransition: "webkitTransitionEnd",
            transition: "transitionend"
        } [r],
        s = {
            transform: o,
            transition: r,
            transitionDuration: r + "Duration",
            transitionProperty: r + "Property",
            transitionDelay: r + "Delay"
        },
        l = i.prototype = Object.create(e.prototype);
    l.constructor = i, l._create = function() {
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        }, this.css({
            position: "absolute"
        })
    }, l.handleEvent = function(e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, l.getSize = function() {
        this.size = t(this.element)
    }, l.css = function(e) {
        var t = this.element.style;
        for (var i in e) t[s[i] || i] = e[i]
    }, l.getPosition = function() {
        var e = getComputedStyle(this.element),
            t = this.layout._getOption("originLeft"),
            i = this.layout._getOption("originTop"),
            n = e[t ? "left" : "right"],
            r = e[i ? "top" : "bottom"],
            o = parseFloat(n),
            a = parseFloat(r),
            s = this.layout.size; - 1 != n.indexOf("%") && (o = o / 100 * s.width), -1 != r.indexOf("%") && (a = a / 100 * s.height), o = isNaN(o) ? 0 : o, a = isNaN(a) ? 0 : a, o -= t ? s.paddingLeft : s.paddingRight, a -= i ? s.paddingTop : s.paddingBottom, this.position.x = o, this.position.y = a
    }, l.layoutPosition = function() {
        var e = this.layout.size,
            t = {},
            i = this.layout._getOption("originLeft"),
            n = this.layout._getOption("originTop"),
            r = i ? "paddingLeft" : "paddingRight",
            o = i ? "left" : "right",
            a = i ? "right" : "left",
            s = this.position.x + e[r];
        t[o] = this.getXValue(s), t[a] = "";
        var l = n ? "paddingTop" : "paddingBottom",
            c = n ? "top" : "bottom",
            h = n ? "bottom" : "top",
            u = this.position.y + e[l];
        t[c] = this.getYValue(u), t[h] = "", this.css(t), this.emitEvent("layout", [this])
    }, l.getXValue = function(e) {
        var t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px"
    }, l.getYValue = function(e) {
        var t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px"
    }, l._transitionTo = function(e, t) {
        this.getPosition();
        var i = this.position.x,
            n = this.position.y,
            r = e == this.position.x && t == this.position.y;
        if (this.setPosition(e, t), !r || this.isTransitioning) {
            var o = e - i,
                a = t - n,
                s = {};
            s.transform = this.getTranslate(o, a), this.transition({
                to: s,
                onTransitionEnd: {
                    transform: this.layoutPosition
                },
                isCleaning: !0
            })
        } else this.layoutPosition()
    }, l.getTranslate = function(e, t) {
        return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)"
    }, l.goTo = function(e, t) {
        this.setPosition(e, t), this.layoutPosition()
    }, l.moveTo = l._transitionTo, l.setPosition = function(e, t) {
        this.position.x = parseFloat(e), this.position.y = parseFloat(t)
    }, l._nonTransition = function(e) {
        for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this)
    }, l.transition = function(e) {
        if (parseFloat(this.layout.options.transitionDuration)) {
            var t = this._transn;
            for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i];
            for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0);
            e.from && (this.css(e.from), this.element.offsetHeight), this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0
        } else this._nonTransition(e)
    };
    var c = "opacity," + o.replace(/([A-Z])/g, (function(e) {
        return "-" + e.toLowerCase()
    }));
    l.enableTransition = function() {
        if (!this.isTransitioning) {
            var e = this.layout.options.transitionDuration;
            e = "number" == typeof e ? e + "ms" : e, this.css({
                transitionProperty: c,
                transitionDuration: e,
                transitionDelay: this.staggerDelay || 0
            }), this.element.addEventListener(a, this, !1)
        }
    }, l.onwebkitTransitionEnd = function(e) {
        this.ontransitionend(e)
    }, l.onotransitionend = function(e) {
        this.ontransitionend(e)
    };
    var h = {
        "-webkit-transform": "transform"
    };
    l.ontransitionend = function(e) {
        if (e.target === this.element) {
            var t = this._transn,
                i = h[e.propertyName] || e.propertyName;
            delete t.ingProperties[i],
                function(e) {
                    for (var t in e) return !1;
                    return !0
                }(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd && (t.onEnd[i].call(this), delete t.onEnd[i]), this.emitEvent("transitionEnd", [this])
        }
    }, l.disableTransition = function() {
        this.removeTransitionStyles(), this.element.removeEventListener(a, this, !1), this.isTransitioning = !1
    }, l._removeStyles = function(e) {
        var t = {};
        for (var i in e) t[i] = "";
        this.css(t)
    };
    var u = {
        transitionProperty: "",
        transitionDuration: "",
        transitionDelay: ""
    };
    return l.removeTransitionStyles = function() {
        this.css(u)
    }, l.stagger = function(e) {
        e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms"
    }, l.removeElem = function() {
        this.element.parentNode.removeChild(this.element), this.css({
            display: ""
        }), this.emitEvent("remove", [this])
    }, l.remove = function() {
        return r && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function() {
            this.removeElem()
        })), void this.hide()) : void this.removeElem()
    }, l.reveal = function() {
        delete this.isHidden, this.css({
            display: ""
        });
        var e = this.layout.options,
            t = {};
        t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({
            from: e.hiddenStyle,
            to: e.visibleStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, l.onRevealTransitionEnd = function() {
        this.isHidden || this.emitEvent("reveal")
    }, l.getHideRevealTransitionEndProperty = function(e) {
        var t = this.layout.options[e];
        if (t.opacity) return "opacity";
        for (var i in t) return i
    }, l.hide = function() {
        this.isHidden = !0, this.css({
            display: ""
        });
        var e = this.layout.options,
            t = {};
        t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({
            from: e.visibleStyle,
            to: e.hiddenStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, l.onHideTransitionEnd = function() {
        this.isHidden && (this.css({
            display: "none"
        }), this.emitEvent("hide"))
    }, l.destroy = function() {
        this.css({
            position: "",
            left: "",
            right: "",
            top: "",
            bottom: "",
            transition: "",
            transform: ""
        })
    }, i
})),
function(e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (function(i, n, r, o) {
        return t(e, i, n, r, o)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item)
}(window, (function(e, t, i, n, r) {
    "use strict";

    function o(e, t) {
        var i = n.getQueryElement(e);
        if (i) {
            this.element = i, l && (this.$element = l(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(t);
            var r = ++h;
            this.element.outlayerGUID = r, (u[r] = this)._create(), this._getOption("initLayout") && this.layout()
        } else s && s.error("Bad element for " + this.constructor.namespace + ": " + (i || e))
    }

    function a(e) {
        function t() {
            e.apply(this, arguments)
        }
        return (t.prototype = Object.create(e.prototype)).constructor = t
    }
    var s = e.console,
        l = e.jQuery,
        c = function() {},
        h = 0,
        u = {};
    o.namespace = "outlayer", o.Item = r, o.defaults = {
        containerStyle: {
            position: "relative"
        },
        initLayout: !0,
        originLeft: !0,
        originTop: !0,
        resize: !0,
        resizeContainer: !0,
        transitionDuration: "0.4s",
        hiddenStyle: {
            opacity: 0,
            transform: "scale(0.001)"
        },
        visibleStyle: {
            opacity: 1,
            transform: "scale(1)"
        }
    };
    var d = o.prototype;
    n.extend(d, t.prototype), d.option = function(e) {
        n.extend(this.options, e)
    }, d._getOption = function(e) {
        var t = this.constructor.compatOptions[e];
        return t && void 0 !== this.options[t] ? this.options[t] : this.options[e]
    }, o.compatOptions = {
        initLayout: "isInitLayout",
        horizontal: "isHorizontal",
        layoutInstant: "isLayoutInstant",
        originLeft: "isOriginLeft",
        originTop: "isOriginTop",
        resize: "isResizeBound",
        resizeContainer: "isResizingContainer"
    }, d._create = function() {
        this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize()
    }, d.reloadItems = function() {
        this.items = this._itemize(this.element.children)
    }, d._itemize = function(e) {
        for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], r = 0; r < t.length; r++) {
            var o = new i(t[r], this);
            n.push(o)
        }
        return n
    }, d._filterFindItemElements = function(e) {
        return n.filterFindElements(e, this.options.itemSelector)
    }, d.getItemElements = function() {
        return this.items.map((function(e) {
            return e.element
        }))
    }, d.layout = function() {
        this._resetLayout(), this._manageStamps();
        var e = this._getOption("layoutInstant"),
            t = void 0 !== e ? e : !this._isLayoutInited;
        this.layoutItems(this.items, t), this._isLayoutInited = !0
    }, d._init = d.layout, d._resetLayout = function() {
        this.getSize()
    }, d.getSize = function() {
        this.size = i(this.element)
    }, d._getMeasurement = function(e, t) {
        var n, r = this.options[e];
        r ? ("string" == typeof r ? n = this.element.querySelector(r) : r instanceof HTMLElement && (n = r), this[e] = n ? i(n)[t] : r) : this[e] = 0
    }, d.layoutItems = function(e, t) {
        e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout()
    }, d._getItemsForLayout = function(e) {
        return e.filter((function(e) {
            return !e.isIgnored
        }))
    }, d._layoutItems = function(e, t) {
        if (this._emitCompleteOnItems("layout", e), e && e.length) {
            var i = [];
            e.forEach((function(e) {
                var n = this._getItemLayoutPosition(e);
                n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n)
            }), this), this._processLayoutQueue(i)
        }
    }, d._getItemLayoutPosition = function() {
        return {
            x: 0,
            y: 0
        }
    }, d._processLayoutQueue = function(e) {
        this.updateStagger(), e.forEach((function(e, t) {
            this._positionItem(e.item, e.x, e.y, e.isInstant, t)
        }), this)
    }, d.updateStagger = function() {
        var e = this.options.stagger;
        return null == e ? void(this.stagger = 0) : (this.stagger = function(e) {
            if ("number" == typeof e) return e;
            var t = e.match(/(^\d*\.?\d*)(\w*)/),
                i = t && t[1],
                n = t && t[2];
            return i.length ? (i = parseFloat(i)) * (p[n] || 1) : 0
        }(e), this.stagger)
    }, d._positionItem = function(e, t, i, n, r) {
        n ? e.goTo(t, i) : (e.stagger(r * this.stagger), e.moveTo(t, i))
    }, d._postLayout = function() {
        this.resizeContainer()
    }, d.resizeContainer = function() {
        if (this._getOption("resizeContainer")) {
            var e = this._getContainerSize();
            e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1))
        }
    }, d._getContainerSize = c, d._setContainerMeasure = function(e, t) {
        if (void 0 !== e) {
            var i = this.size;
            i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px"
        }
    }, d._emitCompleteOnItems = function(e, t) {
        function i() {
            r.dispatchEvent(e + "Complete", null, [t])
        }

        function n() {
            ++a == o && i()
        }
        var r = this,
            o = t.length;
        if (t && o) {
            var a = 0;
            t.forEach((function(t) {
                t.once(e, n)
            }))
        } else i()
    }, d.dispatchEvent = function(e, t, i) {
        var n = t ? [t].concat(i) : i;
        if (this.emitEvent(e, n), l)
            if (this.$element = this.$element || l(this.element), t) {
                var r = l.Event(t);
                r.type = e, this.$element.trigger(r, i)
            } else this.$element.trigger(e, i)
    }, d.ignore = function(e) {
        var t = this.getItem(e);
        t && (t.isIgnored = !0)
    }, d.unignore = function(e) {
        var t = this.getItem(e);
        t && delete t.isIgnored
    }, d.stamp = function(e) {
        (e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this))
    }, d.unstamp = function(e) {
        (e = this._find(e)) && e.forEach((function(e) {
            n.removeFrom(this.stamps, e), this.unignore(e)
        }), this)
    }, d._find = function(e) {
        if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), n.makeArray(e)
    }, d._manageStamps = function() {
        this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this))
    }, d._getBoundingRect = function() {
        var e = this.element.getBoundingClientRect(),
            t = this.size;
        this._boundingRect = {
            left: e.left + t.paddingLeft + t.borderLeftWidth,
            top: e.top + t.paddingTop + t.borderTopWidth,
            right: e.right - (t.paddingRight + t.borderRightWidth),
            bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth)
        }
    }, d._manageStamp = c, d._getElementOffset = function(e) {
        var t = e.getBoundingClientRect(),
            n = this._boundingRect,
            r = i(e);
        return {
            left: t.left - n.left - r.marginLeft,
            top: t.top - n.top - r.marginTop,
            right: n.right - t.right - r.marginRight,
            bottom: n.bottom - t.bottom - r.marginBottom
        }
    }, d.handleEvent = n.handleEvent, d.bindResize = function() {
        e.addEventListener("resize", this), this.isResizeBound = !0
    }, d.unbindResize = function() {
        e.removeEventListener("resize", this), this.isResizeBound = !1
    }, d.onresize = function() {
        this.resize()
    }, n.debounceMethod(o, "onresize", 100), d.resize = function() {
        this.isResizeBound && this.needsResizeLayout() && this.layout()
    }, d.needsResizeLayout = function() {
        var e = i(this.element);
        return this.size && e && e.innerWidth !== this.size.innerWidth
    }, d.addItems = function(e) {
        var t = this._itemize(e);
        return t.length && (this.items = this.items.concat(t)), t
    }, d.appended = function(e) {
        var t = this.addItems(e);
        t.length && (this.layoutItems(t, !0), this.reveal(t))
    }, d.prepended = function(e) {
        var t = this._itemize(e);
        if (t.length) {
            var i = this.items.slice(0);
            this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i)
        }
    }, d.reveal = function(e) {
        if (this._emitCompleteOnItems("reveal", e), e && e.length) {
            var t = this.updateStagger();
            e.forEach((function(e, i) {
                e.stagger(i * t), e.reveal()
            }))
        }
    }, d.hide = function(e) {
        if (this._emitCompleteOnItems("hide", e), e && e.length) {
            var t = this.updateStagger();
            e.forEach((function(e, i) {
                e.stagger(i * t), e.hide()
            }))
        }
    }, d.revealItemElements = function(e) {
        var t = this.getItems(e);
        this.reveal(t)
    }, d.hideItemElements = function(e) {
        var t = this.getItems(e);
        this.hide(t)
    }, d.getItem = function(e) {
        for (var t = 0; t < this.items.length; t++) {
            var i = this.items[t];
            if (i.element == e) return i
        }
    }, d.getItems = function(e) {
        e = n.makeArray(e);
        var t = [];
        return e.forEach((function(e) {
            var i = this.getItem(e);
            i && t.push(i)
        }), this), t
    }, d.remove = function(e) {
        var t = this.getItems(e);
        this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function(e) {
            e.remove(), n.removeFrom(this.items, e)
        }), this)
    }, d.destroy = function() {
        var e = this.element.style;
        e.height = "", e.position = "", e.width = "", this.items.forEach((function(e) {
            e.destroy()
        })), this.unbindResize();
        var t = this.element.outlayerGUID;
        delete u[t], delete this.element.outlayerGUID, l && l.removeData(this.element, this.constructor.namespace)
    }, o.data = function(e) {
        var t = (e = n.getQueryElement(e)) && e.outlayerGUID;
        return t && u[t]
    }, o.create = function(e, t) {
        var i = a(o);
        return i.defaults = n.extend({}, o.defaults), n.extend(i.defaults, t), i.compatOptions = n.extend({}, o.compatOptions), i.namespace = e, i.data = o.data, i.Item = a(r), n.htmlInit(i, e), l && l.bridget && l.bridget(e, i), i
    };
    var p = {
        ms: 1,
        s: 1e3
    };
    return o.Item = r, o
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/item", ["outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.Item = t(e.Outlayer))
}(window, (function(e) {
    "use strict";

    function t() {
        e.Item.apply(this, arguments)
    }
    var i = t.prototype = Object.create(e.Item.prototype),
        n = i._create;
    i._create = function() {
        this.id = this.layout.itemGUID++, n.call(this), this.sortData = {}
    }, i.updateSortData = function() {
        if (!this.isIgnored) {
            this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random();
            var e = this.layout.options.getSortData,
                t = this.layout._sorters;
            for (var i in e) {
                var n = t[i];
                this.sortData[i] = n(this.element, this)
            }
        }
    };
    var r = i.destroy;
    return i.destroy = function() {
        r.apply(this, arguments), this.css({
            display: ""
        })
    }, t
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("get-size"), require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.LayoutMode = t(e.getSize, e.Outlayer))
}(window, (function(e, t) {
    "use strict";

    function i(e) {
        (this.isotope = e) && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size)
    }
    var n = i.prototype;
    return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function(e) {
        n[e] = function() {
            return t.prototype[e].apply(this.isotope, arguments)
        }
    })), n.needsVerticalResizeLayout = function() {
        var t = e(this.isotope.element);
        return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight
    }, n._getMeasurement = function() {
        this.isotope._getMeasurement.apply(this, arguments)
    }, n.getColumnWidth = function() {
        this.getSegmentSize("column", "Width")
    }, n.getRowHeight = function() {
        this.getSegmentSize("row", "Height")
    }, n.getSegmentSize = function(e, t) {
        var i = e + t,
            n = "outer" + t;
        if (this._getMeasurement(i, n), !this[i]) {
            var r = this.getFirstItemSize();
            this[i] = r && r[n] || this.isotope.size["inner" + t]
        }
    }, n.getFirstItemSize = function() {
        var t = this.isotope.filteredItems[0];
        return t && t.element && e(t.element)
    }, n.layout = function() {
        this.isotope.layout.apply(this.isotope, arguments)
    }, n.getSize = function() {
        this.isotope.getSize(), this.size = this.isotope.size
    }, i.modes = {}, i.create = function(e, t) {
        function r() {
            i.apply(this, arguments)
        }
        return (r.prototype = Object.create(n)).constructor = r, t && (r.options = t), i.modes[r.prototype.namespace = e] = r
    }, i
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require("get-size")) : e.Masonry = t(e.Outlayer, e.getSize)
}(window, (function(e, t) {
    var i = e.create("masonry");
    i.compatOptions.fitWidth = "isFitWidth";
    var n = i.prototype;
    return n._resetLayout = function() {
        this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
        for (var e = 0; e < this.cols; e++) this.colYs.push(0);
        this.maxY = 0, this.horizontalColIndex = 0
    }, n.measureColumns = function() {
        if (this.getContainerWidth(), !this.columnWidth) {
            var e = this.items[0],
                i = e && e.element;
            this.columnWidth = i && t(i).outerWidth || this.containerWidth
        }
        var n = this.columnWidth += this.gutter,
            r = this.containerWidth + this.gutter,
            o = r / n,
            a = n - r % n;
        o = Math[a && a < 1 ? "round" : "floor"](o), this.cols = Math.max(o, 1)
    }, n.getContainerWidth = function() {
        var e = this._getOption("fitWidth") ? this.element.parentNode : this.element,
            i = t(e);
        this.containerWidth = i && i.innerWidth
    }, n._getItemLayoutPosition = function(e) {
        e.getSize();
        var t = e.size.outerWidth % this.columnWidth,
            i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth);
        i = Math.min(i, this.cols);
        for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), r = {
                x: this.columnWidth * n.col,
                y: n.y
            }, o = n.y + e.size.outerHeight, a = i + n.col, s = n.col; s < a; s++) this.colYs[s] = o;
        return r
    }, n._getTopColPosition = function(e) {
        var t = this._getTopColGroup(e),
            i = Math.min.apply(Math, t);
        return {
            col: t.indexOf(i),
            y: i
        }
    }, n._getTopColGroup = function(e) {
        if (e < 2) return this.colYs;
        for (var t = [], i = this.cols + 1 - e, n = 0; n < i; n++) t[n] = this._getColGroupY(n, e);
        return t
    }, n._getColGroupY = function(e, t) {
        if (t < 2) return this.colYs[e];
        var i = this.colYs.slice(e, e + t);
        return Math.max.apply(Math, i)
    }, n._getHorizontalColPosition = function(e, t) {
        var i = this.horizontalColIndex % this.cols;
        i = 1 < e && i + e > this.cols ? 0 : i;
        var n = t.size.outerWidth && t.size.outerHeight;
        return this.horizontalColIndex = n ? i + e : this.horizontalColIndex, {
            col: i,
            y: this._getColGroupY(i, e)
        }
    }, n._manageStamp = function(e) {
        var i = t(e),
            n = this._getElementOffset(e),
            r = this._getOption("originLeft") ? n.left : n.right,
            o = r + i.outerWidth,
            a = Math.floor(r / this.columnWidth);
        a = Math.max(0, a);
        var s = Math.floor(o / this.columnWidth);
        s -= o % this.columnWidth ? 0 : 1, s = Math.min(this.cols - 1, s);
        for (var l = (this._getOption("originTop") ? n.top : n.bottom) + i.outerHeight, c = a; c <= s; c++) this.colYs[c] = Math.max(l, this.colYs[c])
    }, n._getContainerSize = function() {
        this.maxY = Math.max.apply(Math, this.colYs);
        var e = {
            height: this.maxY
        };
        return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e
    }, n._getContainerFitWidth = function() {
        for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];) e++;
        return (this.cols - e) * this.columnWidth - this.gutter
    }, n.needsResizeLayout = function() {
        var e = this.containerWidth;
        return this.getContainerWidth(), e != this.containerWidth
    }, i
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode"), require("masonry-layout")) : t(e.Isotope.LayoutMode, e.Masonry)
}(window, (function(e, t) {
    "use strict";
    var i = e.create("masonry"),
        n = i.prototype,
        r = {
            _getElementOffset: !0,
            layout: !0,
            _getMeasurement: !0
        };
    for (var o in t.prototype) r[o] || (n[o] = t.prototype[o]);
    var a = n.measureColumns;
    n.measureColumns = function() {
        this.items = this.isotope.filteredItems, a.call(this)
    };
    var s = n._getOption;
    return n._getOption = function(e) {
        return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : s.apply(this.isotope, arguments)
    }, i
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], t) : "object" == typeof exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function(e) {
    "use strict";
    var t = e.create("fitRows"),
        i = t.prototype;
    return i._resetLayout = function() {
        this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth")
    }, i._getItemLayoutPosition = function(e) {
        e.getSize();
        var t = e.size.outerWidth + this.gutter,
            i = this.isotope.size.innerWidth + this.gutter;
        0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY);
        var n = {
            x: this.x,
            y: this.y
        };
        return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, n
    }, i._getContainerSize = function() {
        return {
            height: this.maxY
        }
    }, t
})),
function(e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function(e) {
    "use strict";
    var t = e.create("vertical", {
            horizontalAlignment: 0
        }),
        i = t.prototype;
    return i._resetLayout = function() {
        this.y = 0
    }, i._getItemLayoutPosition = function(e) {
        e.getSize();
        var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment,
            i = this.y;
        return this.y += e.size.outerHeight, {
            x: t,
            y: i
        }
    }, i._getContainerSize = function() {
        return {
            height: this.y
        }
    }, t
})),
function(e, t) {
    "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], (function(i, n, r, o, a, s) {
        return t(e, i, n, r, o, a, s)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical")) : e.Isotope = t(e, e.Outlayer, e.getSize, e.matchesSelector, e.fizzyUIUtils, e.Isotope.Item, e.Isotope.LayoutMode)
}(window, (function(e, t, i, n, r, o, a) {
    var s = e.jQuery,
        l = String.prototype.trim ? function(e) {
            return e.trim()
        } : function(e) {
            return e.replace(/^\s+|\s+$/g, "")
        },
        c = t.create("isotope", {
            layoutMode: "masonry",
            isJQueryFiltering: !0,
            sortAscending: !0
        });
    c.Item = o, c.LayoutMode = a;
    var h = c.prototype;
    h._create = function() {
        for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], a.modes) this._initLayoutMode(e)
    }, h.reloadItems = function() {
        this.itemGUID = 0, t.prototype.reloadItems.call(this)
    }, h._itemize = function() {
        for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++) e[i].id = this.itemGUID++;
        return this._updateItemsSortData(e), e
    }, h._initLayoutMode = function(e) {
        var t = a.modes[e],
            i = this.options[e] || {};
        this.options[e] = t.options ? r.extend(t.options, i) : i, this.modes[e] = new t(this)
    }, h.layout = function() {
        return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout()
    }, h._layout = function() {
        var e = this._getIsInstant();
        this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0
    }, h.arrange = function(e) {
        this.option(e), this._getIsInstant();
        var t = this._filter(this.items);
        this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout()
    }, h._init = h.arrange, h._hideReveal = function(e) {
        this.reveal(e.needReveal), this.hide(e.needHide)
    }, h._getIsInstant = function() {
        var e = this._getOption("layoutInstant"),
            t = void 0 !== e ? e : !this._isLayoutInited;
        return this._isInstant = t
    }, h._bindArrangeComplete = function() {
        function e() {
            t && i && n && r.dispatchEvent("arrangeComplete", null, [r.filteredItems])
        }
        var t, i, n, r = this;
        this.once("layoutComplete", (function() {
            t = !0, e()
        })), this.once("hideComplete", (function() {
            i = !0, e()
        })), this.once("revealComplete", (function() {
            n = !0, e()
        }))
    }, h._filter = function(e) {
        var t = this.options.filter;
        t = t || "*";
        for (var i = [], n = [], r = [], o = this._getFilterTest(t), a = 0; a < e.length; a++) {
            var s = e[a];
            if (!s.isIgnored) {
                var l = o(s);
                l && i.push(s), l && s.isHidden ? n.push(s) : l || s.isHidden || r.push(s)
            }
        }
        return {
            matches: i,
            needReveal: n,
            needHide: r
        }
    }, h._getFilterTest = function(e) {
        return s && this.options.isJQueryFiltering ? function(t) {
            return s(t.element).is(e)
        } : "function" == typeof e ? function(t) {
            return e(t.element)
        } : function(t) {
            return n(t.element, e)
        }
    }, h.updateSortData = function(e) {
        var t;
        t = e ? (e = r.makeArray(e), this.getItems(e)) : this.items, this._getSorters(), this._updateItemsSortData(t)
    }, h._getSorters = function() {
        var e = this.options.getSortData;
        for (var t in e) {
            var i = e[t];
            this._sorters[t] = u(i)
        }
    }, h._updateItemsSortData = function(e) {
        for (var t = e && e.length, i = 0; t && i < t; i++) e[i].updateSortData()
    };
    var u = function(e) {
        if ("string" != typeof e) return e;
        var t, i, n = l(e).split(" "),
            r = n[0],
            o = r.match(/^\[(.+)\]$/),
            a = o && o[1],
            s = (i = r, (t = a) ? function(e) {
                return e.getAttribute(t)
            } : function(e) {
                var t = e.querySelector(i);
                return t && t.textContent
            }),
            h = c.sortDataParsers[n[1]];
        return h ? function(e) {
            return e && h(s(e))
        } : function(e) {
            return e && s(e)
        }
    };
    c.sortDataParsers = {
        parseInt: function(e) {
            return parseInt(e, 10)
        },
        parseFloat: function(e) {
            return parseFloat(e)
        }
    }, h._sort = function() {
        if (this.options.sortBy) {
            var e = r.makeArray(this.options.sortBy);
            this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory));
            var t = (i = this.sortHistory, n = this.options.sortAscending, function(e, t) {
                for (var r = 0; r < i.length; r++) {
                    var o = i[r],
                        a = e.sortData[o],
                        s = t.sortData[o];
                    if (s < a || a < s) return (s < a ? 1 : -1) * ((void 0 !== n[o] ? n[o] : n) ? 1 : -1)
                }
                return 0
            });
            this.filteredItems.sort(t)
        }
        var i, n
    }, h._getIsSameSortBy = function(e) {
        for (var t = 0; t < e.length; t++)
            if (e[t] != this.sortHistory[t]) return !1;
        return !0
    }, h._mode = function() {
        var e = this.options.layoutMode,
            t = this.modes[e];
        if (!t) throw new Error("No layout mode: " + e);
        return t.options = this.options[e], t
    }, h._resetLayout = function() {
        t.prototype._resetLayout.call(this), this._mode()._resetLayout()
    }, h._getItemLayoutPosition = function(e) {
        return this._mode()._getItemLayoutPosition(e)
    }, h._manageStamp = function(e) {
        this._mode()._manageStamp(e)
    }, h._getContainerSize = function() {
        return this._mode()._getContainerSize()
    }, h.needsResizeLayout = function() {
        return this._mode().needsResizeLayout()
    }, h.appended = function(e) {
        var t = this.addItems(e);
        if (t.length) {
            var i = this._filterRevealAdded(t);
            this.filteredItems = this.filteredItems.concat(i)
        }
    }, h.prepended = function(e) {
        var t = this._itemize(e);
        if (t.length) {
            this._resetLayout(), this._manageStamps();
            var i = this._filterRevealAdded(t);
            this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items)
        }
    }, h._filterRevealAdded = function(e) {
        var t = this._filter(e);
        return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches
    }, h.insert = function(e) {
        var t = this.addItems(e);
        if (t.length) {
            var i, n, r = t.length;
            for (i = 0; i < r; i++) n = t[i], this.element.appendChild(n.element);
            var o = this._filter(t).matches;
            for (i = 0; i < r; i++) t[i].isLayoutInstant = !0;
            for (this.arrange(), i = 0; i < r; i++) delete t[i].isLayoutInstant;
            this.reveal(o)
        }
    };
    var d = h.remove;
    return h.remove = function(e) {
        e = r.makeArray(e);
        var t = this.getItems(e);
        d.call(this, e);
        for (var i = t && t.length, n = 0; i && n < i; n++) {
            var o = t[n];
            r.removeFrom(this.filteredItems, o)
        }
    }, h.shuffle = function() {
        for (var e = 0; e < this.items.length; e++) this.items[e].sortData.random = Math.random();
        this.options.sortBy = "random", this._sort(), this._layout()
    }, h._noTransition = function(e, t) {
        var i = this.options.transitionDuration;
        this.options.transitionDuration = 0;
        var n = e.apply(this, t);
        return this.options.transitionDuration = i, n
    }, h.getFilteredItemElements = function() {
        return this.filteredItems.map((function(e) {
            return e.element
        }))
    }, c
})),
function(e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
}((function(e) {
    e.ui = e.ui || {}, e.ui.version = "1.12.1";
    var t, i = 0,
        n = Array.prototype.slice;
    e.cleanData = (t = e.cleanData, function(i) {
        for (var n, r, o = 0; null != (r = i[o]); o++) try {
            (n = e._data(r, "events")) && n.remove && e(r).triggerHandler("remove")
        } catch (i) {}
        t(i)
    }), e.widget = function(t, i, n) {
        var r, o, a, s = {},
            l = t.split(".")[0],
            c = l + "-" + (t = t.split(".")[1]);
        return n || (n = i, i = e.Widget), e.isArray(n) && (n = e.extend.apply(null, [{}].concat(n))), e.expr[":"][c.toLowerCase()] = function(t) {
            return !!e.data(t, c)
        }, e[l] = e[l] || {}, r = e[l][t], o = e[l][t] = function(e, t) {
            if (!this._createWidget) return new o(e, t);
            arguments.length && this._createWidget(e, t)
        }, e.extend(o, r, {
            version: n.version,
            _proto: e.extend({}, n),
            _childConstructors: []
        }), (a = new i).options = e.widget.extend({}, a.options), e.each(n, (function(t, n) {
            function r() {
                return i.prototype[t].apply(this, arguments)
            }

            function o(e) {
                return i.prototype[t].apply(this, e)
            }
            e.isFunction(n) ? s[t] = function() {
                var e, t = this._super,
                    i = this._superApply;
                return this._super = r, this._superApply = o, e = n.apply(this, arguments), this._super = t, this._superApply = i, e
            } : s[t] = n
        })), o.prototype = e.widget.extend(a, {
            widgetEventPrefix: r && a.widgetEventPrefix || t
        }, s, {
            constructor: o,
            namespace: l,
            widgetName: t,
            widgetFullName: c
        }), r ? (e.each(r._childConstructors, (function(t, i) {
            var n = i.prototype;
            e.widget(n.namespace + "." + n.widgetName, o, i._proto)
        })), delete r._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o), o
    }, e.widget.extend = function(t) {
        for (var i, r, o = n.call(arguments, 1), a = 0, s = o.length; a < s; a++)
            for (i in o[a]) r = o[a][i], o[a].hasOwnProperty(i) && void 0 !== r && (e.isPlainObject(r) ? t[i] = e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], r) : e.widget.extend({}, r) : t[i] = r);
        return t
    }, e.widget.bridge = function(t, i) {
        var r = i.prototype.widgetFullName || t;
        e.fn[t] = function(o) {
            var a = "string" == typeof o,
                s = n.call(arguments, 1),
                l = this;
            return a ? this.length || "instance" !== o ? this.each((function() {
                var i, n = e.data(this, r);
                return "instance" === o ? (l = n, !1) : n ? e.isFunction(n[o]) && "_" !== o.charAt(0) ? (i = n[o].apply(n, s)) !== n && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0 : e.error("no such method '" + o + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; attempted to call method '" + o + "'")
            })) : l = void 0 : (s.length && (o = e.widget.extend.apply(null, [o].concat(s))), this.each((function() {
                var t = e.data(this, r);
                t ? (t.option(o || {}), t._init && t._init()) : e.data(this, r, new i(o, this))
            }))), l
        }
    }, e.Widget = function() {}, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            classes: {},
            disabled: !1,
            create: null
        },
        _createWidget: function(t, n) {
            n = e(n || this.defaultElement || this)[0], this.element = e(n), this.uuid = i++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), this.hoverable = e(), this.focusable = e(), this.classesElementLookup = {}, n !== this && (e.data(n, this.widgetFullName, this), this._on(!0, this.element, {
                remove: function(e) {
                    e.target === n && this.destroy()
                }
            }), this.document = e(n.style ? n.ownerDocument : n.document || n), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
        },
        _getCreateOptions: function() {
            return {}
        },
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function() {
            var t = this;
            this._destroy(), e.each(this.classesElementLookup, (function(e, i) {
                t._removeClass(i, e)
            })), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
        },
        _destroy: e.noop,
        widget: function() {
            return this.element
        },
        option: function(t, i) {
            var n, r, o, a = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t)
                if (a = {}, t = (n = t.split(".")).shift(), n.length) {
                    for (r = a[t] = e.widget.extend({}, this.options[t]), o = 0; o < n.length - 1; o++) r[n[o]] = r[n[o]] || {}, r = r[n[o]];
                    if (t = n.pop(), 1 === arguments.length) return void 0 === r[t] ? null : r[t];
                    r[t] = i
                } else {
                    if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                    a[t] = i
                } return this._setOptions(a), this
        },
        _setOptions: function(e) {
            for (var t in e) this._setOption(t, e[t]);
            return this
        },
        _setOption: function(e, t) {
            return "classes" === e && this._setOptionClasses(t), this.options[e] = t, "disabled" === e && this._setOptionDisabled(t), this
        },
        _setOptionClasses: function(t) {
            var i, n, r;
            for (i in t) r = this.classesElementLookup[i], t[i] !== this.options.classes[i] && r && r.length && (n = e(r.get()), this._removeClass(r, i), n.addClass(this._classes({
                element: n,
                keys: i,
                classes: t,
                add: !0
            })))
        },
        _setOptionDisabled: function(e) {
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!e), e && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
        },
        enable: function() {
            return this._setOptions({
                disabled: !1
            })
        },
        disable: function() {
            return this._setOptions({
                disabled: !0
            })
        },
        _classes: function(t) {
            var i = [],
                n = this;

            function r(r, o) {
                for (var a, s = 0; s < r.length; s++) a = n.classesElementLookup[r[s]] || e(), a = t.add ? e(e.unique(a.get().concat(t.element.get()))) : e(a.not(t.element).get()), n.classesElementLookup[r[s]] = a, i.push(r[s]), o && t.classes[r[s]] && i.push(t.classes[r[s]])
            }
            return t = e.extend({
                element: this.element,
                classes: this.options.classes || {}
            }, t), this._on(t.element, {
                remove: "_untrackClassesElement"
            }), t.keys && r(t.keys.match(/\S+/g) || [], !0), t.extra && r(t.extra.match(/\S+/g) || []), i.join(" ")
        },
        _untrackClassesElement: function(t) {
            var i = this;
            e.each(i.classesElementLookup, (function(n, r) {
                -1 !== e.inArray(t.target, r) && (i.classesElementLookup[n] = e(r.not(t.target).get()))
            }))
        },
        _removeClass: function(e, t, i) {
            return this._toggleClass(e, t, i, !1)
        },
        _addClass: function(e, t, i) {
            return this._toggleClass(e, t, i, !0)
        },
        _toggleClass: function(e, t, i, n) {
            n = "boolean" == typeof n ? n : i;
            var r = "string" == typeof e || null === e;
            return (e = {
                extra: r ? t : i,
                keys: r ? e : t,
                element: r ? this.element : e,
                add: n
            }).element.toggleClass(this._classes(e), n), this
        },
        _on: function(t, i, n) {
            var r, o = this;
            "boolean" != typeof t && (n = i, i = t, t = !1), n ? (i = r = e(i), this.bindings = this.bindings.add(i)) : (n = i, i = this.element, r = this.widget()), e.each(n, (function(n, a) {
                function s() {
                    if (t || !0 !== o.options.disabled && !e(this).hasClass("ui-state-disabled")) return ("string" == typeof a ? o[a] : a).apply(o, arguments)
                }
                var l;
                "string" != typeof a && (s.guid = a.guid = a.guid || s.guid || e.guid++), n = (l = n.match(/^([\w:-]*)\s*(.*)$/))[1] + o.eventNamespace, (l = l[2]) ? r.on(n, l, s) : i.on(n, s)
            }))
        },
        _off: function(t, i) {
            i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(i).off(i), this.bindings = e(this.bindings.not(t).get()), this.focusable = e(this.focusable.not(t).get()), this.hoverable = e(this.hoverable.not(t).get())
        },
        _delay: function(e, t) {
            var i = this;
            return setTimeout((function() {
                return ("string" == typeof e ? i[e] : e).apply(i, arguments)
            }), t || 0)
        },
        _hoverable: function(t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function(t) {
                    this._addClass(e(t.currentTarget), null, "ui-state-hover")
                },
                mouseleave: function(t) {
                    this._removeClass(e(t.currentTarget), null, "ui-state-hover")
                }
            })
        },
        _focusable: function(t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function(t) {
                    this._addClass(e(t.currentTarget), null, "ui-state-focus")
                },
                focusout: function(t) {
                    this._removeClass(e(t.currentTarget), null, "ui-state-focus")
                }
            })
        },
        _trigger: function(t, i, n) {
            var r, o, a = this.options[t];
            if (n = n || {}, (i = e.Event(i)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), i.target = this.element[0], o = i.originalEvent)
                for (r in o) r in i || (i[r] = o[r]);
            return this.element.trigger(i, n), !(e.isFunction(a) && !1 === a.apply(this.element[0], [i].concat(n)) || i.isDefaultPrevented())
        }
    }, e.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, (function(t, i) {
        e.Widget.prototype["_" + t] = function(n, r, o) {
            var a;
            "string" == typeof r && (r = {
                effect: r
            });
            var s = r ? !0 !== r && "number" != typeof r && r.effect || i : t;
            "number" == typeof(r = r || {}) && (r = {
                duration: r
            }), a = !e.isEmptyObject(r), r.complete = o, r.delay && n.delay(r.delay), a && e.effects && e.effects.effect[s] ? n[t](r) : s !== t && n[s] ? n[s](r.duration, r.easing, o) : n.queue((function(i) {
                e(this)[t](), o && o.call(n[0]), i()
            }))
        }
    })), e.widget, e.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    }, e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    var r = !1;
    e(document).on("mouseup", (function() {
        r = !1
    })), e.widget("ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var t = this;
            this.element.on("mousedown." + this.widgetName, (function(e) {
                return t._mouseDown(e)
            })).on("click." + this.widgetName, (function(i) {
                if (!0 === e.data(i.target, t.widgetName + ".preventClickEvent")) return e.removeData(i.target, t.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1
            })), this.started = !1
        },
        _mouseDestroy: function() {
            this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
        },
        _mouseDown: function(t) {
            if (!r) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
                var i = this,
                    n = 1 === t.which,
                    o = !("string" != typeof this.options.cancel || !t.target.nodeName) && e(t.target).closest(this.options.cancel).length;
                return !(n && !o && this._mouseCapture(t)) || (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout((function() {
                    i.mouseDelayMet = !0
                }), this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function(e) {
                    return i._mouseMove(e)
                }, this._mouseUpDelegate = function(e) {
                    return i._mouseUp(e)
                }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), r = !0))
            }
        },
        _mouseMove: function(t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
                if (!t.which)
                    if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
                    else if (!this.ignoreMissingWhich) return this._mouseUp(t)
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
        },
        _mouseUp: function(t) {
            this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, r = !1, t.preventDefault()
        },
        _mouseDistanceMet: function(e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0
        }
    }), e.widget("ui.slider", e.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",
                "ui-slider-range": "ui-corner-all ui-widget-header"
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create: function() {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
        },
        _refresh: function() {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
        },
        _createHandles: function() {
            var t, i = this.options,
                n = this.element.find(".ui-slider-handle"),
                r = [],
                o = i.values && i.values.length || 1;
            for (n.length > o && (n.slice(o).remove(), n = n.slice(0, o)), t = n.length; t < o; t++) r.push("<span tabindex='0'></span>");
            this.handles = n.add(e(r.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each((function(t) {
                e(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
            }))
        },
        _createRange: function() {
            var t = this.options;
            t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : e.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
                left: "",
                bottom: ""
            })) : (this.range = e("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
        },
        _setupEvents: function() {
            this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
        },
        _destroy: function() {
            this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
        },
        _mouseCapture: function(t) {
            var i, n, r, o, a, s, l = this,
                c = this.options;
            return !c.disabled && (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), s = {
                x: t.pageX,
                y: t.pageY
            }, i = this._normValueFromMouse(s), n = this._valueMax() - this._valueMin() + 1, this.handles.each((function(t) {
                var a = Math.abs(i - l.values(t));
                (a < n || n === a && (t === l._lastChangedValue || l.values(t) === c.min)) && (n = a, r = e(this), o = t)
            })), !1 !== this._start(t, o) && (this._mouseSliding = !0, this._handleIndex = o, this._addClass(r, null, "ui-state-active"), r.trigger("focus"), a = r.offset(), s = !e(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = s ? {
                left: 0,
                top: 0
            } : {
                left: t.pageX - a.left - r.width() / 2,
                top: t.pageY - a.top - r.height() / 2 - (parseInt(r.css("borderTopWidth"), 10) || 0) - (parseInt(r.css("borderBottomWidth"), 10) || 0) + (parseInt(r.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, i), this._animateOff = !0))
        },
        _mouseStart: function() {
            return !0
        },
        _mouseDrag: function(e) {
            var t = {
                x: e.pageX,
                y: e.pageY
            };
            return t = this._normValueFromMouse(t), this._slide(e, this._handleIndex, t), !1
        },
        _mouseStop: function(e) {
            return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
        },
        _detectOrientation: function() {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
        },
        _normValueFromMouse: function(e) {
            var t;
            return 1 < (e = (e = "horizontal" === this.orientation ? (t = this.elementSize.width, e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0))) / t) && (e = 1), e < 0 && (e = 0), "vertical" === this.orientation && (e = 1 - e), t = this._valueMax() - this._valueMin(), t = this._valueMin() + e * t, this._trimAlignValue(t)
        },
        _uiHash: function(e, t, i) {
            var n = {
                handle: this.handles[e],
                handleIndex: e,
                value: void 0 !== t ? t : this.value()
            };
            return this._hasMultipleValues() && (n.value = void 0 !== t ? t : this.values(e), n.values = i || this.values()), n
        },
        _hasMultipleValues: function() {
            return this.options.values && this.options.values.length
        },
        _start: function(e, t) {
            return this._trigger("start", e, this._uiHash(t))
        },
        _slide: function(e, t, i) {
            var n, r = this.value(),
                o = this.values();
            this._hasMultipleValues() && (n = this.values(t ? 0 : 1), r = this.values(t), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === t ? Math.min(n, i) : Math.max(n, i)), o[t] = i), i !== r && !1 !== this._trigger("slide", e, this._uiHash(t, i, o)) && (this._hasMultipleValues() ? this.values(t, i) : this.value(i))
        },
        _stop: function(e, t) {
            this._trigger("stop", e, this._uiHash(t))
        },
        _change: function(e, t) {
            this._keySliding || this._mouseSliding || (this._lastChangedValue = t, this._trigger("change", e, this._uiHash(t)))
        },
        value: function(e) {
            return arguments.length ? (this.options.value = this._trimAlignValue(e), this._refreshValue(), void this._change(null, 0)) : this._value()
        },
        values: function(t, i) {
            var n, r, o;
            if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(i), this._refreshValue(), void this._change(null, t);
            if (!arguments.length) return this._values();
            if (!e.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
            for (n = this.options.values, r = t, o = 0; o < n.length; o += 1) n[o] = this._trimAlignValue(r[o]), this._change(null, o);
            this._refreshValue()
        },
        _setOption: function(t, i) {
            var n, r = 0;
            switch ("range" === t && !0 === this.options.range && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), e.isArray(this.options.values) && (r = this.options.values.length), this._super(t, i), t) {
                case "orientation":
                    this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(i), this.handles.css("horizontal" === i ? "bottom" : "left", "");
                    break;
                case "value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                    break;
                case "values":
                    for (this._animateOff = !0, this._refreshValue(), n = r - 1; 0 <= n; n--) this._change(null, n);
                    this._animateOff = !1;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
                    break;
                case "range":
                    this._animateOff = !0, this._refresh(), this._animateOff = !1
            }
        },
        _setOptionDisabled: function(e) {
            this._super(e), this._toggleClass(null, "ui-state-disabled", !!e)
        },
        _value: function() {
            var e = this.options.value;
            return this._trimAlignValue(e)
        },
        _values: function(e) {
            var t, i, n;
            if (arguments.length) return t = this.options.values[e], this._trimAlignValue(t);
            if (this._hasMultipleValues()) {
                for (i = this.options.values.slice(), n = 0; n < i.length; n += 1) i[n] = this._trimAlignValue(i[n]);
                return i
            }
            return []
        },
        _trimAlignValue: function(e) {
            if (e <= this._valueMin()) return this._valueMin();
            if (e >= this._valueMax()) return this._valueMax();
            var t = 0 < this.options.step ? this.options.step : 1,
                i = (e - this._valueMin()) % t;
            return e -= i, 2 * Math.abs(i) >= t && (e += 0 < i ? t : -t), parseFloat(e.toFixed(5))
        },
        _calculateNewMax: function() {
            var e = this.options.max,
                t = this._valueMin(),
                i = this.options.step;
            (e = Math.round((e - t) / i) * i + t) > this.options.max && (e -= i), this.max = parseFloat(e.toFixed(this._precision()))
        },
        _precision: function() {
            var e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this.options.min))), e
        },
        _precisionOf: function(e) {
            var t = e.toString();
            return -1 === (e = t.indexOf(".")) ? 0 : t.length - e - 1
        },
        _valueMin: function() {
            return this.options.min
        },
        _valueMax: function() {
            return this.max
        },
        _refreshRange: function(e) {
            "vertical" === e && this.range.css({
                width: "",
                left: ""
            }), "horizontal" === e && this.range.css({
                height: "",
                bottom: ""
            })
        },
        _refreshValue: function() {
            var t, i, n, r, o, a = this.options.range,
                s = this.options,
                l = this,
                c = !this._animateOff && s.animate,
                h = {};
            this._hasMultipleValues() ? this.handles.each((function(n) {
                i = (l.values(n) - l._valueMin()) / (l._valueMax() - l._valueMin()) * 100, h["horizontal" === l.orientation ? "left" : "bottom"] = i + "%", e(this).stop(1, 1)[c ? "animate" : "css"](h, s.animate), !0 === l.options.range && ("horizontal" === l.orientation ? (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
                    left: i + "%"
                }, s.animate), 1 === n && l.range[c ? "animate" : "css"]({
                    width: i - t + "%"
                }, {
                    queue: !1,
                    duration: s.animate
                })) : (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
                    bottom: i + "%"
                }, s.animate), 1 === n && l.range[c ? "animate" : "css"]({
                    height: i - t + "%"
                }, {
                    queue: !1,
                    duration: s.animate
                }))), t = i
            })) : (n = this.value(), r = this._valueMin(), o = this._valueMax(), i = o !== r ? (n - r) / (o - r) * 100 : 0, h["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[c ? "animate" : "css"](h, s.animate), "min" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                width: i + "%"
            }, s.animate), "max" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                width: 100 - i + "%"
            }, s.animate), "min" === a && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                height: i + "%"
            }, s.animate), "max" === a && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                height: 100 - i + "%"
            }, s.animate))
        },
        _handleEvents: {
            keydown: function(t) {
                var i, n, r, o = e(t.target).data("ui-slider-handle-index");
                switch (t.keyCode) {
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_UP:
                    case e.ui.keyCode.PAGE_DOWN:
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(e(t.target), null, "ui-state-active"), !1 === this._start(t, o))) return
                }
                switch (r = this.options.step, i = n = this._hasMultipleValues() ? this.values(o) : this.value(), t.keyCode) {
                    case e.ui.keyCode.HOME:
                        n = this._valueMin();
                        break;
                    case e.ui.keyCode.END:
                        n = this._valueMax();
                        break;
                    case e.ui.keyCode.PAGE_UP:
                        n = this._trimAlignValue(i + (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.PAGE_DOWN:
                        n = this._trimAlignValue(i - (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                        if (i === this._valueMax()) return;
                        n = this._trimAlignValue(i + r);
                        break;
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (i === this._valueMin()) return;
                        n = this._trimAlignValue(i - r)
                }
                this._slide(t, o, n)
            },
            keyup: function(t) {
                var i = e(t.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(t, i), this._change(t, i), this._removeClass(e(t.target), null, "ui-state-active"))
            }
        }
    })
})),
function() {
    "use strict";

    function e(n) {
        if (!n) throw new Error("No options passed to Waypoint constructor");
        if (!n.element) throw new Error("No element option passed to Waypoint constructor");
        if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + t, this.options = e.Adapter.extend({}, e.defaults, n), this.element = this.options.element, this.adapter = new e.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = e.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = e.Context.findOrCreateByElement(this.options.context), e.offsetAliases[this.options.offset] && (this.options.offset = e.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, t += 1
    }
    var t = 0,
        i = {};
    e.prototype.queueTrigger = function(e) {
        this.group.queueTrigger(this, e)
    }, e.prototype.trigger = function(e) {
        this.enabled && this.callback && this.callback.apply(this, e)
    }, e.prototype.destroy = function() {
        this.context.remove(this), this.group.remove(this), delete i[this.key]
    }, e.prototype.disable = function() {
        return this.enabled = !1, this
    }, e.prototype.enable = function() {
        return this.context.refresh(), this.enabled = !0, this
    }, e.prototype.next = function() {
        return this.group.next(this)
    }, e.prototype.previous = function() {
        return this.group.previous(this)
    }, e.invokeAll = function(e) {
        var t = [];
        for (var n in i) t.push(i[n]);
        for (var r = 0, o = t.length; o > r; r++) t[r][e]()
    }, e.destroyAll = function() {
        e.invokeAll("destroy")
    }, e.disableAll = function() {
        e.invokeAll("disable")
    }, e.enableAll = function() {
        e.invokeAll("enable")
    }, e.refreshAll = function() {
        e.Context.refreshAll()
    }, e.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight
    }, e.viewportWidth = function() {
        return document.documentElement.clientWidth
    }, e.adapters = [], e.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, e.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }, window.Waypoint = e
}(),
function() {
    "use strict";

    function e(e) {
        window.setTimeout(e, 1e3 / 60)
    }

    function t(e) {
        this.element = e, this.Adapter = r.Adapter, this.adapter = new this.Adapter(e), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, e.waypointContextKey = this.key, n[e.waypointContextKey] = this, i += 1, this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
    }
    var i = 0,
        n = {},
        r = window.Waypoint,
        o = window.onload;
    t.prototype.add = function(e) {
        var t = e.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[t][e.key] = e, this.refresh()
    }, t.prototype.checkEmpty = function() {
        var e = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            t = this.Adapter.isEmptyObject(this.waypoints.vertical);
        e && t && (this.adapter.off(".waypoints"), delete n[this.key])
    }, t.prototype.createThrottledResizeHandler = function() {
        function e() {
            t.handleResize(), t.didResize = !1
        }
        var t = this;
        this.adapter.on("resize.waypoints", (function() {
            t.didResize || (t.didResize = !0, r.requestAnimationFrame(e))
        }))
    }, t.prototype.createThrottledScrollHandler = function() {
        function e() {
            t.handleScroll(), t.didScroll = !1
        }
        var t = this;
        this.adapter.on("scroll.waypoints", (function() {
            (!t.didScroll || r.isTouch) && (t.didScroll = !0, r.requestAnimationFrame(e))
        }))
    }, t.prototype.handleResize = function() {
        r.Context.refreshAll()
    }, t.prototype.handleScroll = function() {
        var e = {},
            t = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
        for (var i in t) {
            var n = t[i],
                r = n.newScroll > n.oldScroll ? n.forward : n.backward;
            for (var o in this.waypoints[i]) {
                var a = this.waypoints[i][o],
                    s = n.oldScroll < a.triggerPoint,
                    l = n.newScroll >= a.triggerPoint;
                (s && l || !s && !l) && (a.queueTrigger(r), e[a.group.id] = a.group)
            }
        }
        for (var c in e) e[c].flushTriggers();
        this.oldScroll = {
            x: t.horizontal.newScroll,
            y: t.vertical.newScroll
        }
    }, t.prototype.innerHeight = function() {
        return this.element == this.element.window ? r.viewportHeight() : this.adapter.innerHeight()
    }, t.prototype.remove = function(e) {
        delete this.waypoints[e.axis][e.key], this.checkEmpty()
    }, t.prototype.innerWidth = function() {
        return this.element == this.element.window ? r.viewportWidth() : this.adapter.innerWidth()
    }, t.prototype.destroy = function() {
        var e = [];
        for (var t in this.waypoints)
            for (var i in this.waypoints[t]) e.push(this.waypoints[t][i]);
        for (var n = 0, r = e.length; r > n; n++) e[n].destroy()
    }, t.prototype.refresh = function() {
        var e, t = this.element == this.element.window,
            i = t ? void 0 : this.adapter.offset(),
            n = {};
        for (var o in this.handleScroll(), e = {
                horizontal: {
                    contextOffset: t ? 0 : i.left,
                    contextScroll: t ? 0 : this.oldScroll.x,
                    contextDimension: this.innerWidth(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left",
                    offsetProp: "left"
                },
                vertical: {
                    contextOffset: t ? 0 : i.top,
                    contextScroll: t ? 0 : this.oldScroll.y,
                    contextDimension: this.innerHeight(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up",
                    offsetProp: "top"
                }
            }) {
            var a = e[o];
            for (var s in this.waypoints[o]) {
                var l, c, h, u, d = this.waypoints[o][s],
                    p = d.options.offset,
                    f = d.triggerPoint,
                    m = 0,
                    g = null == f;
                d.element !== d.element.window && (m = d.adapter.offset()[a.offsetProp]), "function" == typeof p ? p = p.apply(d) : "string" == typeof p && (p = parseFloat(p), d.options.offset.indexOf("%") > -1 && (p = Math.ceil(a.contextDimension * p / 100))), l = a.contextScroll - a.contextOffset, d.triggerPoint = m + l - p, c = f < a.oldScroll, h = d.triggerPoint >= a.oldScroll, u = !c && !h, !g && (c && h) ? (d.queueTrigger(a.backward), n[d.group.id] = d.group) : (!g && u || g && a.oldScroll >= d.triggerPoint) && (d.queueTrigger(a.forward), n[d.group.id] = d.group)
            }
        }
        return r.requestAnimationFrame((function() {
            for (var e in n) n[e].flushTriggers()
        })), this
    }, t.findOrCreateByElement = function(e) {
        return t.findByElement(e) || new t(e)
    }, t.refreshAll = function() {
        for (var e in n) n[e].refresh()
    }, t.findByElement = function(e) {
        return n[e.waypointContextKey]
    }, window.onload = function() {
        o && o(), t.refreshAll()
    }, r.requestAnimationFrame = function(t) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || e).call(window, t)
    }, r.Context = t
}(),
function() {
    "use strict";

    function e(e, t) {
        return e.triggerPoint - t.triggerPoint
    }

    function t(e, t) {
        return t.triggerPoint - e.triggerPoint
    }

    function i(e) {
        this.name = e.name, this.axis = e.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this
    }
    var n = {
            vertical: {},
            horizontal: {}
        },
        r = window.Waypoint;
    i.prototype.add = function(e) {
        this.waypoints.push(e)
    }, i.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }, i.prototype.flushTriggers = function() {
        for (var i in this.triggerQueues) {
            var n = this.triggerQueues[i],
                r = "up" === i || "left" === i;
            n.sort(r ? t : e);
            for (var o = 0, a = n.length; a > o; o += 1) {
                var s = n[o];
                (s.options.continuous || o === n.length - 1) && s.trigger([i])
            }
        }
        this.clearTriggerQueues()
    }, i.prototype.next = function(t) {
        this.waypoints.sort(e);
        var i = r.Adapter.inArray(t, this.waypoints);
        return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1]
    }, i.prototype.previous = function(t) {
        this.waypoints.sort(e);
        var i = r.Adapter.inArray(t, this.waypoints);
        return i ? this.waypoints[i - 1] : null
    }, i.prototype.queueTrigger = function(e, t) {
        this.triggerQueues[t].push(e)
    }, i.prototype.remove = function(e) {
        var t = r.Adapter.inArray(e, this.waypoints);
        t > -1 && this.waypoints.splice(t, 1)
    }, i.prototype.first = function() {
        return this.waypoints[0]
    }, i.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1]
    }, i.findOrCreate = function(e) {
        return n[e.axis][e.name] || new i(e)
    }, r.Group = i
}(),
function() {
    "use strict";

    function e(e) {
        this.$element = t(e)
    }
    var t = window.jQuery,
        i = window.Waypoint;
    t.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], (function(t, i) {
        e.prototype[i] = function() {
            var e = Array.prototype.slice.call(arguments);
            return this.$element[i].apply(this.$element, e)
        }
    })), t.each(["extend", "inArray", "isEmptyObject"], (function(i, n) {
        e[n] = t[n]
    })), i.adapters.push({
        name: "jquery",
        Adapter: e
    }), i.Adapter = e
}(),
function() {
    "use strict";

    function e(e) {
        return function() {
            var i = [],
                n = arguments[0];
            return e.isFunction(arguments[0]) && ((n = e.extend({}, arguments[1])).handler = arguments[0]), this.each((function() {
                var r = e.extend({}, n, {
                    element: this
                });
                "string" == typeof r.context && (r.context = e(this).closest(r.context)[0]), i.push(new t(r))
            })), i
        }
    }
    var t = window.Waypoint;
    window.jQuery && (window.jQuery.fn.waypoint = e(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = e(window.Zepto))
}(),
/*!
 * jquery.counterup.js 1.0
 *
 * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
 * Released under the GPL v2 License
 *
 * Date: Nov 26, 2013
 */
function(e) {
    "use strict";
    e.fn.counterUp = function(t) {
        var i, n = e.extend({
            time: 400,
            delay: 10,
            offset: 100,
            beginAt: 0,
            formatter: !1,
            context: "window",
            callback: function() {}
        }, t);
        return this.each((function() {
            var t = e(this),
                r = {
                    time: e(this).data("counterup-time") || n.time,
                    delay: e(this).data("counterup-delay") || n.delay,
                    offset: e(this).data("counterup-offset") || n.offset,
                    beginAt: e(this).data("counterup-beginat") || n.beginAt,
                    context: e(this).data("counterup-context") || n.context
                };
            t.waypoint((function(o) {
                ! function() {
                    var o = [],
                        a = r.time / r.delay,
                        s = e(this).attr("data-num") ? e(this).attr("data-num") : t.text(),
                        l = /[0-9]+,[0-9]+/.test(s),
                        c = ((s = s.replace(/,/g, "")).split(".")[1] || []).length;
                    r.beginAt > s && (r.beginAt = s);
                    var h = /[0-9]+:[0-9]+:[0-9]+/.test(s);
                    if (h) {
                        var u = s.split(":"),
                            d = 1;
                        for (i = 0; u.length > 0;) i += d * parseInt(u.pop(), 10), d *= 60
                    }
                    for (var p = a; p >= r.beginAt / s * a; p--) {
                        var f = parseFloat(s / a * p).toFixed(c);
                        if (h) {
                            f = parseInt(i / a * p);
                            var m = parseInt(f / 3600) % 24,
                                g = parseInt(f / 60) % 60,
                                v = parseInt(f % 60, 10);
                            f = (m < 10 ? "0" + m : m) + ":" + (g < 10 ? "0" + g : g) + ":" + (v < 10 ? "0" + v : v)
                        }
                        if (l)
                            for (;
                                /(\d+)(\d{3})/.test(f.toString());) f = f.toString().replace(/(\d+)(\d{3})/, "$1,$2");
                        n.formatter && (f = n.formatter.call(this, f)), o.unshift(f)
                    }
                    t.data("counterup-nums", o), t.text(r.beginAt), t.data("counterup-func", (function() {
                        t.data("counterup-nums") ? (t.html(t.data("counterup-nums").shift()), t.data("counterup-nums").length ? setTimeout(t.data("counterup-func"), r.delay) : (t.data("counterup-nums", null), t.data("counterup-func", null), n.callback.call(this))) : n.callback.call(this)
                    })), setTimeout(t.data("counterup-func"), r.delay)
                }(), this.destroy()
            }), {
                offset: r.offset + "%",
                context: r.context
            })
        }))
    }
}(jQuery),
function(e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e("object" == typeof exports ? require("jquery") : window.jQuery || window.Zepto)
}((function(e) {
    var t, i, n, r, o, a, s = "Close",
        l = "BeforeClose",
        c = "MarkupParse",
        h = "Open",
        u = "Change",
        d = "mfp",
        p = "." + d,
        f = "mfp-ready",
        m = "mfp-removing",
        g = "mfp-prevent-close",
        v = function() {},
        y = !!window.jQuery,
        b = e(window),
        x = function(e, i) {
            t.ev.on(d + e + p, i)
        },
        w = function(t, i, n, r) {
            var o = document.createElement("div");
            return o.className = "mfp-" + t, n && (o.innerHTML = n), r ? i && i.appendChild(o) : (o = e(o), i && o.appendTo(i)), o
        },
        _ = function(i, n) {
            t.ev.triggerHandler(d + i, n), t.st.callbacks && (i = i.charAt(0).toLowerCase() + i.slice(1), t.st.callbacks[i] && t.st.callbacks[i].apply(t, e.isArray(n) ? n : [n]))
        },
        E = function(i) {
            return i === a && t.currTemplate.closeBtn || (t.currTemplate.closeBtn = e(t.st.closeMarkup.replace("%title%", t.st.tClose)), a = i), t.currTemplate.closeBtn
        },
        M = function() {
            e.magnificPopup.instance || ((t = new v).init(), e.magnificPopup.instance = t)
        };
    v.prototype = {
        constructor: v,
        init: function() {
            var i = navigator.appVersion;
            t.isLowIE = t.isIE8 = document.all && !document.addEventListener, t.isAndroid = /android/gi.test(i), t.isIOS = /iphone|ipad|ipod/gi.test(i), t.supportsTransition = function() {
                var e = document.createElement("p").style,
                    t = ["ms", "O", "Moz", "Webkit"];
                if (void 0 !== e.transition) return !0;
                for (; t.length;)
                    if (t.pop() + "Transition" in e) return !0;
                return !1
            }(), t.probablyMobile = t.isAndroid || t.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), n = e(document), t.popupsCache = {}
        },
        open: function(i) {
            var r;
            if (!1 === i.isObj) {
                t.items = i.items.toArray(), t.index = 0;
                var a, s = i.items;
                for (r = 0; r < s.length; r++)
                    if ((a = s[r]).parsed && (a = a.el[0]), a === i.el[0]) {
                        t.index = r;
                        break
                    }
            } else t.items = e.isArray(i.items) ? i.items : [i.items], t.index = i.index || 0;
            if (!t.isOpen) {
                t.types = [], o = "", i.mainEl && i.mainEl.length ? t.ev = i.mainEl.eq(0) : t.ev = n, i.key ? (t.popupsCache[i.key] || (t.popupsCache[i.key] = {}), t.currTemplate = t.popupsCache[i.key]) : t.currTemplate = {}, t.st = e.extend(!0, {}, e.magnificPopup.defaults, i), t.fixedContentPos = "auto" === t.st.fixedContentPos ? !t.probablyMobile : t.st.fixedContentPos, t.st.modal && (t.st.closeOnContentClick = !1, t.st.closeOnBgClick = !1, t.st.showCloseBtn = !1, t.st.enableEscapeKey = !1), t.bgOverlay || (t.bgOverlay = w("bg").on("click" + p, (function() {
                    t.close()
                })), t.wrap = w("wrap").attr("tabindex", -1).on("click" + p, (function(e) {
                    t._checkIfClose(e.target) && t.close()
                })), t.container = w("container", t.wrap)), t.contentContainer = w("content"), t.st.preloader && (t.preloader = w("preloader", t.container, t.st.tLoading));
                var l = e.magnificPopup.modules;
                for (r = 0; r < l.length; r++) {
                    var u = l[r];
                    u = u.charAt(0).toUpperCase() + u.slice(1), t["init" + u].call(t)
                }
                _("BeforeOpen"), t.st.showCloseBtn && (t.st.closeBtnInside ? (x(c, (function(e, t, i, n) {
                    i.close_replaceWith = E(n.type)
                })), o += " mfp-close-btn-in") : t.wrap.append(E())), t.st.alignTop && (o += " mfp-align-top"), t.fixedContentPos ? t.wrap.css({
                    overflow: t.st.overflowY,
                    overflowX: "hidden",
                    overflowY: t.st.overflowY
                }) : t.wrap.css({
                    top: b.scrollTop(),
                    position: "absolute"
                }), (!1 === t.st.fixedBgPos || "auto" === t.st.fixedBgPos && !t.fixedContentPos) && t.bgOverlay.css({
                    height: n.height(),
                    position: "absolute"
                }), t.st.enableEscapeKey && n.on("keyup" + p, (function(e) {
                    27 === e.keyCode && t.close()
                })), b.on("resize" + p, (function() {
                    t.updateSize()
                })), t.st.closeOnContentClick || (o += " mfp-auto-cursor"), o && t.wrap.addClass(o);
                var d = t.wH = b.height(),
                    m = {};
                if (t.fixedContentPos && t._hasScrollBar(d)) {
                    var g = t._getScrollbarSize();
                    g && (m.marginRight = g)
                }
                t.fixedContentPos && (t.isIE7 ? e("body, html").css("overflow", "hidden") : m.overflow = "hidden");
                var v = t.st.mainClass;
                return t.isIE7 && (v += " mfp-ie7"), v && t._addClassToMFP(v), t.updateItemHTML(), _("BuildControls"), e("html").css(m), t.bgOverlay.add(t.wrap).prependTo(t.st.prependTo || e(document.body)), t._lastFocusedEl = document.activeElement, setTimeout((function() {
                    t.content ? (t._addClassToMFP(f), t._setFocus()) : t.bgOverlay.addClass(f), n.on("focusin" + p, t._onFocusIn)
                }), 16), t.isOpen = !0, t.updateSize(d), _(h), i
            }
            t.updateItemHTML()
        },
        close: function() {
            t.isOpen && (_(l), t.isOpen = !1, t.st.removalDelay && !t.isLowIE && t.supportsTransition ? (t._addClassToMFP(m), setTimeout((function() {
                t._close()
            }), t.st.removalDelay)) : t._close())
        },
        _close: function() {
            _(s);
            var i = m + " " + f + " ";
            if (t.bgOverlay.detach(), t.wrap.detach(), t.container.empty(), t.st.mainClass && (i += t.st.mainClass + " "), t._removeClassFromMFP(i), t.fixedContentPos) {
                var r = {
                    marginRight: ""
                };
                t.isIE7 ? e("body, html").css("overflow", "") : r.overflow = "", e("html").css(r)
            }
            n.off("keyup.mfp focusin" + p), t.ev.off(p), t.wrap.attr("class", "mfp-wrap").removeAttr("style"), t.bgOverlay.attr("class", "mfp-bg"), t.container.attr("class", "mfp-container"), !t.st.showCloseBtn || t.st.closeBtnInside && !0 !== t.currTemplate[t.currItem.type] || t.currTemplate.closeBtn && t.currTemplate.closeBtn.detach(), t.st.autoFocusLast && t._lastFocusedEl && e(t._lastFocusedEl).focus(), t.currItem = null, t.content = null, t.currTemplate = null, t.prevHeight = 0, _("AfterClose")
        },
        updateSize: function(e) {
            if (t.isIOS) {
                var i = document.documentElement.clientWidth / window.innerWidth,
                    n = window.innerHeight * i;
                t.wrap.css("height", n), t.wH = n
            } else t.wH = e || b.height();
            t.fixedContentPos || t.wrap.css("height", t.wH), _("Resize")
        },
        updateItemHTML: function() {
            var i = t.items[t.index];
            t.contentContainer.detach(), t.content && t.content.detach(), i.parsed || (i = t.parseEl(t.index));
            var n = i.type;
            if (_("BeforeChange", [t.currItem ? t.currItem.type : "", n]), t.currItem = i, !t.currTemplate[n]) {
                var o = !!t.st[n] && t.st[n].markup;
                _("FirstMarkupParse", o), t.currTemplate[n] = !o || e(o)
            }
            r && r !== i.type && t.container.removeClass("mfp-" + r + "-holder");
            var a = t["get" + n.charAt(0).toUpperCase() + n.slice(1)](i, t.currTemplate[n]);
            t.appendContent(a, n), i.preloaded = !0, _(u, i), r = i.type, t.container.prepend(t.contentContainer), _("AfterChange")
        },
        appendContent: function(e, i) {
            t.content = e, e ? t.st.showCloseBtn && t.st.closeBtnInside && !0 === t.currTemplate[i] ? t.content.find(".mfp-close").length || t.content.append(E()) : t.content = e : t.content = "", _("BeforeAppend"), t.container.addClass("mfp-" + i + "-holder"), t.contentContainer.append(t.content)
        },
        parseEl: function(i) {
            var n, r = t.items[i];
            if (r.tagName ? r = {
                    el: e(r)
                } : (n = r.type, r = {
                    data: r,
                    src: r.src
                }), r.el) {
                for (var o = t.types, a = 0; a < o.length; a++)
                    if (r.el.hasClass("mfp-" + o[a])) {
                        n = o[a];
                        break
                    } r.src = r.el.attr("data-mfp-src"), r.src || (r.src = r.el.attr("href"))
            }
            return r.type = n || t.st.type || "inline", r.index = i, r.parsed = !0, t.items[i] = r, _("ElementParse", r), t.items[i]
        },
        addGroup: function(e, i) {
            var n = function(n) {
                n.mfpEl = this, t._openClick(n, e, i)
            };
            i || (i = {});
            var r = "click.magnificPopup";
            i.mainEl = e, i.items ? (i.isObj = !0, e.off(r).on(r, n)) : (i.isObj = !1, i.delegate ? e.off(r).on(r, i.delegate, n) : (i.items = e, e.off(r).on(r, n)))
        },
        _openClick: function(i, n, r) {
            if ((void 0 !== r.midClick ? r.midClick : e.magnificPopup.defaults.midClick) || !(2 === i.which || i.ctrlKey || i.metaKey || i.altKey || i.shiftKey)) {
                var o = void 0 !== r.disableOn ? r.disableOn : e.magnificPopup.defaults.disableOn;
                if (o)
                    if (e.isFunction(o)) {
                        if (!o.call(t)) return !0
                    } else if (b.width() < o) return !0;
                i.type && (i.preventDefault(), t.isOpen && i.stopPropagation()), r.el = e(i.mfpEl), r.delegate && (r.items = n.find(r.delegate)), t.open(r)
            }
        },
        updateStatus: function(e, n) {
            if (t.preloader) {
                i !== e && t.container.removeClass("mfp-s-" + i), n || "loading" !== e || (n = t.st.tLoading);
                var r = {
                    status: e,
                    text: n
                };
                _("UpdateStatus", r), e = r.status, n = r.text, t.preloader.html(n), t.preloader.find("a").on("click", (function(e) {
                    e.stopImmediatePropagation()
                })), t.container.addClass("mfp-s-" + e), i = e
            }
        },
        _checkIfClose: function(i) {
            if (!e(i).hasClass(g)) {
                var n = t.st.closeOnContentClick,
                    r = t.st.closeOnBgClick;
                if (n && r) return !0;
                if (!t.content || e(i).hasClass("mfp-close") || t.preloader && i === t.preloader[0]) return !0;
                if (i === t.content[0] || e.contains(t.content[0], i)) {
                    if (n) return !0
                } else if (r && e.contains(document, i)) return !0;
                return !1
            }
        },
        _addClassToMFP: function(e) {
            t.bgOverlay.addClass(e), t.wrap.addClass(e)
        },
        _removeClassFromMFP: function(e) {
            this.bgOverlay.removeClass(e), t.wrap.removeClass(e)
        },
        _hasScrollBar: function(e) {
            return (t.isIE7 ? n.height() : document.body.scrollHeight) > (e || b.height())
        },
        _setFocus: function() {
            (t.st.focus ? t.content.find(t.st.focus).eq(0) : t.wrap).focus()
        },
        _onFocusIn: function(i) {
            return i.target === t.wrap[0] || e.contains(t.wrap[0], i.target) ? void 0 : (t._setFocus(), !1)
        },
        _parseMarkup: function(t, i, n) {
            var r;
            n.data && (i = e.extend(n.data, i)), _(c, [t, i, n]), e.each(i, (function(i, n) {
                if (void 0 === n || !1 === n) return !0;
                if ((r = i.split("_")).length > 1) {
                    var o = t.find(p + "-" + r[0]);
                    if (o.length > 0) {
                        var a = r[1];
                        "replaceWith" === a ? o[0] !== n[0] && o.replaceWith(n) : "img" === a ? o.is("img") ? o.attr("src", n) : o.replaceWith(e("<img>").attr("src", n).attr("class", o.attr("class"))) : o.attr(r[1], n)
                    }
                } else t.find(p + "-" + i).html(n)
            }))
        },
        _getScrollbarSize: function() {
            if (void 0 === t.scrollbarSize) {
                var e = document.createElement("div");
                e.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(e), t.scrollbarSize = e.offsetWidth - e.clientWidth, document.body.removeChild(e)
            }
            return t.scrollbarSize
        }
    }, e.magnificPopup = {
        instance: null,
        proto: v.prototype,
        modules: [],
        open: function(t, i) {
            return M(), (t = t ? e.extend(!0, {}, t) : {}).isObj = !0, t.index = i || 0, this.instance.open(t)
        },
        close: function() {
            return e.magnificPopup.instance && e.magnificPopup.instance.close()
        },
        registerModule: function(t, i) {
            i.options && (e.magnificPopup.defaults[t] = i.options), e.extend(this.proto, i.proto), this.modules.push(t)
        },
        defaults: {
            disableOn: 0,
            key: null,
            midClick: !1,
            mainClass: "",
            preloader: !0,
            focus: "",
            closeOnContentClick: !1,
            closeOnBgClick: !0,
            closeBtnInside: !0,
            showCloseBtn: !0,
            enableEscapeKey: !0,
            modal: !1,
            alignTop: !1,
            removalDelay: 0,
            prependTo: null,
            fixedContentPos: "auto",
            fixedBgPos: "auto",
            overflowY: "auto",
            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
            tClose: "Close (Esc)",
            tLoading: "Loading...",
            autoFocusLast: !0
        }
    }, e.fn.magnificPopup = function(i) {
        M();
        var n = e(this);
        if ("string" == typeof i)
            if ("open" === i) {
                var r, o = y ? n.data("magnificPopup") : n[0].magnificPopup,
                    a = parseInt(arguments[1], 10) || 0;
                o.items ? r = o.items[a] : (r = n, o.delegate && (r = r.find(o.delegate)), r = r.eq(a)), t._openClick({
                    mfpEl: r
                }, n, o)
            } else t.isOpen && t[i].apply(t, Array.prototype.slice.call(arguments, 1));
        else i = e.extend(!0, {}, i), y ? n.data("magnificPopup", i) : n[0].magnificPopup = i, t.addGroup(n, i);
        return n
    };
    var T, S, A, C = "inline",
        L = function() {
            A && (S.after(A.addClass(T)).detach(), A = null)
        };
    e.magnificPopup.registerModule(C, {
        options: {
            hiddenClass: "hide",
            markup: "",
            tNotFound: "Content not found"
        },
        proto: {
            initInline: function() {
                t.types.push(C), x(s + "." + C, (function() {
                    L()
                }))
            },
            getInline: function(i, n) {
                if (L(), i.src) {
                    var r = t.st.inline,
                        o = e(i.src);
                    if (o.length) {
                        var a = o[0].parentNode;
                        a && a.tagName && (S || (T = r.hiddenClass, S = w(T), T = "mfp-" + T), A = o.after(S).detach().removeClass(T)), t.updateStatus("ready")
                    } else t.updateStatus("error", r.tNotFound), o = e("<div>");
                    return i.inlineElement = o, o
                }
                return t.updateStatus("ready"), t._parseMarkup(n, {}, i), n
            }
        }
    });
    var D, P = "ajax",
        R = function() {
            D && e(document.body).removeClass(D)
        },
        O = function() {
            R(), t.req && t.req.abort()
        };
    e.magnificPopup.registerModule(P, {
        options: {
            settings: null,
            cursor: "mfp-ajax-cur",
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },
        proto: {
            initAjax: function() {
                t.types.push(P), D = t.st.ajax.cursor, x(s + "." + P, O), x("BeforeChange." + P, O)
            },
            getAjax: function(i) {
                D && e(document.body).addClass(D), t.updateStatus("loading");
                var n = e.extend({
                    url: i.src,
                    success: function(n, r, o) {
                        var a = {
                            data: n,
                            xhr: o
                        };
                        _("ParseAjax", a), t.appendContent(e(a.data), P), i.finished = !0, R(), t._setFocus(), setTimeout((function() {
                            t.wrap.addClass(f)
                        }), 16), t.updateStatus("ready"), _("AjaxContentAdded")
                    },
                    error: function() {
                        R(), i.finished = i.loadError = !0, t.updateStatus("error", t.st.ajax.tError.replace("%url%", i.src))
                    }
                }, t.st.ajax.settings);
                return t.req = e.ajax(n), ""
            }
        }
    });
    var I, z = function(i) {
        if (i.data && void 0 !== i.data.title) return i.data.title;
        var n = t.st.image.titleSrc;
        if (n) {
            if (e.isFunction(n)) return n.call(t, i);
            if (i.el) return i.el.attr(n) || ""
        }
        return ""
    };
    e.magnificPopup.registerModule("image", {
        options: {
            markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>',
            cursor: "mfp-zoom-out-cur",
            titleSrc: "title",
            verticalFit: !0,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },
        proto: {
            initImage: function() {
                var i = t.st.image,
                    n = ".image";
                t.types.push("image"), x(h + n, (function() {
                    "image" === t.currItem.type && i.cursor && e(document.body).addClass(i.cursor)
                })), x(s + n, (function() {
                    i.cursor && e(document.body).removeClass(i.cursor), b.off("resize" + p)
                })), x("Resize" + n, t.resizeImage), t.isLowIE && x("AfterChange", t.resizeImage)
            },
            resizeImage: function() {
                var e = t.currItem;
                if (e && e.img && t.st.image.verticalFit) {
                    var i = 0;
                    t.isLowIE && (i = parseInt(e.img.css("padding-top"), 10) + parseInt(e.img.css("padding-bottom"), 10)), e.img.css("max-height", t.wH - i)
                }
            },
            _onImageHasSize: function(e) {
                e.img && (e.hasSize = !0, I && clearInterval(I), e.isCheckingImgSize = !1, _("ImageHasSize", e), e.imgHidden && (t.content && t.content.removeClass("mfp-loading"), e.imgHidden = !1))
            },
            findImageSize: function(e) {
                var i = 0,
                    n = e.img[0],
                    r = function(o) {
                        I && clearInterval(I), I = setInterval((function() {
                            return n.naturalWidth > 0 ? void t._onImageHasSize(e) : (i > 200 && clearInterval(I), void(3 === ++i ? r(10) : 40 === i ? r(50) : 100 === i && r(500)))
                        }), o)
                    };
                r(1)
            },
            getImage: function(i, n) {
                var r = 0,
                    o = function() {
                        i && (i.img[0].complete ? (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("ready")), i.hasSize = !0, i.loaded = !0, _("ImageLoadComplete")) : 200 > ++r ? setTimeout(o, 100) : a())
                    },
                    a = function() {
                        i && (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("error", s.tError.replace("%url%", i.src))), i.hasSize = !0, i.loaded = !0, i.loadError = !0)
                    },
                    s = t.st.image,
                    l = n.find(".mfp-img");
                if (l.length) {
                    var c = document.createElement("img");
                    c.className = "mfp-img", i.el && i.el.find("img").length && (c.alt = i.el.find("img").attr("alt")), i.img = e(c).on("load.mfploader", o).on("error.mfploader", a), c.src = i.src, l.is("img") && (i.img = i.img.clone()), (c = i.img[0]).naturalWidth > 0 ? i.hasSize = !0 : c.width || (i.hasSize = !1)
                }
                return t._parseMarkup(n, {
                    title: z(i),
                    img_replaceWith: i.img
                }, i), t.resizeImage(), i.hasSize ? (I && clearInterval(I), i.loadError ? (n.addClass("mfp-loading"), t.updateStatus("error", s.tError.replace("%url%", i.src))) : (n.removeClass("mfp-loading"), t.updateStatus("ready")), n) : (t.updateStatus("loading"), i.loading = !0, i.hasSize || (i.imgHidden = !0, n.addClass("mfp-loading"), t.findImageSize(i)), n)
            }
        }
    });
    var N;
    e.magnificPopup.registerModule("zoom", {
        options: {
            enabled: !1,
            easing: "ease-in-out",
            duration: 300,
            opener: function(e) {
                return e.is("img") ? e : e.find("img")
            }
        },
        proto: {
            initZoom: function() {
                var e, i = t.st.zoom,
                    n = ".zoom";
                if (i.enabled && t.supportsTransition) {
                    var r, o, a = i.duration,
                        c = function(e) {
                            var t = e.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
                                n = "all " + i.duration / 1e3 + "s " + i.easing,
                                r = {
                                    position: "fixed",
                                    zIndex: 9999,
                                    left: 0,
                                    top: 0,
                                    "-webkit-backface-visibility": "hidden"
                                },
                                o = "transition";
                            return r["-webkit-" + o] = r["-moz-" + o] = r["-o-" + o] = r[o] = n, t.css(r), t
                        },
                        h = function() {
                            t.content.css("visibility", "visible")
                        };
                    x("BuildControls" + n, (function() {
                        if (t._allowZoom()) {
                            if (clearTimeout(r), t.content.css("visibility", "hidden"), !(e = t._getItemToZoom())) return void h();
                            (o = c(e)).css(t._getOffset()), t.wrap.append(o), r = setTimeout((function() {
                                o.css(t._getOffset(!0)), r = setTimeout((function() {
                                    h(), setTimeout((function() {
                                        o.remove(), e = o = null, _("ZoomAnimationEnded")
                                    }), 16)
                                }), a)
                            }), 16)
                        }
                    })), x(l + n, (function() {
                        if (t._allowZoom()) {
                            if (clearTimeout(r), t.st.removalDelay = a, !e) {
                                if (!(e = t._getItemToZoom())) return;
                                o = c(e)
                            }
                            o.css(t._getOffset(!0)), t.wrap.append(o), t.content.css("visibility", "hidden"), setTimeout((function() {
                                o.css(t._getOffset())
                            }), 16)
                        }
                    })), x(s + n, (function() {
                        t._allowZoom() && (h(), o && o.remove(), e = null)
                    }))
                }
            },
            _allowZoom: function() {
                return "image" === t.currItem.type
            },
            _getItemToZoom: function() {
                return !!t.currItem.hasSize && t.currItem.img
            },
            _getOffset: function(i) {
                var n, r = (n = i ? t.currItem.img : t.st.zoom.opener(t.currItem.el || t.currItem)).offset(),
                    o = parseInt(n.css("padding-top"), 10),
                    a = parseInt(n.css("padding-bottom"), 10);
                r.top -= e(window).scrollTop() - o;
                var s = {
                    width: n.width(),
                    height: (y ? n.innerHeight() : n[0].offsetHeight) - a - o
                };
                return void 0 === N && (N = void 0 !== document.createElement("p").style.MozTransform), N ? s["-moz-transform"] = s.transform = "translate(" + r.left + "px," + r.top + "px)" : (s.left = r.left, s.top = r.top), s
            }
        }
    });
    var B = "iframe",
        F = function(e) {
            if (t.currTemplate[B]) {
                var i = t.currTemplate[B].find("iframe");
                i.length && (e || (i[0].src = "/about.html:blank"), t.isIE8 && i.css("display", e ? "block" : "none"))
            }
        };
    e.magnificPopup.registerModule(B, {
        options: {
            markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="/about.html:blank" frameborder="0" allowfullscreen></iframe></div>',
            srcAction: "iframe_src",
            patterns: {
                youtube: {
                    index: "youtube.com",
                    id: "v=",
                    src: "//www.youtube.com/embed/%id%?autoplay=1"
                },
                vimeo: {
                    index: "vimeo.com/",
                    id: "/",
                    src: "//player.vimeo.com/video/%id%?autoplay=1"
                },
                gmaps: {
                    index: "//maps.google.",
                    src: "%id%&output=embed"
                }
            }
        },
        proto: {
            initIframe: function() {
                t.types.push(B), x("BeforeChange", (function(e, t, i) {
                    t !== i && (t === B ? F() : i === B && F(!0))
                })), x(s + "." + B, (function() {
                    F()
                }))
            },
            getIframe: function(i, n) {
                var r = i.src,
                    o = t.st.iframe;
                e.each(o.patterns, (function() {
                    return r.indexOf(this.index) > -1 ? (this.id && (r = "string" == typeof this.id ? r.substr(r.lastIndexOf(this.id) + this.id.length, r.length) : this.id.call(this, r)), r = this.src.replace("%id%", r), !1) : void 0
                }));
                var a = {};
                return o.srcAction && (a[o.srcAction] = r), t._parseMarkup(n, a, i), t.updateStatus("ready"), n
            }
        }
    });
    var k = function(e) {
            var i = t.items.length;
            return e > i - 1 ? e - i : 0 > e ? i + e : e
        },
        U = function(e, t, i) {
            return e.replace(/%curr%/gi, t + 1).replace(/%total%/gi, i)
        };
    e.magnificPopup.registerModule("gallery", {
        options: {
            enabled: !1,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [0, 2],
            navigateByImgClick: !0,
            arrows: !0,
            tPrev: "Previous (Left arrow key)",
            tNext: "Next (Right arrow key)",
            tCounter: "%curr% of %total%"
        },
        proto: {
            initGallery: function() {
                var i = t.st.gallery,
                    r = ".mfp-gallery";
                return t.direction = !0, !(!i || !i.enabled) && (o += " mfp-gallery", x(h + r, (function() {
                    i.navigateByImgClick && t.wrap.on("click" + r, ".mfp-img", (function() {
                        return t.items.length > 1 ? (t.next(), !1) : void 0
                    })), n.on("keydown" + r, (function(e) {
                        37 === e.keyCode ? t.prev() : 39 === e.keyCode && t.next()
                    }))
                })), x("UpdateStatus" + r, (function(e, i) {
                    i.text && (i.text = U(i.text, t.currItem.index, t.items.length))
                })), x(c + r, (function(e, n, r, o) {
                    var a = t.items.length;
                    r.counter = a > 1 ? U(i.tCounter, o.index, a) : ""
                })), x("BuildControls" + r, (function() {
                    if (t.items.length > 1 && i.arrows && !t.arrowLeft) {
                        var n = i.arrowMarkup,
                            r = t.arrowLeft = e(n.replace(/%title%/gi, i.tPrev).replace(/%dir%/gi, "left")).addClass(g),
                            o = t.arrowRight = e(n.replace(/%title%/gi, i.tNext).replace(/%dir%/gi, "right")).addClass(g);
                        r.click((function() {
                            t.prev()
                        })), o.click((function() {
                            t.next()
                        })), t.container.append(r.add(o))
                    }
                })), x(u + r, (function() {
                    t._preloadTimeout && clearTimeout(t._preloadTimeout), t._preloadTimeout = setTimeout((function() {
                        t.preloadNearbyImages(), t._preloadTimeout = null
                    }), 16)
                })), void x(s + r, (function() {
                    n.off(r), t.wrap.off("click" + r), t.arrowRight = t.arrowLeft = null
                })))
            },
            next: function() {
                t.direction = !0, t.index = k(t.index + 1), t.updateItemHTML()
            },
            prev: function() {
                t.direction = !1, t.index = k(t.index - 1), t.updateItemHTML()
            },
            goTo: function(e) {
                t.direction = e >= t.index, t.index = e, t.updateItemHTML()
            },
            preloadNearbyImages: function() {
                var e, i = t.st.gallery.preload,
                    n = Math.min(i[0], t.items.length),
                    r = Math.min(i[1], t.items.length);
                for (e = 1; e <= (t.direction ? r : n); e++) t._preloadItem(t.index + e);
                for (e = 1; e <= (t.direction ? n : r); e++) t._preloadItem(t.index - e)
            },
            _preloadItem: function(i) {
                if (i = k(i), !t.items[i].preloaded) {
                    var n = t.items[i];
                    n.parsed || (n = t.parseEl(i)), _("LazyLoad", n), "image" === n.type && (n.img = e('<img class="mfp-img" />').on("load.mfploader", (function() {
                        n.hasSize = !0
                    })).on("error.mfploader", (function() {
                        n.hasSize = !0, n.loadError = !0, _("LazyLoadError", n)
                    })).attr("src", n.src)), n.preloaded = !0
                }
            }
        }
    });
    var H = "retina";
    e.magnificPopup.registerModule(H, {
        options: {
            replaceSrc: function(e) {
                return e.src.replace(/\.\w+$/, (function(e) {
                    return "@2x" + e
                }))
            },
            ratio: 1
        },
        proto: {
            initRetina: function() {
                if (window.devicePixelRatio > 1) {
                    var e = t.st.retina,
                        i = e.ratio;
                    (i = isNaN(i) ? i() : i) > 1 && (x("ImageHasSize." + H, (function(e, t) {
                        t.img.css({
                            "max-width": t.img[0].naturalWidth / i,
                            width: "100%"
                        })
                    })), x("ElementParse." + H, (function(t, n) {
                        n.src = e.replaceSrc(n, i)
                    })))
                }
            }
        }
    }), M()
})),
function(e) {
    e.fn.niceSelect = function(t) {
        function i(t) {
            t.after(e("<div></div>").addClass("nice-select").addClass(t.attr("class") || "").addClass(t.attr("disabled") ? "disabled" : "").attr("tabindex", t.attr("disabled") ? null : "0").html('<span class="current"></span><ul class="list"></ul>'));
            var i = t.next(),
                n = t.find("option"),
                r = t.find("option:selected");
            i.find(".current").html(r.data("display") || r.text()), n.each((function(t) {
                var n = e(this),
                    r = n.data("display");
                i.find("ul").append(e("<li></li>").attr("data-value", n.val()).attr("data-display", r || null).addClass("option" + (n.is(":selected") ? " selected" : "") + (n.is(":disabled") ? " disabled" : "")).html(n.text()))
            }))
        }
        if ("string" == typeof t) return "update" == t ? this.each((function() {
            var t = e(this),
                n = e(this).next(".nice-select"),
                r = n.hasClass("open");
            n.length && (n.remove(), i(t), r && t.next().trigger("click"))
        })) : "destroy" == t ? (this.each((function() {
            var t = e(this),
                i = e(this).next(".nice-select");
            i.length && (i.remove(), t.css("display", ""))
        })), 0 == e(".nice-select").length && e(document).off(".nice_select")) : console.log('Method "' + t + '" does not exist.'), this;
        this.hide(), this.each((function() {
            var t = e(this);
            t.next().hasClass("nice-select") || i(t)
        })), e(document).off(".nice_select"), e(document).on("click.nice_select", ".nice-select", (function(t) {
            var i = e(this);
            e(".nice-select").not(i).removeClass("open"), i.toggleClass("open"), i.hasClass("open") ? (i.find(".option"), i.find(".focus").removeClass("focus"), i.find(".selected").addClass("focus")) : i.focus()
        })), e(document).on("click.nice_select", (function(t) {
            0 === e(t.target).closest(".nice-select").length && e(".nice-select").removeClass("open").find(".option")
        })), e(document).on("click.nice_select", ".nice-select .option:not(.disabled)", (function(t) {
            var i = e(this),
                n = i.closest(".nice-select");
            n.find(".selected").removeClass("selected"), i.addClass("selected");
            var r = i.data("display") || i.text();
            n.find(".current").text(r), n.prev("select").val(i.data("value")).trigger("change")
        })), e(document).on("keydown.nice_select", ".nice-select", (function(t) {
            var i = e(this),
                n = e(i.find(".focus") || i.find(".list .option.selected"));
            if (32 == t.keyCode || 13 == t.keyCode) return i.hasClass("open") ? n.trigger("click") : i.trigger("click"), !1;
            if (40 == t.keyCode) {
                if (i.hasClass("open")) {
                    var r = n.nextAll(".option:not(.disabled)").first();
                    r.length > 0 && (i.find(".focus").removeClass("focus"), r.addClass("focus"))
                } else i.trigger("click");
                return !1
            }
            if (38 == t.keyCode) {
                if (i.hasClass("open")) {
                    var o = n.prevAll(".option:not(.disabled)").first();
                    o.length > 0 && (i.find(".focus").removeClass("focus"), o.addClass("focus"))
                } else i.trigger("click");
                return !1
            }
            if (27 == t.keyCode) i.hasClass("open") && i.trigger("click");
            else if (9 == t.keyCode && i.hasClass("open")) return !1
        }));
        var n = document.createElement("a").style;
        return n.cssText = "pointer-events:auto", "auto" !== n.pointerEvents && e("html").addClass("no-csspointerevents"), this
    }
}(jQuery),
function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports, require("three")) : "function" == typeof define && define.amd ? define(["exports", "three"], t) : t((e = e || self).PANOLENS = {}, e.THREE)
}(this, (function(e, t) {
    function i(e) {
        this.constraints = Object.assign({
            video: {
                width: {
                    ideal: 1920
                },
                height: {
                    ideal: 1080
                },
                facingMode: {
                    exact: "environment"
                }
            },
            audio: !1
        }, e), this.element = this.scene = this.container = null, this.devices = [], this.stream = null, this.ratioScalar = 1, this.videoDeviceIndex = 0
    }

    function n(e, i, n) {
        e = void 0 === e ? 16777215 : e, i = void 0 === i || i, n = void 0 === n ? 1500 : n, this.dpr = window.devicePixelRatio;
        var r = this.createCanvas(),
            o = r.canvas;
        r = r.context;
        var a = new t.SpriteMaterial({
            color: e,
            map: this.createCanvasTexture(o)
        });
        t.Sprite.call(this, a), this.canvasWidth = o.width, this.canvasHeight = o.height, this.context = r, this.color = e instanceof t.Color ? e : new t.Color(e), this.autoSelect = i, this.dwellTime = n, this.rippleDuration = 500, this.position.z = -10, this.center.set(.5, .5), this.scale.set(.5, .5, 1), this.callback = this.timerId = this.startTimestamp = null, this.frustumCulled = !1, this.updateCanvasArcByProgress(0)
    }

    function r(e, i, n) {
        e = void 0 === e ? 300 : e, i = i || M.Info, t.Sprite.call(this), this.type = "infospot", this.animated = void 0 === n || n, this.frustumCulled = this.isHovering = !1, this.cursorStyle = this.toPanorama = this.element = null, this.mode = E.NORMAL, this.scale.set(e, e, 1), this.rotation.y = Math.PI, this.container = null, this.originalRaycast = this.raycast, this.HANDLER_FOCUS = null, this.material.side = t.DoubleSide, this.material.depthTest = !1, this.material.transparent = !0, this.material.opacity = 0, this.scaleUpAnimation = new L.Tween, this.scaleDownAnimation = new L.Tween, n = function(i) {
            if (this.material) {
                var n = i.image.width / i.image.height,
                    r = new t.Vector3;
                i.image.width = i.image.naturalWidth || 64, i.image.height = i.image.naturalHeight || 64, this.scale.set(n * e, e, 1), r.copy(this.scale), this.scaleUpAnimation = new L.Tween(this.scale).to({
                    x: 1.3 * r.x,
                    y: 1.3 * r.y
                }, 500).easing(L.Easing.Elastic.Out), this.scaleDownAnimation = new L.Tween(this.scale).to({
                    x: r.x,
                    y: r.y
                }, 500).easing(L.Easing.Elastic.Out), this.material.map = i, this.material.needsUpdate = !0
            }
        }.bind(this), this.showAnimation = new L.Tween(this.material).to({
            opacity: 1
        }, 500).onStart(this.enableRaycast.bind(this, !0)).easing(L.Easing.Quartic.Out), this.hideAnimation = new L.Tween(this.material).to({
            opacity: 0
        }, 500).onStart(this.enableRaycast.bind(this, !1)).easing(L.Easing.Quartic.Out), this.addEventListener("click", this.onClick), this.addEventListener("hover", this.onHover), this.addEventListener("hoverenter", this.onHoverStart), this.addEventListener("hoverleave", this.onHoverEnd), this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("dismiss", this.onDismiss), this.addEventListener("panolens-infospot-focus", this.setFocusMethod), S.load(i, n)
    }

    function o(e) {
        e || console.warn("PANOLENS.Widget: No container specified"), t.EventDispatcher.call(this), this.DEFAULT_TRANSITION = "all 0.27s ease", this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch), this.PREVENT_EVENT_HANDLER = function(e) {
            e.preventDefault(), e.stopPropagation()
        }, this.container = e, this.mask = this.activeSubMenu = this.activeMainItem = this.mainMenu = this.settingElement = this.videoElement = this.fullscreenElement = this.barElement = null
    }

    function a(e, i) {
        t.Mesh.call(this, e, i), this.type = "panorama", this.ImageQualityLow = 1, this.ImageQualityFair = 2, this.ImageQualityMedium = 3, this.ImageQualityHigh = 4, this.ImageQualitySuperHigh = 5, this.animationDuration = 1e3, this.defaultInfospotSize = 350, this.container = void 0, this.loaded = !1, this.linkedSpots = [], this.isInfospotVisible = !1, this.linkingImageScale = this.linkingImageURL = void 0, this.material.side = t.BackSide, this.material.opacity = 0, this.scale.x *= -1, this.renderOrder = -1, this.active = !1, this.infospotAnimation = new L.Tween(this).to({}, this.animationDuration / 2), this.addEventListener("load", this.fadeIn.bind(this)), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("click", this.onClick.bind(this)), this.setupTransitions()
    }

    function s(e, i, n) {
        i = i || new t.SphereBufferGeometry(5e3, 60, 40), n = n || new t.MeshBasicMaterial({
            opacity: 0,
            transparent: !0
        }), a.call(this, i, n), this.src = e, this.radius = 5e3
    }

    function l() {
        var e = new t.BufferGeometry,
            i = new t.MeshBasicMaterial({
                color: 0,
                opacity: 0,
                transparent: !0
            });
        e.addAttribute("position", new t.BufferAttribute(new Float32Array, 1)), a.call(this, e, i)
    }

    function c(e) {
        e = void 0 === e ? [] : e;
        var i = Object.assign({}, t.ShaderLib.cube),
            n = new t.BoxBufferGeometry(1e4, 1e4, 1e4);
        i = new t.ShaderMaterial({
            fragmentShader: i.fragmentShader,
            vertexShader: i.vertexShader,
            uniforms: i.uniforms,
            side: t.BackSide,
            transparent: !0
        }), a.call(this, n, i), this.images = e, this.edgeLength = 1e4, this.material.uniforms.opacity.value = 0
    }

    function h() {
        for (var e = [], t = 0; 6 > t; t++) e.push(M.WhiteTile);
        c.call(this, e)
    }

    function u(e, i) {
        i = void 0 === i ? {} : i;
        var n = new t.SphereBufferGeometry(5e3, 60, 40),
            r = new t.MeshBasicMaterial({
                opacity: 0,
                transparent: !0
            });
        a.call(this, n, r), this.src = e, this.options = {
            videoElement: document.createElement("video"),
            loop: !0,
            muted: !0,
            autoplay: !1,
            playsinline: !0,
            crossOrigin: "anonymous"
        }, Object.assign(this.options, i), this.videoElement = this.options.videoElement, this.videoProgress = 0, this.radius = 5e3, this.addEventListener("leave", this.pauseVideo.bind(this)), this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.addEventListener("video-toggle", this.toggleVideo.bind(this)), this.addEventListener("video-time", this.setVideoCurrentTime.bind(this))
    }

    function d(e) {
        var t;
        this._parameters = e = void 0 === e ? {} : e, this._panoId = this._zoom = null, this._panoClient = new google.maps.StreetViewService, this._total = this._count = 0, this._canvas = [], this._ctx = [], this._hc = this._wc = 0, this.result = null, this.rotation = 0, this.copyright = "", this.onPanoramaLoad = this.onSizeChange = null, this.levelsW = [1, 2, 4, 7, 13, 26], this.levelsH = [1, 1, 2, 4, 7, 13], this.widths = [416, 832, 1664, 3328, 6656, 13312], this.heights = [416, 416, 832, 1664, 3328, 6656], this.maxH = this.maxW = 6656;
        try {
            var i = document.createElement("canvas");
            (t = i.getContext("experimental-webgl")) || (t = i.getContext("webgl"))
        } catch (e) {}
        this.maxW = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxW), this.maxH = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxH)
    }

    function p(e, t) {
        s.call(this), this.panoId = e, this.gsvLoader = null, this.loadRequested = !1, this.setupGoogleMapAPI(t)
    }

    function f(e, i, n, r) {
        n = void 0 === n ? 1e4 : n, r = void 0 === r ? .5 : r, "image" === (void 0 === e ? "image" : e) && s.call(this, i, this.createGeometry(n, r), this.createMaterial(n)), this.size = n, this.ratio = r, this.EPS = 1e-6, this.frameId = null, this.dragging = !1, this.userMouse = new t.Vector2, this.quatA = new t.Quaternion, this.quatB = new t.Quaternion, this.quatCur = new t.Quaternion, this.quatSlerp = new t.Quaternion, this.vectorX = new t.Vector3(1, 0, 0), this.vectorY = new t.Vector3(0, 1, 0), this.addEventListener("window-resize", this.onWindowResize)
    }

    function m(e, t, i) {
        f.call(this, "image", e, t, i)
    }

    function g(e) {
        var n = new t.SphereBufferGeometry(5e3, 60, 40),
            r = new t.MeshBasicMaterial({
                visible: !1
            });
        a.call(this, n, r), this.media = new i(e), this.radius = 5e3, this.addEventListener("enter", this.start.bind(this)), this.addEventListener("leave", this.stop.bind(this)), this.addEventListener("panolens-container", this.onPanolensContainer.bind(this)), this.addEventListener("panolens-scene", this.onPanolensScene.bind(this))
    }

    function v(e, i) {
        function n(e) {
            if (k = !1, B = F = 0, !1 !== v.enabled) {
                if (e.preventDefault(), e.button === v.mouseButtons.ORBIT) {
                    if (!0 === v.noRotate) return;
                    H = U.ROTATE, y.set(e.clientX, e.clientY)
                } else if (e.button === v.mouseButtons.ZOOM) {
                    if (!0 === v.noZoom) return;
                    H = U.DOLLY, S.set(e.clientX, e.clientY)
                } else if (e.button === v.mouseButtons.PAN) {
                    if (!0 === v.noPan) return;
                    H = U.PAN, w.set(e.clientX, e.clientY)
                }
                H !== U.NONE && (document.addEventListener("mousemove", r, !1), document.addEventListener("mouseup", o, !1), v.dispatchEvent(W)), v.update()
            }
        }

        function r(e) {
            if (!1 !== v.enabled) {
                e.preventDefault();
                var t = v.domElement === document ? v.domElement.body : v.domElement;
                if (H === U.ROTATE) {
                    if (!0 === v.noRotate) return;
                    b.set(e.clientX, e.clientY), x.subVectors(b, y), v.rotateLeft(2 * Math.PI * x.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * x.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (B = e.clientX - d.clientX, F = e.clientY - d.clientY), d = e
                } else if (H === U.DOLLY) {
                    if (!0 === v.noZoom) return;
                    A.set(e.clientX, e.clientY), C.subVectors(A, S), 0 < C.y ? v.dollyIn() : 0 > C.y && v.dollyOut(), S.copy(A)
                } else if (H === U.PAN) {
                    if (!0 === v.noPan) return;
                    _.set(e.clientX, e.clientY), E.subVectors(_, w), v.pan(E.x, E.y), w.copy(_)
                }
                H !== U.NONE && v.update()
            }
        }

        function o() {
            k = !0, d = void 0, !1 !== v.enabled && (document.removeEventListener("mousemove", r, !1), document.removeEventListener("mouseup", o, !1), v.dispatchEvent(q), H = U.NONE)
        }

        function a(e) {
            if (!1 !== v.enabled && !0 !== v.noZoom && H === U.NONE) {
                e.preventDefault(), e.stopPropagation();
                var t = 0;
                void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), 0 < t ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 > t && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), v.update(), v.dispatchEvent(V), v.dispatchEvent(W), v.dispatchEvent(q)
            }
        }

        function s(e) {
            switch (e.keyCode) {
                case v.keys.UP:
                    p = !1;
                    break;
                case v.keys.BOTTOM:
                    f = !1;
                    break;
                case v.keys.LEFT:
                    m = !1;
                    break;
                case v.keys.RIGHT:
                    g = !1
            }
        }

        function l(e) {
            if (!1 !== v.enabled && !0 !== v.noKeys && !0 !== v.noRotate) {
                switch (e.keyCode) {
                    case v.keys.UP:
                        p = !0;
                        break;
                    case v.keys.BOTTOM:
                        f = !0;
                        break;
                    case v.keys.LEFT:
                        m = !0;
                        break;
                    case v.keys.RIGHT:
                        g = !0
                }(p || f || m || g) && (k = !0, p && (F = -v.rotateSpeed * v.momentumKeydownFactor), f && (F = v.rotateSpeed * v.momentumKeydownFactor), m && (B = -v.rotateSpeed * v.momentumKeydownFactor), g && (B = v.rotateSpeed * v.momentumKeydownFactor))
            }
        }

        function c(e) {
            if (k = !1, B = F = 0, !1 !== v.enabled) {
                switch (e.touches.length) {
                    case 1:
                        if (!0 === v.noRotate) return;
                        H = U.TOUCH_ROTATE, y.set(e.touches[0].pageX, e.touches[0].pageY);
                        break;
                    case 2:
                        if (!0 === v.noZoom) return;
                        H = U.TOUCH_DOLLY;
                        var t = e.touches[0].pageX - e.touches[1].pageX;
                        e = e.touches[0].pageY - e.touches[1].pageY, S.set(0, Math.sqrt(t * t + e * e));
                        break;
                    case 3:
                        if (!0 === v.noPan) return;
                        H = U.TOUCH_PAN, w.set(e.touches[0].pageX, e.touches[0].pageY);
                        break;
                    default:
                        H = U.NONE
                }
                H !== U.NONE && v.dispatchEvent(W)
            }
        }

        function h(e) {
            if (!1 !== v.enabled) {
                e.preventDefault(), e.stopPropagation();
                var t = v.domElement === document ? v.domElement.body : v.domElement;
                switch (e.touches.length) {
                    case 1:
                        if (!0 === v.noRotate) break;
                        if (H !== U.TOUCH_ROTATE) break;
                        b.set(e.touches[0].pageX, e.touches[0].pageY), x.subVectors(b, y), v.rotateLeft(2 * Math.PI * x.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * x.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (B = e.touches[0].pageX - d.pageX, F = e.touches[0].pageY - d.pageY), d = {
                            pageX: e.touches[0].pageX,
                            pageY: e.touches[0].pageY
                        }, v.update();
                        break;
                    case 2:
                        if (!0 === v.noZoom) break;
                        if (H !== U.TOUCH_DOLLY) break;
                        t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, A.set(0, Math.sqrt(t * t + e * e)), C.subVectors(A, S), 0 > C.y ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 < C.y && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), S.copy(A), v.update(), v.dispatchEvent(V);
                        break;
                    case 3:
                        if (!0 === v.noPan) break;
                        if (H !== U.TOUCH_PAN) break;
                        _.set(e.touches[0].pageX, e.touches[0].pageY), E.subVectors(_, w), v.pan(E.x, E.y), w.copy(_), v.update();
                        break;
                    default:
                        H = U.NONE
                }
            }
        }

        function u() {
            k = !0, d = void 0, !1 !== v.enabled && (v.dispatchEvent(q), H = U.NONE)
        }
        this.object = e, this.domElement = void 0 !== i ? i : document, this.frameId = null, this.enabled = !0, this.center = this.target = new t.Vector3, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.noRotate = !1, this.rotateSpeed = -.15, this.noPan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.momentumDampingFactor = .9, this.momentumScalingFactor = -.005, this.momentumKeydownFactor = 20, this.minFov = 30, this.maxFov = 120, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        }, this.mouseButtons = {
            ORBIT: t.MOUSE.LEFT,
            ZOOM: t.MOUSE.MIDDLE,
            PAN: t.MOUSE.RIGHT
        };
        var d, p, f, m, g, v = this,
            y = new t.Vector2,
            b = new t.Vector2,
            x = new t.Vector2,
            w = new t.Vector2,
            _ = new t.Vector2,
            E = new t.Vector2,
            M = new t.Vector3,
            T = new t.Vector3,
            S = new t.Vector2,
            A = new t.Vector2,
            C = new t.Vector2,
            L = 0,
            D = 0,
            P = 0,
            R = 0,
            O = 1,
            I = new t.Vector3,
            z = new t.Vector3,
            N = new t.Quaternion,
            B = 0,
            F = 0,
            k = !1,
            U = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            },
            H = U.NONE;
        this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom;
        var G = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
            j = G.clone().inverse(),
            V = {
                type: "change"
            },
            W = {
                type: "start"
            },
            q = {
                type: "end"
            };
        this.setLastQuaternion = function(e) {
            N.copy(e), v.object.quaternion.copy(e)
        }, this.getLastPosition = function() {
            return z
        }, this.rotateLeft = function(e) {
            void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), R -= e
        }, this.rotateUp = function(e) {
            void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), P -= e
        }, this.panLeft = function(e) {
            var t = this.object.matrix.elements;
            M.set(t[0], t[1], t[2]), M.multiplyScalar(-e), I.add(M)
        }, this.panUp = function(e) {
            var t = this.object.matrix.elements;
            M.set(t[4], t[5], t[6]), M.multiplyScalar(e), I.add(M)
        }, this.pan = function(e, i) {
            var n = v.domElement === document ? v.domElement.body : v.domElement;
            if (v.object instanceof t.PerspectiveCamera) {
                var r = v.object.position.clone().sub(v.target).length();
                r *= Math.tan(v.object.fov / 2 * Math.PI / 180), v.panLeft(2 * e * r / n.clientHeight), v.panUp(2 * i * r / n.clientHeight)
            } else v.object instanceof t.OrthographicCamera ? (v.panLeft(e * (v.object.right - v.object.left) / n.clientWidth), v.panUp(i * (v.object.top - v.object.bottom) / n.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
        }, this.momentum = function() {
            k && (1e-4 > Math.abs(B) && 1e-4 > Math.abs(F) ? k = !1 : (F *= this.momentumDampingFactor, B *= this.momentumDampingFactor, R -= this.momentumScalingFactor * B, P -= this.momentumScalingFactor * F))
        }, this.dollyIn = function(e) {
            void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? O /= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }, this.dollyOut = function(e) {
            void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? O *= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }, this.update = function(e) {
            var t = this.object.position;
            T.copy(t).sub(this.target), T.applyQuaternion(G), L = Math.atan2(T.x, T.z), D = Math.atan2(Math.sqrt(T.x * T.x + T.z * T.z), T.y), this.autoRotate && H === U.NONE && this.rotateLeft(2 * Math.PI / 60 / 60 * v.autoRotateSpeed), this.momentum(), L += R, D += P, L = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, L)), D = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, D)), D = Math.max(1e-7, Math.min(Math.PI - 1e-7, D));
            var i = T.length() * O;
            i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(I), T.x = i * Math.sin(D) * Math.sin(L), T.y = i * Math.cos(D), T.z = i * Math.sin(D) * Math.cos(L), T.applyQuaternion(j), t.copy(this.target).add(T), this.object.lookAt(this.target), P = R = 0, O = 1, I.set(0, 0, 0), (1e-7 < z.distanceToSquared(this.object.position) || 1e-7 < 8 * (1 - N.dot(this.object.quaternion))) && (!0 !== e && this.dispatchEvent(V), z.copy(this.object.position), N.copy(this.object.quaternion))
        }, this.reset = function() {
            H = U.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(V), this.update()
        }, this.getPolarAngle = function() {
            return D
        }, this.getAzimuthalAngle = function() {
            return L
        }, this.dispose = function() {
            this.domElement.removeEventListener("mousedown", n), this.domElement.removeEventListener("mousewheel", a), this.domElement.removeEventListener("DOMMouseScroll", a), this.domElement.removeEventListener("touchstart", c), this.domElement.removeEventListener("touchend", u), this.domElement.removeEventListener("touchmove", h), window.removeEventListener("keyup", s), window.removeEventListener("keydown", l)
        }, this.domElement.addEventListener("mousedown", n, {
            passive: !1
        }), this.domElement.addEventListener("mousewheel", a, {
            passive: !1
        }), this.domElement.addEventListener("DOMMouseScroll", a, {
            passive: !1
        }), this.domElement.addEventListener("touchstart", c, {
            passive: !1
        }), this.domElement.addEventListener("touchend", u, {
            passive: !1
        }), this.domElement.addEventListener("touchmove", h, {
            passive: !1
        }), window.addEventListener("keyup", s, {
            passive: !1
        }), window.addEventListener("keydown", l, {
            passive: !1
        }), this.update()
    }

    function y(e, i) {
        var n = this,
            r = {
                type: "change"
            },
            o = 0,
            a = 0,
            s = 0,
            l = 0;
        this.camera = e, this.camera.rotation.reorder("YXZ"), this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.deviceOrientation = {}, this.alphaOffsetAngle = this.alpha = this.screenOrientation = 0;
        var c = function(e) {
                n.deviceOrientation = e
            },
            h = function() {
                n.screenOrientation = window.orientation || 0
            },
            u = function(e) {
                e.preventDefault(), e.stopPropagation(), s = e.touches[0].pageX, l = e.touches[0].pageY
            },
            d = function(e) {
                e.preventDefault(), e.stopPropagation(), o += t.Math.degToRad((e.touches[0].pageX - s) / 4), a += t.Math.degToRad((l - e.touches[0].pageY) / 4), n.updateAlphaOffsetAngle(o), s = e.touches[0].pageX, l = e.touches[0].pageY
            };
        this.connect = function() {
            h(), window.addEventListener("orientationchange", h, {
                passive: !0
            }), window.addEventListener("deviceorientation", c, {
                passive: !0
            }), window.addEventListener("deviceorientation", this.update.bind(this), {
                passive: !0
            }), n.domElement.addEventListener("touchstart", u, {
                passive: !1
            }), n.domElement.addEventListener("touchmove", d, {
                passive: !1
            }), n.enabled = !0
        }, this.disconnect = function() {
            window.removeEventListener("orientationchange", h, !1), window.removeEventListener("deviceorientation", c, !1), window.removeEventListener("deviceorientation", this.update.bind(this), !1), n.domElement.removeEventListener("touchstart", u, !1), n.domElement.removeEventListener("touchmove", d, !1), n.enabled = !1
        }, this.update = function(e) {
            if (!1 !== n.enabled) {
                var i = n.deviceOrientation.alpha ? t.Math.degToRad(n.deviceOrientation.alpha) + n.alphaOffsetAngle : 0,
                    o = n.deviceOrientation.beta ? t.Math.degToRad(n.deviceOrientation.beta) : 0,
                    s = n.deviceOrientation.gamma ? t.Math.degToRad(n.deviceOrientation.gamma) : 0,
                    l = n.screenOrientation ? t.Math.degToRad(n.screenOrientation) : 0,
                    c = n.camera.quaternion,
                    h = new t.Vector3(0, 0, 1),
                    u = new t.Euler,
                    d = new t.Quaternion,
                    p = new t.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)),
                    f = new t.Quaternion,
                    m = new t.Quaternion;
                if (0 == n.screenOrientation) {
                    var g = new t.Vector3(1, 0, 0);
                    f.setFromAxisAngle(g, -a)
                } else 180 == n.screenOrientation ? (g = new t.Vector3(1, 0, 0), f.setFromAxisAngle(g, a)) : 90 == n.screenOrientation ? (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, a)) : -90 == n.screenOrientation && (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, -a));
                p.multiply(f), p.multiply(m), u.set(o, i, -s, "YXZ"), c.setFromEuler(u), c.multiply(p), c.multiply(d.setFromAxisAngle(h, -l)), n.alpha = i, !0 !== e && n.dispatchEvent(r)
            }
        }, this.updateAlphaOffsetAngle = function(e) {
            this.alphaOffsetAngle = e, this.update()
        }, this.dispose = function() {
            this.disconnect()
        }, this.connect()
    }

    function b(e) {
        var i = new t.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            n = new t.Scene,
            r = new t.StereoCamera;
        r.aspect = .5;
        var o = new t.WebGLRenderTarget(512, 512, {
            minFilter: t.LinearFilter,
            magFilter: t.NearestFilter,
            format: t.RGBAFormat
        });
        o.scissorTest = !0, o.texture.generateMipmaps = !1;
        var a = new t.Vector2(.441, .156),
            s = new t.PlaneBufferGeometry(1, 1, 10, 20).removeAttribute("normal").toNonIndexed(),
            l = s.attributes.position.array,
            c = s.attributes.uv.array;
        s.attributes.position.count *= 2, s.attributes.uv.count *= 2;
        var h = new Float32Array(2 * l.length);
        h.set(l), h.set(l, l.length);
        var u = new Float32Array(2 * c.length);
        u.set(c), u.set(c, c.length), c = new t.Vector2, l = l.length / 3;
        for (var d = 0, p = h.length / 3; d < p; d++) {
            c.x = h[3 * d], c.y = h[3 * d + 1];
            var f = c.dot(c);
            f = 1.5 + (a.x + a.y * f) * f;
            var m = d < l ? 0 : 1;
            h[3 * d] = c.x / f * 1.5 - .5 + m, h[3 * d + 1] = c.y / f * 3, u[2 * d] = .5 * (u[2 * d] + m)
        }
        s.attributes.position.array = h, s.attributes.uv.array = u, a = new t.MeshBasicMaterial({
            map: o.texture
        }), s = new t.Mesh(s, a), n.add(s), this.setSize = function(t, i) {
            e.setSize(t, i);
            var n = e.getPixelRatio();
            o.setSize(t * n, i * n)
        }, this.render = function(t, a) {
            t.updateMatrixWorld(), null === a.parent && a.updateMatrixWorld(), r.update(a), a = o.width / 2;
            var s = o.height;
            e.autoClear && e.clear(), o.scissor.set(0, 0, a, s), o.viewport.set(0, 0, a, s), e.setRenderTarget(o), e.render(t, r.cameraL), e.clearDepth(), o.scissor.set(a, 0, a, s), o.viewport.set(a, 0, a, s), e.setRenderTarget(o), e.render(t, r.cameraR), e.clearDepth(), e.setRenderTarget(null), e.render(n, i)
        }
    }

    function x(e) {
        if ((e = e || {}).controlBar = void 0 === e.controlBar || e.controlBar, e.controlButtons = e.controlButtons || ["fullscreen", "setting", "video"], e.autoHideControlBar = void 0 !== e.autoHideControlBar && e.autoHideControlBar, e.autoHideInfospot = void 0 === e.autoHideInfospot || e.autoHideInfospot, e.horizontalView = void 0 !== e.horizontalView && e.horizontalView, e.clickTolerance = e.clickTolerance || 10, e.cameraFov = e.cameraFov || 60, e.reverseDragging = e.reverseDragging || !1, e.enableReticle = e.enableReticle || !1, e.dwellTime = e.dwellTime || 1500, e.autoReticleSelect = void 0 === e.autoReticleSelect || e.autoReticleSelect, e.viewIndicator = void 0 !== e.viewIndicator && e.viewIndicator, e.indicatorSize = e.indicatorSize || 30, e.output = e.output ? e.output : "none", e.autoRotate = e.autoRotate || !1, e.autoRotateSpeed = e.autoRotateSpeed || 2, e.autoRotateActivationDuration = e.autoRotateActivationDuration || 5e3, this.options = e, e.container) {
            var i = e.container;
            i._width = i.clientWidth, i._height = i.clientHeight
        } else(i = document.createElement("div")).classList.add("panolens-container"), i.style.width = "100%", i.style.height = "100%", i._width = window.innerWidth, i._height = window.innerHeight, document.body.appendChild(i);
        this.container = i, this.camera = e.camera || new t.PerspectiveCamera(this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 1e4), this.scene = e.scene || new t.Scene, this.renderer = e.renderer || new t.WebGLRenderer({
            alpha: !0,
            antialias: !1
        }), this.sceneReticle = new t.Scene, this.viewIndicatorSize = this.options.indicatorSize, this.reticle = {}, this.tempEnableReticle = this.options.enableReticle, this.mode = E.NORMAL, this.pressObject = this.pressEntityObject = this.infospot = this.hoverObject = this.widget = this.panorama = null, this.raycaster = new t.Raycaster, this.raycasterPoint = new t.Vector2, this.userMouse = new t.Vector2, this.updateCallbacks = [], this.requestAnimationId = null, this.cameraFrustum = new t.Frustum, this.cameraViewProjectionMatrix = new t.Matrix4, this.outputDivElement = this.autoRotateRequestId = null, this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this), this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this), this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this), this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this), this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this), this.HANDLER_KEY_UP = this.onKeyUp.bind(this), this.HANDLER_TAP = this.onTap.bind(this, {
            clientX: this.container.clientWidth / 2,
            clientY: this.container.clientHeight / 2
        }), this.OUTPUT_INFOSPOT = !1, this.tweenLeftAnimation = new L.Tween, this.tweenUpAnimation = new L.Tween, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.renderer.setClearColor(0, 0), this.renderer.autoClear = !1, this.renderer.domElement.classList.add("panolens-canvas"), this.renderer.domElement.style.display = "block", this.container.style.backgroundColor = "#000", this.container.appendChild(this.renderer.domElement), this.OrbitControls = new v(this.camera, this.container), this.OrbitControls.id = "orbit", this.OrbitControls.minDistance = 1, this.OrbitControls.noPan = !0, this.OrbitControls.autoRotate = this.options.autoRotate, this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed, this.DeviceOrientationControls = new y(this.camera, this.container), this.DeviceOrientationControls.id = "device-orientation", this.DeviceOrientationControls.enabled = !1, this.camera.position.z = 1, this.options.passiveRendering && console.warn("passiveRendering is now deprecated"), this.controls = [this.OrbitControls, this.DeviceOrientationControls], this.control = this.OrbitControls, this.CardboardEffect = new b(this.renderer), this.CardboardEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.StereoEffect = new P(this.renderer), this.StereoEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.effect = this.CardboardEffect, this.addReticle(), this.options.horizontalView && (this.OrbitControls.minPolarAngle = Math.PI / 2, this.OrbitControls.maxPolarAngle = Math.PI / 2), !1 !== this.options.controlBar && this.addDefaultControlBar(this.options.controlButtons), this.options.viewIndicator && this.addViewIndicator(), this.options.reverseDragging && this.reverseDraggingDirection(), this.options.enableReticle ? this.enableReticleControl() : this.registerMouseAndTouchEvents(), "overlay" === this.options.output && this.addOutputElement(), this.registerEventListeners(), this.animate.call(this)
    }
    var w = "^0.105.2".replace(/[^0-9.]/g, ""),
        _ = {
            ORBIT: 0,
            DEVICEORIENTATION: 1
        },
        E = {
            UNKNOWN: 0,
            NORMAL: 1,
            CARDBOARD: 2,
            STEREO: 3
        },
        M = {
            Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC",
            Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=",
            FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
            FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
            VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
            VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
            WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==",
            Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC",
            ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
            Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
            ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+"
        },
        T = {
            load: function(e, i, n, r) {
                var o, a, s, l;
                for (l in i = void 0 === i ? function() {} : i, n = void 0 === n ? function() {} : n, r = void 0 === r ? function() {} : r, t.Cache.enabled = !0, M) M.hasOwnProperty(l) && e === M[l] && (o = l);
                var c = t.Cache.get(o || e);
                if (void 0 !== c) return i && setTimeout((function() {
                    n({
                        loaded: 1,
                        total: 1
                    }), i(c)
                }), 0), c;
                var h = window.URL || window.webkitURL,
                    u = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                t.Cache.add(o || e, u);
                var d = function() {
                    h.revokeObjectURL(u.src), i(u)
                };
                if (0 === e.indexOf("data:")) return u.addEventListener("load", d, !1), u.src = e, u;
                u.crossOrigin = void 0 !== this.crossOrigin ? this.crossOrigin : "", (o = new window.XMLHttpRequest).open("GET", e, !0), o.responseType = "arraybuffer", o.addEventListener("error", r), o.addEventListener("progress", (function(e) {
                    if (e) {
                        var t = e.loaded,
                            i = e.total;
                        e.lengthComputable && n({
                            loaded: t,
                            total: i
                        })
                    }
                })), o.addEventListener("loadend", (function(e) {
                    e && (a = new Uint8Array(e.currentTarget.response), s = new window.Blob([a]), u.addEventListener("load", d, !1), u.src = h.createObjectURL(s))
                })), o.send(null)
            }
        },
        S = {
            load: function(e, i, n, r) {
                i = void 0 === i ? function() {} : i;
                var o = new t.Texture;
                return T.load(e, (function(n) {
                    o.image = n, n = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data:image\/jpeg/), o.format = n ? t.RGBFormat : t.RGBAFormat, o.needsUpdate = !0, i(o)
                }), n, r), o
            }
        },
        A = {
            load: function(e, i, n, r) {
                var o;
                i = void 0 === i ? function() {} : i, n = void 0 === n ? function() {} : n;
                var a = new t.CubeTexture([]),
                    s = 0,
                    l = {},
                    c = {};
                return e.map((function(e, t) {
                    T.load(e, (function(e) {
                        a.images[t] = e, 6 === ++s && (a.needsUpdate = !0, i(a))
                    }), (function(e) {
                        for (var i in l[t] = {
                                loaded: e.loaded,
                                total: e.total
                            }, c.loaded = 0, o = c.total = 0, l) o++, c.loaded += l[i].loaded, c.total += l[i].total;
                        6 > o && (c.total = c.total / o * 6), n(c)
                    }), r)
                })), a
            }
        };
    i.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        setContainer: function(e) {
            this.container = e
        },
        setScene: function(e) {
            this.scene = e
        },
        enumerateDevices: function() {
            var e = this.devices,
                t = new Promise((function(t) {
                    t(e)
                }));
            return 0 < e.length ? t : window.navigator.mediaDevices.enumerateDevices()
        },
        switchNextVideoDevice: function() {
            var e = this.stop.bind(this),
                t = this.start.bind(this),
                i = this.setVideDeviceIndex.bind(this),
                n = this.videoDeviceIndex;
            this.getDevices("video").then((function(r) {
                e(), ++n >= r.length ? (i(0), n--) : i(n), t(r[n])
            }))
        },
        getDevices: function(e) {
            e = void 0 === e ? "video" : e;
            var t = this.devices;
            return this.enumerateDevices().then((function(e) {
                return e.map((function(e) {
                    return t.includes(e) || t.push(e), e
                }))
            })).then((function(t) {
                var i = new RegExp(e, "i");
                return t.filter((function(e) {
                    return i.test(e.kind)
                }))
            }))
        },
        getUserMedia: function(e) {
            var t = this.setMediaStream.bind(this),
                i = this.playVideo.bind(this);
            return window.navigator.mediaDevices.getUserMedia(e).then(t).then(i).catch((function(e) {
                console.warn("PANOLENS.Media: " + e)
            }))
        },
        setVideDeviceIndex: function(e) {
            this.videoDeviceIndex = e
        },
        start: function(e) {
            var t = this.constraints,
                i = this.getUserMedia.bind(this);
            return this.element = this.createVideoElement(), this.getDevices().then((function(n) {
                if (!n || 0 === n.length) throw Error("no video device found");
                return t.video.deviceId = (e || n[0]).deviceId, i(t)
            }))
        },
        stop: function() {
            var e = this.stream;
            e && e.active && (e.getTracks()[0].stop(), window.removeEventListener("resize", this.onWindowResize.bind(this)), this.stream = this.element = null)
        },
        setMediaStream: function(e) {
            this.stream = e, this.element.srcObject = e, this.scene && (this.scene.background = this.createVideoTexture()), window.addEventListener("resize", this.onWindowResize.bind(this))
        },
        playVideo: function() {
            var e = this.element;
            e && (e.play(), this.dispatchEvent({
                type: "play"
            }))
        },
        pauseVideo: function() {
            var e = this.element;
            e && (e.pause(), this.dispatchEvent({
                type: "pause"
            }))
        },
        createVideoTexture: function() {
            var e = this.element,
                i = new t.VideoTexture(e);
            return i.generateMipmaps = !1, i.minFilter = t.LinearFilter, i.magFilter = t.LinearFilter, i.format = t.RGBFormat, i.center.set(.5, .5), e.addEventListener("canplay", this.onWindowResize.bind(this)), i
        },
        createVideoElement: function() {
            var e = this.dispatchEvent.bind(this),
                t = document.createElement("video");
            return t.setAttribute("autoplay", ""), t.setAttribute("muted", ""), t.setAttribute("playsinline", ""), t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.objectPosition = "center", t.style.objectFit = "cover", t.style.display = this.scene ? "none" : "", t.addEventListener("canplay", (function() {
                return e({
                    type: "canplay"
                })
            })), t
        },
        onWindowResize: function() {
            if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) {
                var e = this.container,
                    t = e.clientWidth;
                e = e.clientHeight;
                var i = this.scene.background,
                    n = this.element;
                n = n.videoHeight / n.videoWidth * (this.container ? t / e : 1) * this.ratioScalar, t > e ? i.repeat.set(n, 1) : i.repeat.set(1, 1 / n)
            }
        }
    }), n.prototype = Object.assign(Object.create(t.Sprite.prototype), {
        constructor: n,
        setColor: function(e) {
            this.material.color.copy(e instanceof t.Color ? e : new t.Color(e))
        },
        createCanvasTexture: function(e) {
            return (e = new t.CanvasTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.generateMipmaps = !1, e
        },
        createCanvas: function() {
            var e = document.createElement("canvas"),
                t = e.getContext("2d"),
                i = this.dpr;
            return e.width = 32 * i, e.height = 32 * i, t.scale(i, i), t.shadowBlur = 5, t.shadowColor = "rgba(200,200,200,0.9)", {
                canvas: e,
                context: t
            }
        },
        updateCanvasArcByProgress: function(e) {
            var t = this.context,
                i = this.canvasWidth,
                n = this.canvasHeight,
                r = this.material,
                o = this.dpr,
                a = e * Math.PI * 2,
                s = this.color.getStyle(),
                l = .5 * i / o;
            o = .5 * n / o, t.clearRect(0, 0, i, n), t.beginPath(), 0 === e ? (t.arc(l, o, i / 16, 0, 2 * Math.PI), t.fillStyle = s, t.fill()) : (t.arc(l, o, i / 4 - 3, -Math.PI / 2, -Math.PI / 2 + a), t.strokeStyle = s, t.lineWidth = 3, t.stroke()), t.closePath(), r.map.needsUpdate = !0
        },
        ripple: function() {
            var e = this,
                t = this.context,
                i = this.canvasWidth,
                n = this.canvasHeight,
                r = this.material,
                o = this.rippleDuration,
                a = performance.now(),
                s = this.color,
                l = this.dpr,
                c = .5 * i / l,
                h = .5 * n / l,
                u = function() {
                    var d = window.requestAnimationFrame(u),
                        p = (performance.now() - a) / o,
                        f = 0 < 1 - p ? 1 - p : 0,
                        m = p * i * .5 / l;
                    t.clearRect(0, 0, i, n), t.beginPath(), t.arc(c, h, m, 0, 2 * Math.PI), t.fillStyle = "rgba(" + 255 * s.r + ", " + 255 * s.g + ", " + 255 * s.b + ", " + f + ")", t.fill(), t.closePath(), 1 <= p && (window.cancelAnimationFrame(d), e.updateCanvasArcByProgress(0), e.dispatchEvent({
                        type: "reticle-ripple-end"
                    })), r.map.needsUpdate = !0
                };
            this.dispatchEvent({
                type: "reticle-ripple-start"
            }), u()
        },
        show: function() {
            this.visible = !0
        },
        hide: function() {
            this.visible = !1
        },
        start: function(e) {
            this.autoSelect && (this.dispatchEvent({
                type: "reticle-start"
            }), this.startTimestamp = performance.now(), this.callback = e, this.update())
        },
        end: function() {
            this.startTimestamp && (window.cancelAnimationFrame(this.timerId), this.updateCanvasArcByProgress(0), this.startTimestamp = this.timerId = this.callback = null, this.dispatchEvent({
                type: "reticle-end"
            }))
        },
        update: function() {
            this.timerId = window.requestAnimationFrame(this.update.bind(this));
            var e = (performance.now() - this.startTimestamp) / this.dwellTime;
            this.updateCanvasArcByProgress(e), this.dispatchEvent({
                type: "reticle-update",
                progress: e
            }), 1 <= e && (window.cancelAnimationFrame(this.timerId), this.callback && this.callback(), this.end(), this.ripple())
        }
    });
    var C, L = (function(e, t) {
        (t = function() {
            this._tweens = {}, this._tweensAddedDuringUpdate = {}
        }).prototype = {
            getAll: function() {
                return Object.keys(this._tweens).map(function(e) {
                    return this._tweens[e]
                }.bind(this))
            },
            removeAll: function() {
                this._tweens = {}
            },
            add: function(e) {
                this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
            },
            remove: function(e) {
                delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
            },
            update: function(e, t) {
                var n = Object.keys(this._tweens);
                if (0 === n.length) return !1;
                for (e = void 0 !== e ? e : i.now(); 0 < n.length;) {
                    this._tweensAddedDuringUpdate = {};
                    for (var r = 0; r < n.length; r++) {
                        var o = this._tweens[n[r]];
                        o && !1 === o.update(e) && (o._isPlaying = !1, t || delete this._tweens[n[r]])
                    }
                    n = Object.keys(this._tweensAddedDuringUpdate)
                }
                return !0
            }
        };
        var i = new t;
        i.Group = t, i._nextId = 0, i.nextId = function() {
            return i._nextId++
        }, i.now = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function() {
            var e = process.hrtime();
            return 1e3 * e[0] + e[1] / 1e6
        } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function() {
            return (new Date).getTime()
        }, i.Tween = function(e, t) {
            this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._reversed = this._isPlaying = this._yoyo = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = i.Easing.Linear.None, this._interpolationFunction = i.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onStopCallback = this._onCompleteCallback = this._onRepeatCallback = this._onUpdateCallback = null, this._group = t || i, this._id = i.nextId()
        }, i.Tween.prototype = {
            getId: function() {
                return this._id
            },
            isPlaying: function() {
                return this._isPlaying
            },
            to: function(e, t) {
                return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
            },
            duration: function(e) {
                return this._duration = e, this
            },
            start: function(e) {
                for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" == typeof e ? i.now() + parseFloat(e) : e : i.now(), this._startTime += this._delayTime, this._valuesEnd) {
                    if (this._valuesEnd[t] instanceof Array) {
                        if (0 === this._valuesEnd[t].length) continue;
                        this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                    }
                    void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], 0 == this._valuesStart[t] instanceof Array && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
                }
                return this
            },
            stop: function() {
                return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this
            },
            end: function() {
                return this.update(1 / 0), this
            },
            stopChainedTweens: function() {
                for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop()
            },
            group: function(e) {
                return this._group = e, this
            },
            delay: function(e) {
                return this._delayTime = e, this
            },
            repeat: function(e) {
                return this._repeat = e, this
            },
            repeatDelay: function(e) {
                return this._repeatDelayTime = e, this
            },
            yoyo: function(e) {
                return this._yoyo = e, this
            },
            easing: function(e) {
                return this._easingFunction = e, this
            },
            interpolation: function(e) {
                return this._interpolationFunction = e, this
            },
            chain: function() {
                return this._chainedTweens = arguments, this
            },
            onStart: function(e) {
                return this._onStartCallback = e, this
            },
            onUpdate: function(e) {
                return this._onUpdateCallback = e, this
            },
            onRepeat: function(e) {
                return this._onRepeatCallback = e, this
            },
            onComplete: function(e) {
                return this._onCompleteCallback = e, this
            },
            onStop: function(e) {
                return this._onStopCallback = e, this
            },
            update: function(e) {
                var t;
                if (e < this._startTime) return !0;
                !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0);
                var i = (e - this._startTime) / this._duration;
                i = 0 === this._duration || 1 < i ? 1 : i;
                var n = this._easingFunction(i);
                for (t in this._valuesEnd)
                    if (void 0 !== this._valuesStart[t]) {
                        var r = this._valuesStart[t] || 0,
                            o = this._valuesEnd[t];
                        o instanceof Array ? this._object[t] = this._interpolationFunction(o, n) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? r + parseFloat(o) : parseFloat(o)), "number" == typeof o && (this._object[t] = r + (o - r) * n))
                    } if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, i), 1 === i) {
                    if (!(0 < this._repeat)) {
                        for (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].start(this._startTime + this._duration);
                        return !1
                    }
                    for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) "string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] += parseFloat(this._valuesEnd[t])), this._yoyo && (i = this._valuesStartRepeat[t], this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = i), this._valuesStart[t] = this._valuesStartRepeat[t];
                    this._yoyo && (this._reversed = !this._reversed), this._startTime = void 0 !== this._repeatDelayTime ? e + this._repeatDelayTime : e + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object)
                }
                return !0
            }
        }, i.Easing = {
            Linear: {
                None: function(e) {
                    return e
                }
            },
            Quadratic: {
                In: function(e) {
                    return e * e
                },
                Out: function(e) {
                    return e * (2 - e)
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                }
            },
            Cubic: {
                In: function(e) {
                    return e * e * e
                },
                Out: function(e) {
                    return --e * e * e + 1
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                }
            },
            Quartic: {
                In: function(e) {
                    return e * e * e * e
                },
                Out: function(e) {
                    return 1 - --e * e * e * e
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                }
            },
            Quintic: {
                In: function(e) {
                    return e * e * e * e * e
                },
                Out: function(e) {
                    return --e * e * e * e * e + 1
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                }
            },
            Sinusoidal: {
                In: function(e) {
                    return 1 - Math.cos(e * Math.PI / 2)
                },
                Out: function(e) {
                    return Math.sin(e * Math.PI / 2)
                },
                InOut: function(e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                }
            },
            Exponential: {
                In: function(e) {
                    return 0 === e ? 0 : Math.pow(1024, e - 1)
                },
                Out: function(e) {
                    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                },
                InOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                }
            },
            Circular: {
                In: function(e) {
                    return 1 - Math.sqrt(1 - e * e)
                },
                Out: function(e) {
                    return Math.sqrt(1 - --e * e)
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }
            },
            Elastic: {
                In: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                },
                Out: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                },
                InOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
                }
            },
            Back: {
                In: function(e) {
                    return e * e * (2.70158 * e - 1.70158)
                },
                Out: function(e) {
                    return --e * e * (2.70158 * e + 1.70158) + 1
                },
                InOut: function(e) {
                    return 1 > (e *= 2) ? .5 * e * e * (3.5949095 * e - 2.5949095) : .5 * ((e -= 2) * e * (3.5949095 * e + 2.5949095) + 2)
                }
            },
            Bounce: {
                In: function(e) {
                    return 1 - i.Easing.Bounce.Out(1 - e)
                },
                Out: function(e) {
                    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                },
                InOut: function(e) {
                    return .5 > e ? .5 * i.Easing.Bounce.In(2 * e) : .5 * i.Easing.Bounce.Out(2 * e - 1) + .5
                }
            }
        }, i.Interpolation = {
            Linear: function(e, t) {
                var n = e.length - 1,
                    r = n * t,
                    o = Math.floor(r),
                    a = i.Interpolation.Utils.Linear;
                return 0 > t ? a(e[0], e[1], r) : 1 < t ? a(e[n], e[n - 1], n - r) : a(e[o], e[o + 1 > n ? n : o + 1], r - o)
            },
            Bezier: function(e, t) {
                for (var n = 0, r = e.length - 1, o = Math.pow, a = i.Interpolation.Utils.Bernstein, s = 0; s <= r; s++) n += o(1 - t, r - s) * o(t, s) * e[s] * a(r, s);
                return n
            },
            CatmullRom: function(e, t) {
                var n = e.length - 1,
                    r = n * t,
                    o = Math.floor(r),
                    a = i.Interpolation.Utils.CatmullRom;
                return e[0] === e[n] ? (0 > t && (o = Math.floor(r = n * (1 + t))), a(e[(o - 1 + n) % n], e[o], e[(o + 1) % n], e[(o + 2) % n], r - o)) : 0 > t ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : 1 < t ? e[n] - (a(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : a(e[o ? o - 1 : 0], e[o], e[n < o + 1 ? n : o + 1], e[n < o + 2 ? n : o + 2], r - o)
            },
            Utils: {
                Linear: function(e, t, i) {
                    return (t - e) * i + e
                },
                Bernstein: function(e, t) {
                    var n = i.Interpolation.Utils.Factorial;
                    return n(e) / n(t) / n(e - t)
                },
                Factorial: function() {
                    var e = [1];
                    return function(t) {
                        var i = 1;
                        if (e[t]) return e[t];
                        for (var n = t; 1 < n; n--) i *= n;
                        return e[t] = i
                    }
                }(),
                CatmullRom: function(e, t, i, n, r) {
                    var o = r * r;
                    return (2 * t - 2 * i + (e = .5 * (i - e)) + (n = .5 * (n - t))) * r * o + (-3 * t + 3 * i - 2 * e - n) * o + e * r + t
                }
            }
        }, e.exports = i
    }(C = {
        exports: {}
    }, C.exports), C.exports);
    r.prototype = Object.assign(Object.create(t.Sprite.prototype), {
        constructor: r,
        setContainer: function(e) {
            if (e instanceof HTMLElement) var t = e;
            else e && e.container && (t = e.container);
            t && this.element && t.appendChild(this.element), this.container = t
        },
        getContainer: function() {
            return this.container
        },
        onClick: function(e) {
            this.element && this.getContainer() && (this.onHoverStart(e), this.lockHoverElement())
        },
        onDismiss: function() {
            this.element && (this.unlockHoverElement(), this.onHoverEnd())
        },
        onHover: function() {},
        onHoverStart: function(e) {
            if (this.getContainer()) {
                var t = this.cursorStyle || (this.mode === E.NORMAL ? "pointer" : "default"),
                    i = this.scaleDownAnimation,
                    n = this.scaleUpAnimation,
                    r = this.element;
                this.isHovering = !0, this.container.style.cursor = t, this.animated && (i.stop(), n.start()), r && 0 <= e.mouseEvent.clientX && 0 <= e.mouseEvent.clientY && (e = r.left, t = r.right, i = r.style, this.mode === E.CARDBOARD || this.mode === E.STEREO ? (i.display = "none", e.style.display = "block", t.style.display = "block", r._width = e.clientWidth, r._height = e.clientHeight) : (i.display = "block", e && (e.style.display = "none"), t && (t.style.display = "none"), r._width = r.clientWidth, r._height = r.clientHeight))
            }
        },
        onHoverEnd: function() {
            if (this.getContainer()) {
                var e = this.scaleDownAnimation,
                    t = this.scaleUpAnimation,
                    i = this.element;
                this.isHovering = !1, this.container.style.cursor = "default", this.animated && (t.stop(), e.start()), i && !this.element.locked && (e = i.left, t = i.right, i.style.display = "none", e && (e.style.display = "none"), t && (t.style.display = "none"), this.unlockHoverElement())
            }
        },
        onDualEyeEffect: function(e) {
            if (this.getContainer()) {
                this.mode = e.mode, e = this.element;
                var t = this.container.clientWidth / 2,
                    i = this.container.clientHeight / 2;
                e && (e.left || e.right || (e.left = e.cloneNode(!0), e.right = e.cloneNode(!0)), this.mode === E.CARDBOARD || this.mode === E.STEREO ? (e.left.style.display = e.style.display, e.right.style.display = e.style.display, e.style.display = "none") : (e.style.display = e.left.style.display, e.left.style.display = "none", e.right.style.display = "none"), this.translateElement(t, i), this.container.appendChild(e.left), this.container.appendChild(e.right))
            }
        },
        translateElement: function(e, t) {
            if (this.element._width && this.element._height && this.getContainer()) {
                var i = this.container,
                    n = this.element,
                    r = n._width / 2,
                    o = n._height / 2,
                    a = void 0 !== n.verticalDelta ? n.verticalDelta : 40,
                    s = e - r,
                    l = t - o - a;
                this.mode !== E.CARDBOARD && this.mode !== E.STEREO || !n.left || !n.right || e === i.clientWidth / 2 && t === i.clientHeight / 2 ? this.setElementStyle("transform", n, "translate(" + s + "px, " + l + "px)") : (s = i.clientWidth / 4 - r + (e - i.clientWidth / 2), l = i.clientHeight / 2 - o - a + (t - i.clientHeight / 2), this.setElementStyle("transform", n.left, "translate(" + s + "px, " + l + "px)"), s += i.clientWidth / 2, this.setElementStyle("transform", n.right, "translate(" + s + "px, " + l + "px)"))
            }
        },
        setElementStyle: function(e, t, i) {
            t = t.style, "transform" === e && (t.webkitTransform = t.msTransform = t.transform = i)
        },
        setText: function(e) {
            this.element && (this.element.textContent = e)
        },
        setCursorHoverStyle: function(e) {
            this.cursorStyle = e
        },
        addHoverText: function(e, t) {
            t = void 0 === t ? 40 : t, this.element || (this.element = document.createElement("div"), this.element.style.display = "none", this.element.style.color = "#fff", this.element.style.top = 0, this.element.style.maxWidth = "50%", this.element.style.maxHeight = "50%", this.element.style.textShadow = "0 0 3px #000000", this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif', this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t), this.setText(e)
        },
        addHoverElement: function(e, t) {
            t = void 0 === t ? 40 : t, this.element || (this.element = e.cloneNode(!0), this.element.style.display = "none", this.element.style.top = 0, this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t)
        },
        removeHoverElement: function() {
            this.element && (this.element.left && (this.container.removeChild(this.element.left), this.element.left = null), this.element.right && (this.container.removeChild(this.element.right), this.element.right = null), this.container.removeChild(this.element), this.element = null)
        },
        lockHoverElement: function() {
            this.element && (this.element.locked = !0)
        },
        unlockHoverElement: function() {
            this.element && (this.element.locked = !1)
        },
        enableRaycast: function(e) {
            this.raycast = void 0 === e || e ? this.originalRaycast : function() {}
        },
        show: function(e) {
            e = void 0 === e ? 0 : e;
            var t = this.hideAnimation,
                i = this.showAnimation,
                n = this.material;
            this.animated ? (t.stop(), i.delay(e).start()) : (this.enableRaycast(!0), n.opacity = 1)
        },
        hide: function(e) {
            e = void 0 === e ? 0 : e;
            var t = this.hideAnimation,
                i = this.showAnimation,
                n = this.material;
            this.animated ? (i.stop(), t.delay(e).start()) : (this.enableRaycast(!1), n.opacity = 0)
        },
        setFocusMethod: function(e) {
            e && (this.HANDLER_FOCUS = e.method)
        },
        focus: function(e, t) {
            this.HANDLER_FOCUS && (this.HANDLER_FOCUS(this.position, e, t), this.onDismiss())
        },
        dispose: function() {
            var e = this.geometry,
                t = this.material,
                i = t.map;
            this.removeHoverElement(), this.parent && this.parent.remove(this), i && (i.dispose(), t.map = null), e && (e.dispose(), this.geometry = null), t && (t.dispose(), this.material = null)
        }
    }), o.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: o,
        addControlBar: function() {
            if (this.container) {
                var e, t, i = this,
                    n = document.createElement("div");
                n.style.width = "100%", n.style.height = "44px", n.style.float = "left", n.style.transform = n.style.webkitTransform = n.style.msTransform = "translateY(-100%)", n.style.background = "-webkit-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-moz-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-o-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-ms-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.transition = this.DEFAULT_TRANSITION, n.style.pointerEvents = "none", n.isHidden = !1, n.toggle = function() {
                    n.isHidden = !n.isHidden, e = n.isHidden ? "translateY(0)" : "translateY(-100%)", t = n.isHidden ? 0 : 1, n.style.transform = n.style.webkitTransform = n.style.msTransform = e, n.style.opacity = t
                };
                var r = this.createDefaultMenu();
                this.mainMenu = this.createMainMenu(r), n.appendChild(this.mainMenu), this.mask = r = this.createMask(), this.container.appendChild(r), n.dispose = function() {
                    i.fullscreenElement && (n.removeChild(i.fullscreenElement), i.fullscreenElement.dispose(), i.fullscreenElement = null), i.settingElement && (n.removeChild(i.settingElement), i.settingElement.dispose(), i.settingElement = null), i.videoElement && (n.removeChild(i.videoElement), i.videoElement.dispose(), i.videoElement = null)
                }, this.container.appendChild(n), this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", (function(e) {
                    e.preventDefault(), e.stopPropagation(), i.mask.hide(), i.settingElement.deactivate()
                }), !1), this.addEventListener("control-bar-toggle", n.toggle), this.barElement = n
            } else console.warn("Widget container not set")
        },
        createDefaultMenu: function() {
            var e = this,
                t = function(t, i) {
                    return function() {
                        e.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: t,
                            data: i
                        })
                    }
                };
            return [{
                title: "Control",
                subMenu: [{
                    title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
                    handler: t("enableControl", _.ORBIT)
                }, {
                    title: "Sensor",
                    handler: t("enableControl", _.DEVICEORIENTATION)
                }]
            }, {
                title: "Mode",
                subMenu: [{
                    title: "Normal",
                    handler: t("disableEffect")
                }, {
                    title: "Cardboard",
                    handler: t("enableEffect", E.CARDBOARD)
                }, {
                    title: "Stereoscopic",
                    handler: t("enableEffect", E.STEREO)
                }]
            }]
        },
        addControlButton: function(e) {
            switch (e) {
                case "fullscreen":
                    this.fullscreenElement = e = this.createFullscreenButton();
                    break;
                case "setting":
                    this.settingElement = e = this.createSettingButton();
                    break;
                case "video":
                    this.videoElement = e = this.createVideoControl();
                    break;
                default:
                    return
            }
            e && this.barElement.appendChild(e)
        },
        createMask: function() {
            var e = document.createElement("div");
            return e.style.position = "absolute", e.style.top = 0, e.style.left = 0, e.style.width = "100%", e.style.height = "100%", e.style.background = "transparent", e.style.display = "none", e.show = function() {
                this.style.display = "block"
            }, e.hide = function() {
                this.style.display = "none"
            }, e
        },
        createSettingButton: function() {
            var e = this,
                t = this.createCustomItem({
                    style: {
                        backgroundImage: 'url("' + M.Setting + '")',
                        webkitTransition: this.DEFAULT_TRANSITION,
                        transition: this.DEFAULT_TRANSITION
                    },
                    onTap: function(t) {
                        t.preventDefault(), t.stopPropagation(), e.mainMenu.toggle(), this.activated ? this.deactivate() : this.activate()
                    }
                });
            return t.activate = function() {
                this.style.transform = "rotate3d(0,0,1,90deg)", this.activated = !0, e.mask.show()
            }, t.deactivate = function() {
                this.style.transform = "rotate3d(0,0,0,0)", this.activated = !1, e.mask.hide(), e.mainMenu && e.mainMenu.visible && e.mainMenu.hide(), e.activeSubMenu && e.activeSubMenu.visible && e.activeSubMenu.hide(), e.mainMenu && e.mainMenu._width && (e.mainMenu.changeSize(e.mainMenu._width), e.mainMenu.unslideAll())
            }, t.activated = !1, t
        },
        createFullscreenButton: function() {
            function e() {
                n && (i = !i, o.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'), t.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onWindowResize"
                }), n = !0
            }
            var t = this,
                i = !1,
                n = !0,
                r = this.container;
            if (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) {
                document.addEventListener("fullscreenchange", e, !1), document.addEventListener("webkitfullscreenchange", e, !1), document.addEventListener("mozfullscreenchange", e, !1), document.addEventListener("MSFullscreenChange", e, !1);
                var o = this.createCustomItem({
                    style: {
                        backgroundImage: 'url("' + M.FullscreenEnter + '")'
                    },
                    onTap: function(e) {
                        e.preventDefault(), e.stopPropagation(), n = !1, i ? (document.exitFullscreen && document.exitFullscreen(), document.msExitFullscreen && document.msExitFullscreen(), document.mozCancelFullScreen && document.mozCancelFullScreen(), document.webkitExitFullscreen && document.webkitExitFullscreen(), i = !1) : (r.requestFullscreen && r.requestFullscreen(), r.msRequestFullscreen && r.msRequestFullscreen(), r.mozRequestFullScreen && r.mozRequestFullScreen(), r.webkitRequestFullscreen && r.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT), i = !0), this.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'
                    }
                });
                if (!document.querySelector("panolens-style-addon")) {
                    var a = document.createElement("style");
                    a.id = "panolens-style-addon", a.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }", document.body.appendChild(a)
                }
                return o
            }
        },
        createVideoControl: function() {
            var e = document.createElement("span");
            return e.style.display = "none", e.show = function() {
                e.style.display = ""
            }, e.hide = function() {
                e.style.display = "none", e.controlButton.paused = !0, e.controlButton.update()
            }, e.controlButton = this.createVideoControlButton(), e.seekBar = this.createVideoControlSeekbar(), e.appendChild(e.controlButton), e.appendChild(e.seekBar), e.dispose = function() {
                e.removeChild(e.controlButton), e.removeChild(e.seekBar), e.controlButton.dispose(), e.controlButton = null, e.seekBar.dispose(), e.seekBar = null
            }, this.addEventListener("video-control-show", e.show), this.addEventListener("video-control-hide", e.hide), e
        },
        createVideoControlButton: function() {
            var e = this,
                t = this.createCustomItem({
                    style: {
                        float: "left",
                        backgroundImage: 'url("' + M.VideoPlay + '")'
                    },
                    onTap: function(i) {
                        i.preventDefault(), i.stopPropagation(), e.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "toggleVideoPlay",
                            data: !this.paused
                        }), this.paused = !this.paused, t.update()
                    }
                });
            return t.paused = !0, t.update = function(e) {
                this.paused = void 0 !== e ? e : this.paused, this.style.backgroundImage = 'url("' + (this.paused ? M.VideoPlay : M.VideoPause) + '")'
            }, t
        },
        createVideoControlSeekbar: function() {
            function e(e) {
                e.stopPropagation(), l = !0, r = e.clientX || e.changedTouches && e.changedTouches[0].clientX, o = parseInt(c.style.width) / 100, s.container.addEventListener("mousemove", t, {
                    passive: !0
                }), s.container.addEventListener("mouseup", i, {
                    passive: !0
                }), s.container.addEventListener("touchmove", t, {
                    passive: !0
                }), s.container.addEventListener("touchend", i, {
                    passive: !0
                })
            }

            function t(e) {
                l && (a = ((e.clientX || e.changedTouches && e.changedTouches[0].clientX) - r) / u.clientWidth, a = 1 < (a = o + a) ? 1 : 0 > a ? 0 : a, u.setProgress(a), s.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "setVideoCurrentTime",
                    data: a
                }))
            }

            function i(e) {
                e.stopPropagation(), l = !1, n()
            }

            function n() {
                s.container.removeEventListener("mousemove", t, !1), s.container.removeEventListener("mouseup", i, !1), s.container.removeEventListener("touchmove", t, !1), s.container.removeEventListener("touchend", i, !1)
            }
            var r, o, a, s = this,
                l = !1,
                c = document.createElement("div");
            c.style.width = "0%", c.style.height = "100%", c.style.backgroundColor = "#fff";
            var h = document.createElement("div");
            h.style.float = "right", h.style.width = "14px", h.style.height = "14px", h.style.transform = "translate(7px, -5px)", h.style.borderRadius = "50%", h.style.backgroundColor = "#ddd", h.addEventListener("mousedown", e, {
                passive: !0
            }), h.addEventListener("touchstart", e, {
                passive: !0
            }), c.appendChild(h);
            var u = this.createCustomItem({
                style: {
                    float: "left",
                    width: "30%",
                    height: "4px",
                    marginTop: "20px",
                    backgroundColor: "rgba(188,188,188,0.8)"
                },
                onTap: function(e) {
                    if (e.preventDefault(), e.stopPropagation(), e.target !== h) {
                        var t = e.changedTouches && 0 < e.changedTouches.length ? (e.changedTouches[0].pageX - e.target.getBoundingClientRect().left) / this.clientWidth : e.offsetX / this.clientWidth;
                        s.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "setVideoCurrentTime",
                            data: t
                        }), u.setProgress(e.offsetX / this.clientWidth)
                    }
                },
                onDispose: function() {
                    n(), h = c = null
                }
            });
            return u.appendChild(c), u.setProgress = function(e) {
                c.style.width = 100 * e + "%"
            }, this.addEventListener("video-update", (function(e) {
                u.setProgress(e.percentage)
            })), u.progressElement = c, u.progressElementControl = h, u
        },
        createMenuItem: function(e) {
            var t = this,
                i = document.createElement("a");
            return i.textContent = e, i.style.display = "block", i.style.padding = "10px", i.style.textDecoration = "none", i.style.cursor = "pointer", i.style.pointerEvents = "auto", i.style.transition = this.DEFAULT_TRANSITION, i.slide = function(e) {
                this.style.transform = "translateX(" + (e ? "" : "-") + "100%)"
            }, i.unslide = function() {
                this.style.transform = "translateX(0)"
            }, i.setIcon = function(e) {
                this.icon && (this.icon.style.backgroundImage = "url(" + e + ")")
            }, i.setSelectionTitle = function(e) {
                this.selection && (this.selection.textContent = e)
            }, i.addSelection = function(e) {
                var t = document.createElement("span");
                return t.style.fontSize = "13px", t.style.fontWeight = "300", t.style.float = "right", this.selection = t, this.setSelectionTitle(e), this.appendChild(t), this
            }, i.addIcon = function(e, t, i) {
                e = void 0 === e ? M.ChevronRight : e, t = void 0 !== t && t, i = void 0 !== i && i;
                var n = document.createElement("span");
                return n.style.float = t ? "left" : "right", n.style.width = "17px", n.style.height = "17px", n.style["margin" + (t ? "Right" : "Left")] = "12px", n.style.backgroundSize = "cover", i && (n.style.transform = "rotateZ(180deg)"), this.icon = n, this.setIcon(e), this.appendChild(n), this
            }, i.addSubMenu = function(e, i) {
                return this.subMenu = t.createSubMenu(e, i), this
            }, i.addEventListener("mouseenter", (function() {
                this.style.backgroundColor = "#e0e0e0"
            }), !1), i.addEventListener("mouseleave", (function() {
                this.style.backgroundColor = "#fafafa"
            }), !1), i
        },
        createMenuItemHeader: function(e) {
            return (e = this.createMenuItem(e)).style.borderBottom = "1px solid #333", e.style.paddingBottom = "15px", e
        },
        createMainMenu: function(e) {
            function t(e) {
                e.preventDefault(), e.stopPropagation();
                var t = i.mainMenu,
                    n = this.subMenu;
                t.hide(), t.slideAll(), t.parentElement.appendChild(n), i.activeMainItem = this, i.activeSubMenu = n, window.requestAnimationFrame((function() {
                    t.changeSize(n.clientWidth), n.show(), n.unslideAll()
                }))
            }
            var i = this,
                n = this.createMenu();
            n._width = 200, n.changeSize(n._width);
            for (var r = 0; r < e.length; r++) {
                var o = n.addItem(e[r].title);
                o.style.paddingLeft = "20px", o.addIcon().addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", t, !1), e[r].subMenu && 0 < e[r].subMenu.length && o.addSelection(e[r].subMenu[0].title).addSubMenu(e[r].title, e[r].subMenu)
            }
            return n
        },
        createSubMenu: function(e, t) {
            function i(e) {
                e.preventDefault(), e.stopPropagation(), (n = r.mainMenu).changeSize(n._width), n.unslideAll(), n.show(), o.slideAll(!0), o.hide(), "header" !== this.type && (o.setActiveItem(this), r.activeMainItem.setSelectionTitle(this.textContent), this.handler && this.handler())
            }
            var n, r = this,
                o = this.createMenu();
            for (o.items = t, o.activeItem = null, o.addHeader(e).addIcon(void 0, !0, !0).addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), e = 0; e < t.length; e++) {
                var a = o.addItem(t[e].title);
                a.style.fontWeight = 300, a.handler = t[e].handler, a.addIcon(" ", !0), a.addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), o.activeItem || o.setActiveItem(a)
            }
            return o.slideAll(!0), o
        },
        createMenu: function() {
            var e = this,
                t = document.createElement("span"),
                i = t.style;
            return i.padding = "5px 0", i.position = "fixed", i.bottom = "100%", i.right = "14px", i.backgroundColor = "#fafafa", i.fontFamily = "Helvetica Neue", i.fontSize = "14px", i.visibility = "hidden", i.opacity = 0, i.boxShadow = "0 0 12pt rgba(0,0,0,0.25)", i.borderRadius = "2px", i.overflow = "hidden", i.willChange = "width, height, opacity", i.pointerEvents = "auto", i.transition = this.DEFAULT_TRANSITION, t.visible = !1, t.changeSize = function(e, t) {
                e && (this.style.width = e + "px"), t && (this.style.height = t + "px")
            }, t.show = function() {
                this.style.opacity = 1, this.style.visibility = "visible", this.visible = !0
            }, t.hide = function() {
                this.style.opacity = 0, this.style.visibility = "hidden", this.visible = !1
            }, t.toggle = function() {
                this.visible ? this.hide() : this.show()
            }, t.slideAll = function(e) {
                for (var i = 0; i < t.children.length; i++) t.children[i].slide && t.children[i].slide(e)
            }, t.unslideAll = function() {
                for (var e = 0; e < t.children.length; e++) t.children[e].unslide && t.children[e].unslide()
            }, t.addHeader = function(t) {
                return (t = e.createMenuItemHeader(t)).type = "header", this.appendChild(t), t
            }, t.addItem = function(t) {
                return (t = e.createMenuItem(t)).type = "item", this.appendChild(t), t
            }, t.setActiveItem = function(e) {
                this.activeItem && this.activeItem.setIcon(" "), e.setIcon(M.Check), this.activeItem = e
            }, t.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), t
        },
        createCustomItem: function(e) {
            var t = this,
                i = (e = void 0 === e ? {} : e).element || document.createElement("span"),
                n = e.onDispose;
            return i.style.cursor = "pointer", i.style.float = "right", i.style.width = "44px", i.style.height = "100%", i.style.backgroundSize = "60%", i.style.backgroundRepeat = "no-repeat", i.style.backgroundPosition = "center", i.style.webkitUserSelect = i.style.MozUserSelect = i.style.userSelect = "none", i.style.position = "relative", i.style.pointerEvents = "auto", i.addEventListener(t.TOUCH_ENABLED ? "touchstart" : "mouseenter", (function() {
                i.style.filter = i.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))"
            }), {
                passive: !0
            }), i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "mouseleave", (function() {
                i.style.filter = i.style.webkitFilter = ""
            }), {
                passive: !0
            }), this.mergeStyleOptions(i, e.style), e.onTap && i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), i.dispose = function() {
                i.removeEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), n && e.onDispose()
            }, i
        },
        mergeStyleOptions: function(e, t) {
            for (var i in t = void 0 === t ? {} : t) t.hasOwnProperty(i) && (e.style[i] = t[i]);
            return e
        },
        dispose: function() {
            this.barElement && (this.container.removeChild(this.barElement), this.barElement.dispose(), this.barElement = null)
        }
    }), a.prototype = Object.assign(Object.create(t.Mesh.prototype), {
        constructor: a,
        add: function(e) {
            var i;
            if (1 < arguments.length) {
                for (i = 0; i < arguments.length; i++) this.add(arguments[i]);
                return this
            }
            if (e instanceof r) {
                if (i = e, e.dispatchEvent) {
                    var n = this.container;
                    n && e.dispatchEvent({
                        type: "panolens-container",
                        container: n
                    }), e.dispatchEvent({
                        type: "panolens-infospot-focus",
                        method: function(e, t, i) {
                            this.dispatchEvent({
                                type: "panolens-viewer-handler",
                                method: "tweenControlCenter",
                                data: [e, t, i]
                            })
                        }.bind(this)
                    })
                }
            } else(i = new t.Object3D).scale.x = -1, i.scalePlaceHolder = !0, i.add(e);
            t.Object3D.prototype.add.call(this, i)
        },
        load: function() {
            this.onLoad()
        },
        onClick: function(e) {
            e.intersects && 0 === e.intersects.length && this.traverse((function(e) {
                e.dispatchEvent({
                    type: "dismiss"
                })
            }))
        },
        setContainer: function(e) {
            if (e instanceof HTMLElement) var t = e;
            else e && e.container && (t = e.container);
            t && (this.children.forEach((function(e) {
                e instanceof r && e.dispatchEvent && e.dispatchEvent({
                    type: "panolens-container",
                    container: t
                })
            })), this.container = t)
        },
        onLoad: function() {
            this.loaded = !0, this.dispatchEvent({
                type: "load"
            })
        },
        onProgress: function(e) {
            this.dispatchEvent({
                type: "progress",
                progress: e
            })
        },
        onError: function() {
            this.dispatchEvent({
                type: "error"
            })
        },
        getZoomLevel: function() {
            return 800 >= window.innerWidth ? this.ImageQualityFair : 800 < window.innerWidth && 1280 >= window.innerWidth ? this.ImageQualityMedium : 1280 < window.innerWidth && 1920 >= window.innerWidth ? this.ImageQualityHigh : 1920 < window.innerWidth ? this.ImageQualitySuperHigh : this.ImageQualityLow
        },
        updateTexture: function(e) {
            this.material.map = e, this.material.needsUpdate = !0
        },
        toggleInfospotVisibility: function(e, t) {
            t = void 0 !== t ? t : 0;
            var i = void 0 !== e ? e : !this.isInfospotVisible;
            this.traverse((function(e) {
                e instanceof r && (i ? e.show(t) : e.hide(t))
            })), this.isInfospotVisible = i, this.infospotAnimation.onComplete(function() {
                this.dispatchEvent({
                    type: "infospot-animation-complete",
                    visible: i
                })
            }.bind(this)).delay(t).start()
        },
        setLinkingImage: function(e, t) {
            this.linkingImageURL = e, this.linkingImageScale = t
        },
        link: function(e, t, i, n) {
            this.visible = !0, t ? ((n = new r(i = void 0 !== i ? i : void 0 !== e.linkingImageScale ? e.linkingImageScale : 300, n = n || (e.linkingImageURL ? e.linkingImageURL : M.Arrow))).position.copy(t), n.toPanorama = e, n.addEventListener("click", function() {
                this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "setPanorama",
                    data: e
                })
            }.bind(this)), this.linkedSpots.push(n), this.add(n), this.visible = !1) : console.warn("Please specify infospot position for linking")
        },
        reset: function() {
            this.children.length = 0
        },
        setupTransitions: function() {
            this.fadeInAnimation = new L.Tween(this.material).easing(L.Easing.Quartic.Out).onStart(function() {
                this.visible = !0, this.dispatchEvent({
                    type: "enter-fade-start"
                })
            }.bind(this)), this.fadeOutAnimation = new L.Tween(this.material).easing(L.Easing.Quartic.Out).onComplete(function() {
                this.visible = !1, this.dispatchEvent({
                    type: "leave-complete"
                })
            }.bind(this)), this.enterTransition = new L.Tween(this).easing(L.Easing.Quartic.Out).onComplete(function() {
                this.dispatchEvent({
                    type: "enter-complete"
                })
            }.bind(this)).start(), this.leaveTransition = new L.Tween(this).easing(L.Easing.Quartic.Out)
        },
        onFadeAnimationUpdate: function() {
            var e = this.material.opacity,
                t = this.material.uniforms;
            t && t.opacity && (t.opacity.value = e)
        },
        fadeIn: function(e) {
            e = 0 <= e ? e : this.animationDuration, this.fadeOutAnimation.stop(), this.fadeInAnimation.to({
                opacity: 1
            }, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function() {
                this.toggleInfospotVisibility(!0, e / 2), this.dispatchEvent({
                    type: "enter-fade-complete"
                })
            }.bind(this)).start()
        },
        fadeOut: function(e) {
            e = 0 <= e ? e : this.animationDuration, this.fadeInAnimation.stop(), this.fadeOutAnimation.to({
                opacity: 0
            }, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).start()
        },
        onEnter: function() {
            var e = this.animationDuration;
            this.leaveTransition.stop(), this.enterTransition.to({}, e).onStart(function() {
                this.dispatchEvent({
                    type: "enter-start"
                }), this.loaded ? this.fadeIn(e) : this.load()
            }.bind(this)).start(), this.dispatchEvent({
                type: "enter"
            }), this.children.forEach((function(e) {
                e.dispatchEvent({
                    type: "panorama-enter"
                })
            })), this.active = !0
        },
        onLeave: function() {
            var e = this.animationDuration;
            this.enterTransition.stop(), this.leaveTransition.to({}, e).onStart(function() {
                this.dispatchEvent({
                    type: "leave-start"
                }), this.fadeOut(e), this.toggleInfospotVisibility(!1)
            }.bind(this)).start(), this.dispatchEvent({
                type: "leave"
            }), this.children.forEach((function(e) {
                e.dispatchEvent({
                    type: "panorama-leave"
                })
            })), this.active = !1
        },
        dispose: function() {
            this.infospotAnimation.stop(), this.fadeInAnimation.stop(), this.fadeOutAnimation.stop(), this.enterTransition.stop(), this.leaveTransition.stop(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onPanoramaDispose",
                    data: this
                }),
                function e(t) {
                    for (var i = t.geometry, n = t.material, o = t.children.length - 1; 0 <= o; o--) e(t.children[o]), t.remove(t.children[o]);
                    t instanceof r && t.dispose(), i && (i.dispose(), t.geometry = null), n && (n.dispose(), t.material = null)
                }(this), this.parent && this.parent.remove(this)
        }
    }), s.prototype = Object.assign(Object.create(a.prototype), {
        constructor: s,
        load: function(e) {
            (e = e || this.src) ? "string" == typeof e ? S.load(e, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) : e instanceof HTMLImageElement && this.onLoad(new t.Texture(e)): console.warn("Image source undefined")
        },
        onLoad: function(e) {
            e.minFilter = e.magFilter = t.LinearFilter, e.needsUpdate = !0, this.updateTexture(e), window.requestAnimationFrame(a.prototype.onLoad.bind(this))
        },
        reset: function() {
            a.prototype.reset.call(this)
        },
        dispose: function() {
            var e = this.material.map;
            t.Cache.remove(this.src), e && e.dispose(), a.prototype.dispose.call(this)
        }
    }), l.prototype = Object.assign(Object.create(a.prototype), {
        constructor: l
    }), c.prototype = Object.assign(Object.create(a.prototype), {
        constructor: c,
        load: function() {
            A.load(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this))
        },
        onLoad: function(e) {
            this.material.uniforms.tCube.value = e, a.prototype.onLoad.call(this)
        },
        dispose: function() {
            var e = this.material.uniforms.tCube.value;
            this.images.forEach((function(e) {
                t.Cache.remove(e)
            })), e instanceof t.CubeTexture && e.dispose(), a.prototype.dispose.call(this)
        }
    }), h.prototype = Object.assign(Object.create(c.prototype), {
        constructor: h
    }), u.prototype = Object.assign(Object.create(a.prototype), {
        constructor: u,
        isMobile: function() {
            var e = !1,
                t = window.navigator.userAgent || window.navigator.vendor || window.opera;
            return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e
        },
        load: function() {
            var e = this.options,
                t = e.muted,
                i = e.loop,
                n = e.autoplay,
                r = e.playsinline;
            e = e.crossOrigin;
            var o = this.videoElement,
                a = this.material,
                s = this.onProgress.bind(this),
                l = this.onLoad.bind(this);
            o.loop = i, o.autoplay = n, o.playsinline = r, o.crossOrigin = e, o.muted = t, r && (o.setAttribute("playsinline", ""), o.setAttribute("webkit-playsinline", "")), r = function() {
                this.setVideoTexture(o), n && this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !1
                }), this.isMobile() && (o.pause(), n && t ? this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !1
                }) : this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !0
                })), window.requestAnimationFrame((function() {
                    a.map.needsUpdate = !0, s({
                        loaded: 1,
                        total: 1
                    }), l()
                }))
            }, 2 < o.readyState ? r.call(this) : (0 === o.querySelectorAll("source").length && ((e = document.createElement("source")).src = this.src, o.appendChild(e)), o.load()), o.addEventListener("loadeddata", r.bind(this)), o.addEventListener("timeupdate", function() {
                this.videoProgress = 0 <= o.duration ? o.currentTime / o.duration : 0, this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onVideoUpdate",
                    data: this.videoProgress
                })
            }.bind(this)), o.addEventListener("ended", function() {
                i || (this.resetVideo(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !0
                }))
            }.bind(this), !1)
        },
        setVideoTexture: function(e) {
            e && ((e = new t.VideoTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.format = t.RGBFormat, this.updateTexture(e))
        },
        reset: function() {
            this.videoElement = void 0, a.prototype.reset.call(this)
        },
        isVideoPaused: function() {
            return this.videoElement.paused
        },
        toggleVideo: function() {
            var e = this.videoElement;
            e && e[e.paused ? "play" : "pause"]()
        },
        setVideoCurrentTime: function(e) {
            e = e.percentage;
            var t = this.videoElement;
            t && !Number.isNaN(e) && 1 !== e && (t.currentTime = t.duration * e, this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "onVideoUpdate",
                data: e
            }))
        },
        playVideo: function() {
            var e = this.videoElement,
                t = this.playVideo.bind(this),
                i = this.dispatchEvent.bind(this);
            e && e.paused && e.play().then((function() {
                i({
                    type: "play"
                })
            })).catch((function(e) {
                window.requestAnimationFrame(t), i({
                    type: "play-error",
                    error: e
                })
            }))
        },
        pauseVideo: function() {
            var e = this.videoElement;
            e && !e.paused && e.pause(), this.dispatchEvent({
                type: "pause"
            })
        },
        resumeVideoProgress: function() {
            var e = this.videoElement;
            4 <= e.readyState && e.autoplay && !this.isMobile() ? (this.playVideo(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "updateVideoPlayButton",
                data: !1
            })) : (this.pauseVideo(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "updateVideoPlayButton",
                data: !0
            })), this.setVideoCurrentTime({
                percentage: this.videoProgress
            })
        },
        resetVideo: function() {
            this.videoElement && this.setVideoCurrentTime({
                percentage: 0
            })
        },
        isVideoMuted: function() {
            return this.videoElement.muted
        },
        muteVideo: function() {
            var e = this.videoElement;
            e && !e.muted && (e.muted = !0), this.dispatchEvent({
                type: "volumechange"
            })
        },
        unmuteVideo: function() {
            var e = this.videoElement;
            e && this.isVideoMuted() && (e.muted = !1), this.dispatchEvent({
                type: "volumechange"
            })
        },
        getVideoElement: function() {
            return this.videoElement
        },
        dispose: function() {
            var e = this.material.map;
            this.pauseVideo(), this.removeEventListener("leave", this.pauseVideo.bind(this)), this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.removeEventListener("video-toggle", this.toggleVideo.bind(this)), this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this)), e && e.dispose(), a.prototype.dispose.call(this)
        }
    }), Object.assign(d.prototype, {
        constructor: d,
        setProgress: function(e, t) {
            this.onProgress && this.onProgress({
                loaded: e,
                total: t
            })
        },
        adaptTextureToZoom: function() {
            var e = this.widths[this._zoom],
                t = this.heights[this._zoom],
                i = this.maxW,
                n = this.maxH;
            this._wc = Math.ceil(e / i), this._hc = Math.ceil(t / n);
            for (var r = 0; r < this._hc; r++)
                for (var o = 0; o < this._wc; o++) {
                    var a = document.createElement("canvas");
                    a.width = o < this._wc - 1 ? i : e - i * o, a.height = r < this._hc - 1 ? n : t - n * r, this._canvas.push(a), this._ctx.push(a.getContext("2d"))
                }
        },
        composeFromTile: function(e, t, i) {
            var n = this.maxW,
                r = this.maxH;
            e *= 512, t *= 512;
            var o = Math.floor(e / n),
                a = Math.floor(t / r);
            this._ctx[a * this._wc + o].drawImage(i, 0, 0, i.width, i.height, e - o * n, t - a * r, 512, 512), this.progress()
        },
        progress: function() {
            this._count++, this.setProgress(this._count, this._total), this._count === this._total && (this.canvas = this._canvas, this.panoId = this._panoId, this.zoom = this._zoom, this.onPanoramaLoad) && this.onPanoramaLoad(this._canvas[0])
        },
        composePanorama: function() {
            this.setProgress(0, 1);
            var e = this.levelsW[this._zoom],
                t = this.levelsH[this._zoom],
                i = this;
            this._count = 0, this._total = e * t;
            for (var n = this._parameters.useWebGL, r = 0; r < t; r++)
                for (var o = {}, a = 0; a < e; o = {
                        $jscomp$loop$prop$url$1: o.$jscomp$loop$prop$url$1
                    }, a++) o.$jscomp$loop$prop$url$1 = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + a + "&y=" + r + "&panoid=" + this._panoId + "&nbt&fover=2",
                    function(e) {
                        return function(t, r) {
                            if (n) var o = S.load(e.$jscomp$loop$prop$url$1, null, (function() {
                                i.composeFromTile(t, r, o)
                            }));
                            else {
                                var a = new Image;
                                a.addEventListener("load", (function() {
                                    i.composeFromTile(t, r, this)
                                })), a.crossOrigin = "", a.src = e.$jscomp$loop$prop$url$1
                            }
                        }
                    }(o)(a, r)
        },
        load: function(e) {
            this.loadPano(e)
        },
        loadPano: function(e) {
            var t = this;
            this._panoClient.getPanoramaById(e, (function(e, i) {
                i === google.maps.StreetViewStatus.OK && (t.result = e, t.copyright = e.copyright, t._panoId = e.location.pano, t.composePanorama())
            }))
        },
        setZoom: function(e) {
            this._zoom = e, this.adaptTextureToZoom()
        }
    }), p.prototype = Object.assign(Object.create(s.prototype), {
        constructor: p,
        load: function(e) {
            this.loadRequested = !0, e = e || this.panoId || {}, this.gsvLoader && this.loadGSVLoader(e)
        },
        setupGoogleMapAPI: function(e) {
            var t = document.createElement("script");
            t.src = "https://maps.googleapis.com/maps/api/js?", t.src += e ? "key=" + e : "", t.onreadystatechange = this.setGSVLoader.bind(this), t.onload = this.setGSVLoader.bind(this), document.querySelector("head").appendChild(t)
        },
        setGSVLoader: function() {
            this.gsvLoader = new d, this.loadRequested && this.load()
        },
        getGSVLoader: function() {
            return this.gsvLoader
        },
        loadGSVLoader: function(e) {
            this.loadRequested = !1, this.gsvLoader.onProgress = this.onProgress.bind(this), this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this), this.gsvLoader.setZoom(this.getZoomLevel()), this.gsvLoader.load(e), this.gsvLoader.loaded = !0
        },
        onLoad: function(e) {
            s.prototype.onLoad.call(this, new t.Texture(e))
        },
        reset: function() {
            this.gsvLoader = void 0, s.prototype.reset.call(this)
        }
    });
    var D = {
        uniforms: {
            tDiffuse: {
                value: new t.Texture
            },
            resolution: {
                value: 1
            },
            transform: {
                value: new t.Matrix4
            },
            zoom: {
                value: 1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform float resolution;\nuniform mat4 transform;\nuniform float zoom;\nuniform float opacity;\nvarying vec2 vUv;\nconst float PI = 3.141592653589793;\nvoid main(){\nvec2 position = -1.0 +  2.0 * vUv;\nposition *= vec2( zoom * resolution, zoom * 0.5 );\nfloat x2y2 = position.x * position.x + position.y * position.y;\nvec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );\nsphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );\nvec2 sampleUV = vec2(\n(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,\n(asin(sphere_pnt.z) / PI + 0.5)\n);\ngl_FragColor = texture2D( tDiffuse, sampleUV );\ngl_FragColor.a *= opacity;\n}"
    };
    f.prototype = Object.assign(Object.create(s.prototype), {
        constructor: f,
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            e instanceof r && (e.material.depthTest = !1), s.prototype.add.call(this, e)
        },
        createGeometry: function(e, i) {
            return new t.PlaneBufferGeometry(e, e * i)
        },
        createMaterial: function(e) {
            var i = Object.assign({}, D),
                n = i.uniforms;
            return n.zoom.value = e, n.opacity.value = 0, new t.ShaderMaterial({
                uniforms: n,
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: t.BackSide,
                transparent: !0
            })
        },
        registerMouseEvents: function() {
            this.container.addEventListener("mousedown", this.onMouseDown.bind(this), {
                passive: !0
            }), this.container.addEventListener("mousemove", this.onMouseMove.bind(this), {
                passive: !0
            }), this.container.addEventListener("mouseup", this.onMouseUp.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchstart", this.onMouseDown.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchmove", this.onMouseMove.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchend", this.onMouseUp.bind(this), {
                passive: !0
            }), this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), {
                passive: !1
            }), this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), {
                passive: !1
            }), this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), {
                passive: !0
            })
        },
        unregisterMouseEvents: function() {
            this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), !1), this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), !1), this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), !1), this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("touchend", this.onMouseUp.bind(this), !1), this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), !1)
        },
        onMouseDown: function(e) {
            switch (e.touches && e.touches.length || 1) {
                case 1:
                    var t = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
                    e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.dragging = !0, this.userMouse.set(t, e);
                    break;
                case 2:
                    t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.userMouse.pinchDistance = Math.sqrt(t * t + e * e)
            }
            this.onUpdateCallback()
        },
        onMouseMove: function(e) {
            switch (e.touches && e.touches.length || 1) {
                case 1:
                    var i = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
                    e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY;
                    var n = .4 * t.Math.degToRad(i - this.userMouse.x),
                        r = .4 * t.Math.degToRad(e - this.userMouse.y);
                    this.dragging && (this.quatA.setFromAxisAngle(this.vectorY, n), this.quatB.setFromAxisAngle(this.vectorX, r), this.quatCur.multiply(this.quatA).multiply(this.quatB), this.userMouse.set(i, e));
                    break;
                case 2:
                    i = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.addZoomDelta(this.userMouse.pinchDistance - Math.sqrt(i * i + e * e))
            }
        },
        onMouseUp: function() {
            this.dragging = !1
        },
        onMouseWheel: function(e) {
            e.preventDefault(), e.stopPropagation();
            var t = 0;
            void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), this.addZoomDelta(t), this.onUpdateCallback()
        },
        addZoomDelta: function(e) {
            var t = this.material.uniforms,
                i = .1 * this.size,
                n = 10 * this.size;
            t.zoom.value += e, t.zoom.value <= i ? t.zoom.value = i : t.zoom.value >= n && (t.zoom.value = n)
        },
        onUpdateCallback: function() {
            this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this)), this.quatSlerp.slerp(this.quatCur, .1), this.material && this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp), !this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS && window.cancelAnimationFrame(this.frameId)
        },
        reset: function() {
            this.quatCur.set(0, 0, 0, 1), this.quatSlerp.set(0, 0, 0, 1), this.onUpdateCallback()
        },
        onLoad: function(e) {
            this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight, this.registerMouseEvents(), this.onUpdateCallback(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "disableControl"
            }), s.prototype.onLoad.call(this, e)
        },
        onLeave: function() {
            this.unregisterMouseEvents(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "enableControl",
                data: _.ORBIT
            }), window.cancelAnimationFrame(this.frameId), s.prototype.onLeave.call(this)
        },
        onWindowResize: function() {
            this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight
        },
        onContextMenu: function() {
            this.dragging = !1
        },
        dispose: function() {
            this.unregisterMouseEvents(), s.prototype.dispose.call(this)
        }
    }), m.prototype = Object.assign(Object.create(f.prototype), {
        constructor: m,
        onLoad: function(e) {
            this.updateTexture(e), f.prototype.onLoad.call(this, e)
        },
        updateTexture: function(e) {
            e.minFilter = e.magFilter = t.LinearFilter, this.material.uniforms.tDiffuse.value = e
        },
        dispose: function() {
            var e = this.material.uniforms.tDiffuse;
            e && e.value && e.value.dispose(), f.prototype.dispose.call(this)
        }
    }), g.prototype = Object.assign(Object.create(a.prototype), {
        constructor: g,
        onPanolensContainer: function(e) {
            this.media.setContainer(e.container)
        },
        onPanolensScene: function(e) {
            this.media.setScene(e.scene)
        },
        start: function() {
            return this.media.start()
        },
        stop: function() {
            this.media.stop()
        }
    }), v.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: v
    }), y.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: y
    });
    var P = function(e) {
        var i = new t.StereoCamera;
        i.aspect = .5;
        var n = new t.Vector2;
        this.setEyeSeparation = function(e) {
            i.eyeSep = e
        }, this.setSize = function(t, i) {
            e.setSize(t, i)
        }, this.render = function(t, r) {
            t.updateMatrixWorld(), null === r.parent && r.updateMatrixWorld(), i.update(r), e.getSize(n), e.autoClear && e.clear(), e.setScissorTest(!0), e.setScissor(0, 0, n.width / 2, n.height), e.setViewport(0, 0, n.width / 2, n.height), e.render(t, i.cameraL), e.setScissor(n.width / 2, 0, n.width / 2, n.height), e.setViewport(n.width / 2, 0, n.width / 2, n.height), e.render(t, i.cameraR), e.setScissorTest(!1)
        }
    };
    x.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: x,
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            this.scene.add(e), e.addEventListener && e.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), e instanceof a && e.dispatchEvent && e.dispatchEvent({
                type: "panolens-container",
                container: this.container
            }), e instanceof g && e.dispatchEvent({
                type: "panolens-scene",
                scene: this.scene
            }), "panorama" === e.type && (this.addPanoramaEventListener(e), this.panorama || this.setPanorama(e))
        },
        remove: function(e) {
            e.removeEventListener && e.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), this.scene.remove(e)
        },
        addDefaultControlBar: function(e) {
            if (this.widget) console.warn("Default control bar exists");
            else {
                var t = new o(this.container);
                t.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), t.addControlBar(), e.forEach((function(e) {
                    t.addControlButton(e)
                })), this.widget = t
            }
        },
        setPanorama: function(e) {
            var t = this.panorama;
            if ("panorama" === e.type && t !== e) {
                this.hideInfospot();
                var i = function() {
                    t && t.onLeave(), e.removeEventListener("enter-fade-start", i)
                };
                e.addEventListener("enter-fade-start", i), (this.panorama = e).onEnter()
            }
        },
        eventHandler: function(e) {
            e.method && this[e.method] && this[e.method](e.data)
        },
        dispatchEventToChildren: function(e) {
            this.scene.traverse((function(t) {
                t.dispatchEvent && t.dispatchEvent(e)
            }))
        },
        activateWidgetItem: function(e, t) {
            var i = this.widget.mainMenu,
                n = i.children[0];
            if (i = i.children[1], void 0 !== e) {
                switch (e) {
                    case 0:
                    default:
                        e = n.subMenu.children[1];
                        break;
                    case 1:
                        e = n.subMenu.children[2]
                }
                n.subMenu.setActiveItem(e), n.setSelectionTitle(e.textContent)
            }
            if (void 0 !== t) {
                switch (t) {
                    case E.CARDBOARD:
                        e = i.subMenu.children[2];
                        break;
                    case E.STEREO:
                        e = i.subMenu.children[3];
                        break;
                    default:
                        e = i.subMenu.children[1]
                }
                i.subMenu.setActiveItem(e), i.setSelectionTitle(e.textContent)
            }
        },
        enableEffect: function(e) {
            if (this.mode !== e)
                if (e === E.NORMAL) this.disableEffect();
                else {
                    this.mode = e;
                    var t = this.camera.fov;
                    switch (e) {
                        case E.CARDBOARD:
                            this.effect = this.CardboardEffect, this.enableReticleControl();
                            break;
                        case E.STEREO:
                            this.effect = this.StereoEffect, this.enableReticleControl();
                            break;
                        default:
                            this.effect = null, this.disableReticleControl()
                    }
                    this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                        type: "panolens-dual-eye-effect",
                        mode: this.mode
                    }), this.camera.fov = t + .01, this.effect.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.camera.fov = t, this.dispatchEvent({
                        type: "mode-change",
                        mode: this.mode
                    })
                }
        },
        disableEffect: function() {
            this.mode !== E.NORMAL && (this.mode = E.NORMAL, this.disableReticleControl(), this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                type: "panolens-dual-eye-effect",
                mode: this.mode
            }), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.dispatchEvent({
                type: "mode-change",
                mode: this.mode
            }))
        },
        enableReticleControl: function() {
            this.reticle.visible || (this.tempEnableReticle = !0, this.unregisterMouseAndTouchEvents(), this.reticle.show(), this.registerReticleEvent(), this.updateReticleEvent())
        },
        disableReticleControl: function() {
            this.tempEnableReticle = !1, this.options.enableReticle ? this.updateReticleEvent() : (this.reticle.hide(), this.unregisterReticleEvent(), this.registerMouseAndTouchEvents())
        },
        enableAutoRate: function() {
            this.options.autoRotate = !0, this.OrbitControls.autoRotate = !0
        },
        disableAutoRate: function() {
            clearTimeout(this.autoRotateRequestId), this.options.autoRotate = !1, this.OrbitControls.autoRotate = !1
        },
        toggleVideoPlay: function(e) {
            this.panorama instanceof u && this.panorama.dispatchEvent({
                type: "video-toggle",
                pause: e
            })
        },
        setVideoCurrentTime: function(e) {
            this.panorama instanceof u && this.panorama.dispatchEvent({
                type: "video-time",
                percentage: e
            })
        },
        onVideoUpdate: function(e) {
            var t = this.widget;
            t && t.dispatchEvent({
                type: "video-update",
                percentage: e
            })
        },
        addUpdateCallback: function(e) {
            e && this.updateCallbacks.push(e)
        },
        removeUpdateCallback: function(e) {
            var t = this.updateCallbacks.indexOf(e);
            e && 0 <= t && this.updateCallbacks.splice(t, 1)
        },
        showVideoWidget: function() {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "video-control-show"
            })
        },
        hideVideoWidget: function() {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "video-control-hide"
            })
        },
        updateVideoPlayButton: function(e) {
            var t = this.widget;
            t && t.videoElement && t.videoElement.controlButton && t.videoElement.controlButton.update(e)
        },
        addPanoramaEventListener: function(e) {
            e.addEventListener("enter-fade-start", this.setCameraControl.bind(this)), e instanceof u && (e.addEventListener("enter-fade-start", this.showVideoWidget.bind(this)), e.addEventListener("leave", function() {
                this.panorama instanceof u || this.hideVideoWidget.call(this)
            }.bind(this)))
        },
        setCameraControl: function() {
            this.OrbitControls.target.copy(this.panorama.position)
        },
        getControl: function() {
            return this.control
        },
        getScene: function() {
            return this.scene
        },
        getCamera: function() {
            return this.camera
        },
        getRenderer: function() {
            return this.renderer
        },
        getContainer: function() {
            return this.container
        },
        getControlId: function() {
            return this.control.id
        },
        getNextControlId: function() {
            return this.controls[this.getNextControlIndex()].id
        },
        getNextControlIndex: function() {
            var e = this.controls,
                t = e.indexOf(this.control) + 1;
            return t >= e.length ? 0 : t
        },
        setCameraFov: function(e) {
            this.camera.fov = e, this.camera.updateProjectionMatrix()
        },
        enableControl: function(e) {
            switch (e = 0 <= e && e < this.controls.length ? e : 0, this.control.enabled = !1, this.control = this.controls[e], this.control.enabled = !0, e) {
                case _.ORBIT:
                    this.camera.position.copy(this.panorama.position), this.camera.position.z += 1;
                    break;
                case _.DEVICEORIENTATION:
                    this.camera.position.copy(this.panorama.position)
            }
            this.control.update(), this.activateWidgetItem(e, void 0)
        },
        disableControl: function() {
            this.control.enabled = !1
        },
        toggleNextControl: function() {
            this.enableControl(this.getNextControlIndex())
        },
        getScreenVector: function(e) {
            e = e.clone();
            var t = this.container.clientWidth / 2,
                i = this.container.clientHeight / 2;
            return e.project(this.camera), e.x = e.x * t + t, e.y = -e.y * i + i, e.z = 0, e
        },
        checkSpriteInViewport: function(e) {
            return this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix), e.visible && this.cameraFrustum.intersectsSprite(e)
        },
        reverseDraggingDirection: function() {
            this.OrbitControls.rotateSpeed *= -1, this.OrbitControls.momentumScalingFactor *= -1
        },
        addReticle: function() {
            this.reticle = new n(16777215, !0, this.options.dwellTime), this.reticle.hide(), this.camera.add(this.reticle), this.sceneReticle.add(this.camera)
        },
        tweenControlCenter: function(e, i, n) {
            var r;
            if (this.control === this.OrbitControls) {
                e instanceof Array && (i = e[1], n = e[2], e = e[0]), i = void 0 !== i ? i : 1e3, n = n || L.Easing.Exponential.Out;
                var o = this,
                    a = this.camera.getWorldDirection(new t.Vector3),
                    s = a.clone(),
                    l = this.panorama.getWorldPosition(new t.Vector3).sub(this.camera.getWorldPosition(new t.Vector3));
                (e = e.clone()).x *= -1, e.add(l).normalize();
                var c = e.clone();
                a.y = 0, e.y = 0, l = (l = (l = Math.atan2(e.z, e.x) - Math.atan2(a.z, a.x)) > Math.PI ? l - 2 * Math.PI : l) < -Math.PI ? l + 2 * Math.PI : l, a = Math.abs(s.angleTo(a) + (0 >= s.y * c.y ? c.angleTo(e) : -c.angleTo(e))), a *= c.y < s.y ? 1 : -1, s = {
                    left: 0,
                    up: 0
                };
                var h = r = 0;
                this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.tweenLeftAnimation = new L.Tween(s).to({
                    left: l
                }, i).easing(n).onUpdate((function(e) {
                    o.control.rotateLeft(e.left - r), r = e.left
                })).start(), this.tweenUpAnimation = new L.Tween(s).to({
                    up: a
                }, i).easing(n).onUpdate((function(e) {
                    o.control.rotateUp(e.up - h), h = e.up
                })).start()
            }
        },
        tweenControlCenterByObject: function(e, i, n) {
            var r = !1;
            if (e.traverseAncestors((function(e) {
                    e.scalePlaceHolder && (r = !0)
                })), r) {
                var o = new t.Vector3(-1, 1, 1);
                this.tweenControlCenter(e.getWorldPosition(new t.Vector3).multiply(o), i, n)
            } else this.tweenControlCenter(e.getWorldPosition(new t.Vector3), i, n)
        },
        onWindowResize: function(e, t) {
            var i = this.container.classList.contains("panolens-container") || this.container.isFullscreen;
            if (void 0 !== e && void 0 !== t) {
                var n = e,
                    r = t;
                this.container._width = e, this.container._height = t
            } else e = (t = /(android)/i.test(window.navigator.userAgent)) ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), t = t ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0), n = i ? e : this.container.clientWidth, r = i ? t : this.container.clientHeight, this.container._width = n, this.container._height = r;
            this.camera.aspect = n / r, this.camera.updateProjectionMatrix(), this.renderer.setSize(n, r), (this.options.enableReticle || this.tempEnableReticle) && this.updateReticleEvent(), this.dispatchEvent({
                type: "window-resize",
                width: n,
                height: r
            }), this.scene.traverse((function(e) {
                e.dispatchEvent && e.dispatchEvent({
                    type: "window-resize",
                    width: n,
                    height: r
                })
            }))
        },
        addOutputElement: function() {
            var e = document.createElement("div");
            e.style.position = "absolute", e.style.right = "10px", e.style.top = "10px", e.style.color = "#fff", this.container.appendChild(e), this.outputDivElement = e
        },
        outputPosition: function() {
            var e = this.raycaster.intersectObject(this.panorama, !0);
            if (0 < e.length) {
                e = e[0].point.clone();
                var i = new t.Vector3(-1, 1, 1),
                    n = this.panorama.getWorldPosition(new t.Vector3);
                if (e.sub(n).multiply(i), i = e.x.toFixed(2) + ", " + e.y.toFixed(2) + ", " + e.z.toFixed(2), 0 !== e.length()) switch (this.options.output) {
                    case "console":
                        console.info(i);
                        break;
                    case "overlay":
                        this.outputDivElement.textContent = i
                }
            }
        },
        onMouseDown: function(e) {
            e.preventDefault(), this.userMouse.x = 0 <= e.clientX ? e.clientX : e.touches[0].clientX, this.userMouse.y = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.userMouse.type = "mousedown", this.onTap(e)
        },
        onMouseMove: function(e) {
            e.preventDefault(), this.userMouse.type = "mousemove", this.onTap(e)
        },
        onMouseUp: function(e) {
            this.userMouse.type = "mouseup";
            var t = this.userMouse.x >= e.clientX - this.options.clickTolerance && this.userMouse.x <= e.clientX + this.options.clickTolerance && this.userMouse.y >= e.clientY - this.options.clickTolerance && this.userMouse.y <= e.clientY + this.options.clickTolerance || e.changedTouches && this.userMouse.x >= e.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= e.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= e.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= e.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0;
            if ((!e || !e.target || e.target.classList.contains("panolens-canvas")) && (e.preventDefault(), e = e.changedTouches && 1 === e.changedTouches.length ? this.onTap({
                    clientX: e.changedTouches[0].clientX,
                    clientY: e.changedTouches[0].clientY
                }, t) : this.onTap(e, t), this.userMouse.type = "none", !e && "click" === t)) {
                e = (t = this.options).autoHideControlBar;
                var i = this.panorama,
                    n = this.toggleControlBar;
                t.autoHideInfospot && i && i.toggleInfospotVisibility(), e && n()
            }
        },
        onTap: function(e, t) {
            var i = this.container.getBoundingClientRect(),
                n = i.top,
                o = this.container,
                a = o.clientHeight;
            if (this.raycasterPoint.x = (e.clientX - i.left) / o.clientWidth * 2 - 1, this.raycasterPoint.y = -(e.clientY - n) / a * 2 + 1, this.raycaster.setFromCamera(this.raycasterPoint, this.camera), this.panorama) {
                if (("mousedown" !== e.type && this.touchSupported || this.OUTPUT_INFOSPOT) && this.outputPosition(), i = this.raycaster.intersectObjects(this.panorama.children, !0), n = this.getConvertedIntersect(i), o = 0 < i.length ? i[0].object : void 0, "mouseup" === this.userMouse.type && (n && this.pressEntityObject === n && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressstop-entity",
                        mouseEvent: e
                    }), this.pressEntityObject = void 0), "mouseup" === this.userMouse.type && (o && this.pressObject === o && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressstop",
                        mouseEvent: e
                    }), this.pressObject = void 0), "click" === t ? (this.panorama.dispatchEvent({
                        type: "click",
                        intersects: i,
                        mouseEvent: e
                    }), n && n.dispatchEvent && n.dispatchEvent({
                        type: "click-entity",
                        mouseEvent: e
                    }), o && o.dispatchEvent && o.dispatchEvent({
                        type: "click",
                        mouseEvent: e
                    })) : (this.panorama.dispatchEvent({
                        type: "hover",
                        intersects: i,
                        mouseEvent: e
                    }), (this.hoverObject && 0 < i.length && this.hoverObject !== n || this.hoverObject && 0 === i.length) && (this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                        type: "hoverleave",
                        mouseEvent: e
                    }), this.reticle.end()), this.hoverObject = void 0), n && 0 < i.length && (this.hoverObject !== n && (this.hoverObject = n, this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                        type: "hoverenter",
                        mouseEvent: e
                    }), (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) && this.reticle.start(this.onTap.bind(this, e, "click")))), "mousedown" === this.userMouse.type && this.pressEntityObject != n && (this.pressEntityObject = n, this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressstart-entity",
                        mouseEvent: e
                    })), "mousedown" === this.userMouse.type && this.pressObject != o && (this.pressObject = o, this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressstart",
                        mouseEvent: e
                    })), "mousemove" === this.userMouse.type || this.options.enableReticle) && (o && o.dispatchEvent && o.dispatchEvent({
                        type: "hover",
                        mouseEvent: e
                    }), this.pressEntityObject && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressmove-entity",
                        mouseEvent: e
                    }), this.pressObject && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressmove",
                        mouseEvent: e
                    })), !n && this.pressEntityObject && this.pressEntityObject.dispatchEvent && (this.pressEntityObject.dispatchEvent({
                        type: "pressstop-entity",
                        mouseEvent: e
                    }), this.pressEntityObject = void 0), !o && this.pressObject && this.pressObject.dispatchEvent && (this.pressObject.dispatchEvent({
                        type: "pressstop",
                        mouseEvent: e
                    }), this.pressObject = void 0)), o && o instanceof r) {
                    if (this.infospot = o, "click" === t) return !0
                } else this.infospot && this.hideInfospot();
                this.options.autoRotate && "mousemove" !== this.userMouse.type && (clearTimeout(this.autoRotateRequestId), this.control === this.OrbitControls && (this.OrbitControls.autoRotate = !1, this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration)))
            }
        },
        getConvertedIntersect: function(e) {
            for (var t, i = 0; i < e.length; i++)
                if (0 <= e[i].distance && e[i].object && !e[i].object.passThrough && (!e[i].object.entity || !e[i].object.entity.passThrough)) {
                    t = e[i].object.entity && !e[i].object.entity.passThrough ? e[i].object.entity : e[i].object;
                    break
                } return t
        },
        hideInfospot: function() {
            this.infospot && (this.infospot.onHoverEnd(), this.infospot = void 0)
        },
        toggleControlBar: function() {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "control-bar-toggle"
            })
        },
        onKeyDown: function(e) {
            this.options.output && "none" !== this.options.output && "Control" === e.key && (this.OUTPUT_INFOSPOT = !0)
        },
        onKeyUp: function() {
            this.OUTPUT_INFOSPOT = !1
        },
        update: function() {
            L.update(), this.updateCallbacks.forEach((function(e) {
                e()
            })), this.control.update(), this.scene.traverse(function(e) {
                if (e instanceof r && e.element && (this.hoverObject === e || "none" !== e.element.style.display || e.element.left && "none" !== e.element.left.style.display || e.element.right && "none" !== e.element.right.style.display))
                    if (this.checkSpriteInViewport(e)) {
                        var i = this.getScreenVector(e.getWorldPosition(new t.Vector3));
                        e.translateElement(i.x, i.y)
                    } else e.onDismiss()
            }.bind(this))
        },
        render: function() {
            this.mode === E.CARDBOARD || this.mode === E.STEREO ? (this.renderer.clear(), this.effect.render(this.scene, this.camera), this.effect.render(this.sceneReticle, this.camera)) : (this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth(), this.renderer.render(this.sceneReticle, this.camera))
        },
        animate: function() {
            this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this)), this.onChange()
        },
        onChange: function() {
            this.update(), this.render()
        },
        registerMouseAndTouchEvents: function() {
            var e = {
                passive: !1
            };
            this.container.addEventListener("mousedown", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("mousemove", this.HANDLER_MOUSE_MOVE, e), this.container.addEventListener("mouseup", this.HANDLER_MOUSE_UP, e), this.container.addEventListener("touchstart", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("touchend", this.HANDLER_MOUSE_UP, e)
        },
        unregisterMouseAndTouchEvents: function() {
            this.container.removeEventListener("mousedown", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("mousemove", this.HANDLER_MOUSE_MOVE, !1), this.container.removeEventListener("mouseup", this.HANDLER_MOUSE_UP, !1), this.container.removeEventListener("touchstart", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("touchend", this.HANDLER_MOUSE_UP, !1)
        },
        registerReticleEvent: function() {
            this.addUpdateCallback(this.HANDLER_TAP)
        },
        unregisterReticleEvent: function() {
            this.removeUpdateCallback(this.HANDLER_TAP)
        },
        updateReticleEvent: function() {
            var e = this.container.clientWidth / 2 + this.container.offsetLeft,
                t = this.container.clientHeight / 2;
            this.removeUpdateCallback(this.HANDLER_TAP), this.HANDLER_TAP = this.onTap.bind(this, {
                clientX: e,
                clientY: t
            }), this.addUpdateCallback(this.HANDLER_TAP)
        },
        registerEventListeners: function() {
            window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.addEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.addEventListener("keyup", this.HANDLER_KEY_UP, !0)
        },
        unregisterEventListeners: function() {
            window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.removeEventListener("keyup", this.HANDLER_KEY_UP, !0)
        },
        dispose: function() {
            this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.unregisterEventListeners(),
                function e(t) {
                    for (var i = t.children.length - 1; 0 <= i; i--) e(t.children[i]), t.remove(t.children[i]);
                    t instanceof a || t instanceof r ? t.dispose() : t.dispatchEvent && t.dispatchEvent("dispose")
                }(this.scene), this.widget && (this.widget.dispose(), this.widget = null), t.Cache && t.Cache.enabled && t.Cache.clear()
        },
        destroy: function() {
            this.dispose(), this.render(), window.cancelAnimationFrame(this.requestAnimationId)
        },
        onPanoramaDispose: function(e) {
            e instanceof u && this.hideVideoWidget(), e === this.panorama && (this.panorama = null)
        },
        loadAsyncRequest: function(e, t) {
            t = void 0 === t ? function() {} : t;
            var i = new window.XMLHttpRequest;
            i.onloadend = function(e) {
                t(e)
            }, i.open("GET", e, !0), i.send(null)
        },
        addViewIndicator: function() {
            var e = this;
            this.loadAsyncRequest(M.ViewIndicator, (function(i) {
                if (0 !== i.loaded) {
                    (i = i.target.responseXML.documentElement).style.width = e.viewIndicatorSize + "px", i.style.height = e.viewIndicatorSize + "px", i.style.position = "absolute", i.style.top = "10px", i.style.left = "10px", i.style.opacity = "0.5", i.style.cursor = "pointer", i.id = "panolens-view-indicator-container", e.container.appendChild(i);
                    var n = i.querySelector("#indicator");
                    e.addUpdateCallback((function() {
                        e.radius = .225 * e.viewIndicatorSize, e.currentPanoAngle = e.camera.rotation.y - t.Math.degToRad(90), e.fovAngle = t.Math.degToRad(e.camera.fov), e.leftAngle = -e.currentPanoAngle - e.fovAngle / 2, e.rightAngle = -e.currentPanoAngle + e.fovAngle / 2, e.leftX = e.radius * Math.cos(e.leftAngle), e.leftY = e.radius * Math.sin(e.leftAngle), e.rightX = e.radius * Math.cos(e.rightAngle), e.rightY = e.radius * Math.sin(e.rightAngle), e.indicatorD = "M " + e.leftX + " " + e.leftY + " A " + e.radius + " " + e.radius + " 0 0 1 " + e.rightX + " " + e.rightY, e.leftX && e.leftY && e.rightX && e.rightY && e.radius && n.setAttribute("d", e.indicatorD)
                    })), i.addEventListener("mouseenter", (function() {
                        this.style.opacity = "1"
                    })), i.addEventListener("mouseleave", (function() {
                        this.style.opacity = "0.5"
                    }))
                }
            }))
        },
        appendControlItem: function(e) {
            var t = this.widget.createCustomItem(e);
            return "video" === e.group ? this.widget.videoElement.appendChild(t) : this.widget.barElement.appendChild(t), t
        },
        clearAllCache: function() {
            t.Cache.clear()
        }
    }), "105" != t.REVISION && console.warn("three.js version is not matched. Please consider use the target revision 105"), window.TWEEN = L, e.BasicPanorama = h, e.CONTROLS = _, e.CameraPanorama = g, e.CubePanorama = c, e.CubeTextureLoader = A, e.DataImage = M, e.EmptyPanorama = l, e.GoogleStreetviewPanorama = p, e.ImageLittlePlanet = m, e.ImageLoader = T, e.ImagePanorama = s, e.Infospot = r, e.LittlePlanet = f, e.MODES = E, e.Media = i, e.Panorama = a, e.REVISION = "11", e.Reticle = n, e.THREE_REVISION = "105", e.THREE_VERSION = w, e.TextureLoader = S, e.VERSION = "0.11.0", e.VideoPanorama = u, e.Viewer = x, e.Widget = o, Object.defineProperty(e, "__esModule", {
        value: !0
    })
})),
function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {})
}(this, (function(e) {
    "use strict";

    function t(e) {
        return e
    }

    function i() {
        return "undefined" != typeof window
    }

    function n() {
        return L || i() && (L = window.gsap) && L.registerPlugin && L
    }

    function r(e) {
        return !!~z.indexOf(e)
    }

    function o(e, t) {
        var i = t.s;
        return function(t) {
            return arguments.length ? e[i] = t : e[i]
        }
    }

    function a(e, t) {
        var i = t.s,
            n = t.d2;
        return (i = "scroll" + n) && r(e) ? Math.max(O[i], I[i]) - (P["inner" + n] || O["client" + n] || I["client" + n]) : e[i] - e["offset" + n]
    }

    function s(e) {
        return "string" == typeof e
    }

    function l(e) {
        return "function" == typeof e
    }

    function c(e) {
        return "number" == typeof e
    }

    function h(e) {
        return "object" == typeof e
    }

    function u(e) {
        return P.getComputedStyle(e)
    }

    function d(e, t) {
        for (var i in t) i in e || (e[i] = t[i]);
        return e
    }

    function p(e, t) {
        var i = t && "matrix(1, 0, 0, 1, 0, 0)" !== u(e)[W] && L.to(e, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1),
            n = e.getBoundingClientRect();
        return i && i.progress(0).kill(), n
    }

    function f(e, t) {
        var i = t.d2;
        return e["offset" + i] || e["client" + i] || 0
    }

    function m(e, t, i, n) {
        return i.split(",").forEach((function(i) {
            return e(t, i, n)
        }))
    }

    function g(e, t, i) {
        return e.addEventListener(t, i, {
            passive: !0
        })
    }

    function v(e, t, i) {
        return e.removeEventListener(t, i)
    }

    function y(e, t) {
        if (s(e)) {
            var i = e.indexOf("="),
                n = ~i ? (e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
            n && (e.indexOf("%") > i && (n *= t / 100), e = e.substr(0, i - 1)), e = n + (e in be ? be[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
        }
        return e
    }

    function b(e, t, i, n, o, a, s) {
        var l = o.startColor,
            c = o.endColor,
            h = o.fontSize,
            u = o.indent,
            d = o.fontWeight,
            p = R.createElement("div"),
            f = r(i),
            m = -1 !== e.indexOf("scroller"),
            g = f ? I : i,
            v = -1 !== e.indexOf("start"),
            y = v ? l : c,
            b = "border-color:" + y + ";font-size:" + h + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return b += "position:" + (m && f ? "fixed;" : "absolute;"), !m && f || (b += (n === ge ? ie : ne) + ":" + (a + parseFloat(u)) + "px;"), s && (b += "box-sizing:border-box;text-align:left;width:" + s.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + e), p.style.cssText = b, p.innerText = t || 0 === t ? e + "-" + t : e, g.insertBefore(p, g.children[0]), p._offset = p["offset" + n.op.d2], xe(p, 0, n, f, v), p
    }

    function x() {
        return F = F || B(Se)
    }

    function w() {
        F || (F = B(Se), Z || Te("scrollStart"), Z = X())
    }

    function _() {
        return !j && 200 < X() - Z && N.restart(!0)
    }

    function E(e) {
        for (var t = Te("refreshInit"), i = we.length, n = i; n--;) we[n].scroll.rec = we[n].scroll();
        for (n = 0; n < i; n++) we[n] && we[n].refresh(!0 !== e);
        for (t.forEach((function(e) {
                return e && e.render && e.render(-1)
            })), n = we.length; n--;) we[n].scroll.rec = 0;
        Te("refresh")
    }

    function M(e, t, i) {
        if (De(i), e.parentNode === t) {
            var n = t.parentNode;
            n && (n.insertBefore(e, t), n.removeChild(t))
        }
    }

    function T(e, t, i) {
        if (e.parentNode !== t) {
            for (var n, r = Ae.length, o = t.style, a = e.style; r--;) o[n = Ae[r]] = i[n];
            o.position = "absolute" === i.position ? "absolute" : "relative", a[ne] = a[ie] = "auto", o.overflow = "visible", o.boxSizing = "border-box", o[re] = f(e, me) + fe, o[oe] = f(e, ge) + fe, o[he] = a[ue] = a[te] = a[ee] = "0", a[re] = i[re], a[oe] = i[oe], a[he] = i[he], e.parentNode.insertBefore(t, e), t.appendChild(e)
        }
    }

    function S(e) {
        for (var t = Ce.length, i = e.style, n = [], r = 0; r < t; r++) n.push(Ce[r], i[Ce[r]]);
        return n.t = e, n
    }

    function A(e, t, i, n, r, o, a, h, d, f, m, g) {
        if (l(e) && (e = e(h)), s(e) && "max" === e.substr(0, 3) && (e = g + ("=" === e.charAt(4) ? y("0" + e.substr(3), i) : 0)), c(e)) a && xe(a, i, n, m, !0);
        else {
            l(t) && (t = t(h));
            var v, b, x, w = k(t)[0] || I,
                _ = p(w) || {},
                E = e.split(" ");
            _ && (_.left || _.top) || "none" !== u(w).display || (x = w.style.display, w.style.display = "block", _ = p(w), x ? w.style.display = x : w.style.removeProperty("display")), v = y(E[0], _[n.d]), b = y(E[1] || "0", i), e = _[n.p] - d[n.p] - f + v + r - b, a && xe(a, b, n, m, i - b < 20 || a._isStart && 20 < b), i -= i - b
        }
        if (o) {
            var M = e + i,
                T = o._isStart;
            g = "scroll" + n.d2, xe(o, M, n, m, T && 20 < M || !T && (m ? Math.max(I[g], O[g]) : o.parentNode[g]) <= M + 1), m && (d = p(a), m && (o.style[n.op.p] = d[n.op.p] - n.op.m - o._offset + fe))
        }
        return Math.round(e)
    }

    function C(e, t) {
        var i, n = r(e) ? t.sc : o(e, t),
            a = "_scroll" + t.p2;
        return e[a] = n,
            function t(r, o, s, l, c) {
                var h = t.tween,
                    u = o.onComplete;
                return h && h.kill(), i = n(), o[a] = r, (o.modifiers = {})[a] = function(e) {
                    return n() !== i ? (h.kill(), t.tween = 0, e = n()) : l && (e = s + l * h.ratio + c * h.ratio * h.ratio), i = Math.round(e)
                }, o.onComplete = function() {
                    t.tween = 0, u && u.call(h)
                }, h = t.tween = L.to(e, o)
            }
    }
    var L, D, P, R, O, I, z, N, B, F, k, U, H, G, j, V, W, q = 1,
        X = Date.now,
        Y = X(),
        Z = 0,
        J = 1,
        Q = Math.abs,
        $ = "scrollLeft",
        K = "scrollTop",
        ee = "left",
        te = "top",
        ie = "right",
        ne = "bottom",
        re = "width",
        oe = "height",
        ae = "Right",
        se = "Left",
        le = "Top",
        ce = "Bottom",
        he = "padding",
        ue = "margin",
        de = "Width",
        pe = "Height",
        fe = "px",
        me = {
            s: $,
            p: ee,
            p2: se,
            os: ie,
            os2: ae,
            d: re,
            d2: de,
            a: "x",
            sc: function(e) {
                return arguments.length ? P.scrollTo(e, ge.sc()) : P.pageXOffset || R[$] || O[$] || I[$] || 0
            }
        },
        ge = {
            s: K,
            p: te,
            p2: le,
            os: ne,
            os2: ce,
            d: oe,
            d2: pe,
            a: "y",
            op: me,
            sc: function(e) {
                return arguments.length ? P.scrollTo(me.sc(), e) : P.pageYOffset || R[K] || O[K] || I[K] || 0
            }
        },
        ve = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        },
        ye = {
            toggleActions: "play",
            anticipatePin: 0
        },
        be = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        },
        xe = function(e, t, i, n, r) {
            var o = {},
                a = i[r ? "os2" : "p2"],
                s = i[r ? "p2" : "os2"];
            e._isFlipped = r, o[i.a + "Percent"] = r ? -100 : 0, o[i.a] = r ? 1 : 0, o["border" + a + de] = 1, o["border" + s + de] = 0, o[i.p] = t, L.set(e, o)
        },
        we = [],
        _e = {},
        Ee = {},
        Me = [],
        Te = function(e) {
            return Ee[e] && Ee[e].map((function(e) {
                return e()
            })) || Me
        },
        Se = function() {
            var e = we.length,
                t = 0,
                i = X(),
                n = 50 <= i - Y;
            for (n && (Z && !V && 200 < i - Z && (Z = 0, Te("scrollEnd")), H = Y, Y = i); t < e; t++) we[t] && we[t].update(0, n);
            F = 0
        },
        Ae = [ee, te, ne, ie, ue + ce, ue + ae, ue + le, ue + se, "display", "flexShrink"],
        Ce = Ae.concat([re, oe, "boxSizing", "max" + de, "max" + pe, "position", ue, he, he + le, he + ae, he + ce, he + se]),
        Le = /([A-Z])/g,
        De = function(e) {
            for (var t, i, n = e.t.style, r = e.length, o = 0; o < r; o += 2) i = e[o + 1], t = e[o], i ? n[t] = i : n[t] && n.removeProperty(t.replace(Le, "-$1").toLowerCase())
        },
        Pe = {
            left: 0,
            top: 0
        },
        Re = /(?:webkit|moz|length)/i;
    me.op = ge;
    var Oe = (Ie.prototype.init = function(e, i) {
        if (this.progress = 0, this.vars && this.kill(1), J) {
            var n, m, x, E, D, O, z, N, B, F, G, W, Y, $, K, ee, te, ie, ne, be, xe, Ee, Me, Te, Se, Ae, Ce, Le, Oe, ze, Ne, Be, Fe, ke, Ue, He, Ge = (e = d(s(e) || c(e) || e.nodeType ? {
                    trigger: e
                } : e, ye)).horizontal ? me : ge,
                je = e.onUpdate,
                Ve = e.toggleClass,
                We = e.id,
                qe = e.onToggle,
                Xe = e.onRefresh,
                Ye = e.scrub,
                Ze = e.trigger,
                Je = e.pin,
                Qe = e.pinSpacing,
                $e = e.invalidateOnRefresh,
                Ke = e.anticipatePin,
                et = e.onScrubComplete,
                tt = e.onSnapComplete,
                it = e.once,
                nt = e.snap,
                rt = e.pinReparent,
                ot = !Ye && 0 !== Ye,
                at = k(e.scroller || P)[0],
                st = L.core.getCache(at),
                lt = r(at),
                ct = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                ht = ot && (it ? "play" : e.toggleActions).split(" "),
                ut = "markers" in e ? e.markers : ye.markers,
                dt = lt ? 0 : parseFloat(u(at)["border" + Ge.p2 + de]) || 0,
                pt = this,
                ft = function e() {
                    return Ie.removeEventListener("scrollEnd", e) || pt.refresh()
                },
                mt = e.onRefreshInit && function() {
                    return e.onRefreshInit(pt)
                };
            Ke *= 45, we.push(pt), pt.scroller = at, pt.scroll = lt ? Ge.sc : o(at, Ge), D = pt.scroll(), pt.vars = e, i = i || e.animation, st.tweenScroll = st.tweenScroll || {
                top: C(at, ge),
                left: C(at, me)
            }, pt.tweenTo = n = st.tweenScroll[Ge.p], i && (i.vars.lazy = !1, i._initted || !1 !== i.vars.immediateRender && i.render(-.01, !0, !0), pt.animation = i.pause(), i.scrollTrigger = pt, (Fe = c(Ye) && Ye) && (Be = L.to(i, {
                ease: "power3",
                duration: Fe,
                onComplete: function() {
                    return et && et(pt)
                }
            })), Oe = 0, We = We || i.vars.id), nt && (h(nt) || (nt = {
                snapTo: nt
            }), x = l(nt.snapTo) ? nt.snapTo : "labels" === nt.snapTo ? function(e) {
                return function(t) {
                    var i, n = [],
                        r = e.labels,
                        o = e.duration();
                    for (i in r) n.push(r[i] / o);
                    return L.utils.snap(n, t)
                }
            }(i) : L.utils.snap(nt.snapTo), ke = h(ke = nt.duration || {
                min: .1,
                max: 2
            }) ? U(ke.min, ke.max) : U(ke, ke), Ue = L.delayedCall(nt.delay || Fe / 2 || .1, (function() {
                if (!Z || Z === Ne && !V) {
                    var e = i && !ot ? i.totalProgress() : pt.progress,
                        t = (e - ze) / (X() - H) * 1e3 || 0,
                        r = Q(t / 2) * t / .185,
                        o = e + r,
                        a = U(0, 1, x(o, pt)),
                        s = a - e - r,
                        l = pt.scroll(),
                        c = Math.round(z + a * $),
                        h = n.tween;
                    if (l <= N && z <= l) {
                        if (h && !h._initted) {
                            if (h.data <= Math.abs(c - l)) return;
                            h.kill()
                        }
                        n(c, {
                            duration: ke(Q(.185 * Math.max(Q(o - e), Q(a - e)) / t / .05 || 0)),
                            ease: nt.ease || "power3",
                            data: Math.abs(c - l),
                            onComplete: function() {
                                Oe = ze = i && !ot ? i.totalProgress() : pt.progress, tt && tt(pt)
                            }
                        }, z + e * $, r * $, s * $)
                    }
                } else Ue.restart(!0)
            })).pause()), We && (_e[We] = pt), Ze = pt.trigger = k(Ze || Je)[0], Je = !0 === Je ? Ze : k(Je)[0], s(Ve) && (Ve = {
                targets: Ze,
                className: Ve
            }), Je && (!1 === Qe || Qe === ue || (Qe = "flex" !== u(Je.parentNode).display && he), pt.pin = Je, !1 !== e.force3D && L.set(Je, {
                force3D: !0
            }), (m = L.core.getCache(Je)).spacer ? K = m.pinState : (m.spacer = ie = R.createElement("div"), ie.setAttribute("class", "pin-spacer" + (We ? " pin-spacer-" + We : "")), m.pinState = K = S(Je)), pt.spacer = ie = m.spacer, Le = u(Je), Te = Le[Qe + Ge.os2], be = L.getProperty(Je), xe = L.quickSetter(Je, Ge.a, fe), T(Je, ie, Le), te = S(Je)), ut && (Y = h(ut) ? d(ut, ve) : ve, G = b("scroller-start", We, at, Ge, Y, 0), W = b("scroller-end", We, at, Ge, Y, 0, G), ne = G["offset" + Ge.op.d2], B = b("start", We, at, Ge, Y, ne), F = b("end", We, at, Ge, Y, ne), lt || (function(e) {
                e.style.position = "absolute" === u(e).position ? "absolute" : "relative"
            }(at), L.set([G, W], {
                force3D: !0
            }), Ae = L.quickSetter(G, Ge.a, fe), Ce = L.quickSetter(W, Ge.a, fe))), pt.revert = function(e) {
                var t = !1 !== e;
                t !== E && (pt.update(t), Je && t && M(Je, ie, K), E = t)
            }, pt.refresh = function(t) {
                if (!j && He)
                    if (Je && t && Z) g(Ie, "scrollEnd", ft);
                    else {
                        var n = Math.max(pt.scroll(), pt.scroll.rec || 0),
                            r = pt.progress;
                        j = 1, Be && Be.kill(), $e && i && i.progress(0).invalidate().progress(pt.progress), E || pt.revert();
                        var o, c, h, d, m, v, b, x = (lt ? P["inner" + Ge.d2] : at["client" + Ge.d2]) || 0,
                            w = lt ? Pe : p(at),
                            _ = a(at, Ge),
                            M = 0,
                            C = 0,
                            D = e.end,
                            R = e.endTrigger || Ze,
                            O = e.start || (Je || !Ze ? "0 0" : "0 100%"),
                            k = Je && Math.max(0, we.indexOf(pt)) || 0;
                        if (k)
                            for (v = k; v--;) we[v].pin === Je && we[v].revert();
                        if (z = A(O, Ze, x, Ge, pt.scroll(), B, G, pt, w, dt, lt, _) || (Je ? -.001 : 0), l(D) && (D = D(pt)), s(D) && !D.indexOf("+=") && (~D.indexOf(" ") ? D = (s(O) ? O.split(" ")[0] : "") + D : (M = y(D.substr(2), x), D = s(O) ? O : z + M, R = Ze)), N = Math.max(z, A(D || (R ? "100% 0" : _), R, x, Ge, pt.scroll() + M, F, W, pt, w, dt, lt, _)) || -.001, $ = N - z || (z -= .01) && .001, Je) {
                            for (v = k; v--;)(b = we[v]).pin === Je && b.start - b._pinPush < z && (C += b.end - b.start);
                            if (z += C, N += C, pt._pinPush = C, B && C && ((o = {})[Ge.a] = "+=" + C, L.set([B, F], o)), o = u(Je), d = Ge === ge, h = pt.scroll(), Ee = parseFloat(be(Ge.a)) + C, T(Je, ie, o), te = S(Je), c = p(Je, !0), Qe && (ie.style[Qe + Ge.os2] = $ + C + fe, (Se = Qe === he ? f(Je, Ge) + $ + C : 0) && (ie.style[Ge.d] = Se + fe), lt && pt.scroll(n)), lt && ((m = {
                                    top: c.top + (d ? h - z : 0) + fe,
                                    left: c.left + (d ? 0 : h - z) + fe,
                                    boxSizing: "border-box",
                                    position: "fixed"
                                })[re] = m.maxWidth = Math.ceil(c.width) + fe, m[oe] = m["max" + pe] = Math.ceil(c.height) + fe, m[ue] = m[ue + le] = m[ue + ae] = m[ue + ce] = m[ue + se] = "0", m[he] = o[he], m[he + le] = o[he + le], m[he + ae] = o[he + ae], m[he + ce] = o[he + ce], m[he + se] = o[he + se], ee = function(e, t, i) {
                                    for (var n, r = [], o = e.length, a = i ? 8 : 0; a < o; a += 2) n = e[a], r.push(n, n in t ? t[n] : e[a + 1]);
                                    return r.t = e.t, r
                                }(K, m, rt)), i ? (i.progress(1, !0), Me = be(Ge.a) - Ee + $ + C, $ !== Me && ee.splice(ee.length - 2, 2), i.progress(0, !0)) : Me = $, k)
                                for (v = 0; v < k; v++) we[v].pin === Je && we[v].revert(!1)
                        } else if (Ze && pt.scroll())
                            for (c = Ze.parentNode; c && c !== I;) c._pinOffset && (z -= c._pinOffset, N -= c._pinOffset), c = c.parentNode;
                        pt.start = z, pt.end = N, pt.scroll() < n && pt.scroll(n), pt.revert(!1), j = 0, r !== pt.progress && (Be && i.totalProgress(r, !0), pt.progress = r, pt.update()), Je && Qe && (ie._pinOffset = Math.round(pt.progress * Me)), Xe && Xe(pt)
                    }
            }, pt.getVelocity = function() {
                return (pt.scroll() - O) / (X() - H) * 1e3 || 0
            }, pt.update = function(e, t) {
                var r, o, s, l, c, h = pt.scroll(),
                    d = e ? 0 : (h - z) / $,
                    f = d < 0 ? 0 : 1 < d ? 1 : d || 0,
                    m = pt.progress;
                if (t && (O = D, D = h, nt && (ze = Oe, Oe = i && !ot ? i.totalProgress() : f)), Ke && !f && Je && !j && z < h + (h - O) / (X() - H) * Ke && (f = 1e-4), f !== m && He) {
                    if (l = (c = (r = pt.isActive = !!f && f < 1) != (!!m && m < 1)) || !!f != !!m, pt.direction = m < f ? 1 : -1, pt.progress = f, ot || (!Be || j || q ? i && i.totalProgress(f, !!j) : (Be.vars.totalProgress = f, Be.invalidate().restart())), Je)
                        if (e && Qe && (ie.style[Qe + Ge.os2] = Te), lt) {
                            if (l) {
                                if (s = !e && h + 1 >= a(at, Ge), rt) {
                                    if (!j && (r || s)) {
                                        var g = p(Je, !0),
                                            v = h - z;
                                        Je.style.top = g.top + (Ge === ge ? v : 0) + fe, Je.style.left = g.left + (Ge === ge ? 0 : v) + fe
                                    }! function(e, t) {
                                        if (e.parentNode !== t) {
                                            var i, n, r = e.style;
                                            if (t === I)
                                                for (i in e._stOrig = r.cssText, n = u(e)) + i || Re.test(i) || !n[i] || "string" != typeof r[i] || "0" === i || (r[i] = n[i]);
                                            else r.cssText = e._stOrig;
                                            t.appendChild(e)
                                        }
                                    }(Je, j || !r && !s ? ie : I)
                                }
                                De(r || s ? ee : te), Me !== $ && f < 1 && r || xe(Ee + (1 !== f || s ? 0 : Me))
                            }
                        } else xe(Ee + Me * f);
                    !nt || n.tween || j || q || (Ne = Z, Ue.restart(!0)), Ve && c && (!it || r) && k(Ve.targets).forEach((function(e) {
                        return e.classList[r ? "add" : "remove"](Ve.className)
                    })), !je || ot || e || je(pt), l && !j ? (o = f && !m ? 0 : 1 === f ? 1 : 1 === m ? 2 : 3, 1 === f && it ? pt.kill() : ot && (s = !c && "none" !== ht[o + 1] && ht[o + 1] || ht[o], i && ("complete" === s || "reset" === s || s in i) && ("complete" === s ? i.pause().totalProgress(1) : "reset" === s ? i.restart(!0).pause() : i[s]()), je && je(pt)), !c && q || (qe && c && qe(pt), ct[o] && ct[o](pt), it && (ct[o] = 0), c || ct[o = 1 === f ? 1 : 3] && ct[o](pt))) : ot && je && !j && je(pt)
                }
                Ce && (Ae(h + (G._isFlipped ? 1 : 0)), Ce(h))
            }, pt.enable = function() {
                He || (He = !0, g(at, "resize", _), g(at, "scroll", w), mt && g(Ie, "refreshInit", mt), i && (i.add ? L.delayedCall(.01, pt.refresh) && ($ = .01) && (z = N = 0) : pt.refresh()))
            }, pt.disable = function(e) {
                if (He && (He = pt.isActive = !1, Be && Be.pause(), e !== He && pt.update(1), Je && M(Je, ie, K), mt && v(Ie, "refreshInit", mt), Ue && (Ue.pause(), n.tween && n.tween.kill()), !lt)) {
                    for (var t = we.length; t--;)
                        if (we[t].scroller === at && we[t] !== pt) return;
                    v(at, "resize", _), v(at, "scroll", w)
                }
            }, pt.kill = function(e) {
                pt.disable(e), We && delete _e[We], we.splice(we.indexOf(pt), 1), i && (i.scrollTrigger = null)
            }, pt.enable()
        } else this.update = this.refresh = this.kill = t
    }, Ie.register = function(e) {
        if (L = e || n(), i() && window.document && (P = window, R = document, O = R.documentElement, I = R.body), L && (k = L.utils.toArray, U = L.utils.clamp, L.core.globals("ScrollTrigger", Ie), I)) {
            B = P.requestAnimationFrame || function(e) {
                return setTimeout(e, 16)
            }, g(P, "mousewheel", w), z = [P, R, O, I], g(R, "scroll", w);
            var r, o = I.style,
                a = o.borderTop;
            o.borderTop = "1px solid #000", r = p(I), ge.m = Math.round(r.top + ge.sc()) || 0, me.m = Math.round(r.left + me.sc()) || 0, a ? o.borderTop = a : o.removeProperty("border-top"), G = setInterval(x, 100), L.delayedCall(.5, (function() {
                return q = 0
            })), g(R, "touchcancel", t), g(I, "touchstart", t), m(g, R, "pointerdown,touchstart,mousedown", (function() {
                return V = 1
            })), m(g, R, "pointerup,touchend,mouseup", (function() {
                return V = 0
            })), W = L.utils.checkPrefix("transform"), Ce.push(W), D = X(), N = L.delayedCall(.2, E).pause(), g(R, "visibilitychange", (function() {
                return R.hidden || E()
            })), g(R, "DOMContentLoaded", E), g(P, "load", (function() {
                return Z || E()
            })), g(P, "resize", _)
        }
        return D
    }, Ie.defaults = function(e) {
        for (var t in e) ye[t] = e[t]
    }, Ie.kill = function() {
        J = 0, we.slice(0).forEach((function(e) {
            return e.kill(1)
        }))
    }, Ie);

    function Ie(e, t) {
        D || Ie.register(L) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e, t)
    }
    Oe.version = "3.3.3", Oe.create = function(e, t) {
        return new Oe(e, t)
    }, Oe.refresh = function(e) {
        return e ? _() : E(!0)
    }, Oe.update = Se, Oe.maxScroll = function(e, t) {
        return a(e, t ? me : ge)
    }, Oe.getScrollFunc = function(e, t) {
        return (t = t ? me : ge) && (r(e) ? t.sc : o(e, t))
    }, Oe.getById = function(e) {
        return _e[e]
    }, Oe.getAll = function() {
        return we.slice(0)
    }, Oe.syncInterval = function(e) {
        return clearInterval(G) || (G = e) && setInterval(x, e)
    }, Oe.isScrolling = function() {
        return !!Z
    }, Oe.addEventListener = function(e, t) {
        var i = Ee[e] || (Ee[e] = []);
        ~i.indexOf(t) || i.push(t)
    }, Oe.removeEventListener = function(e, t) {
        var i = Ee[e],
            n = i && i.indexOf(t);
        0 <= n && i.splice(n, 1)
    }, Oe.batch = function(e, t) {
        function i(e, t) {
            var i = [],
                n = [],
                r = L.delayedCall(a, (function() {
                    t(i, n), i = [], n = []
                })).pause();
            return function(e) {
                i.length || r.restart(!0), i.push(e.trigger), n.push(e), s <= i.length && r.progress(1)
            }
        }
        var n, r = [],
            o = {},
            a = t.interval || .016,
            s = t.batchMax || 1e9;
        for (n in t) o[n] = "on" === n.substr(0, 2) && l(t[n]) && "onRefreshInit" !== n ? i(0, t[n]) : t[n];
        return l(s) && (s = s(), Oe.addEventListener("refresh", (function() {
            return s = t.batchMax()
        }))), k(e).forEach((function(e) {
            var t = {};
            for (n in o) t[n] = o[n];
            t.trigger = e, r.push(Oe.create(t))
        })), r
    }, n() && L.registerPlugin(Oe), e.ScrollTrigger = Oe, e.default = Oe, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
        value: !0
    }) : delete e.default
})),
function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {})
}(this, (function(e) {
    "use strict";
    var t = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

    function i(e) {
        return g.getComputedStyle(e)
    }

    function n(e, t) {
        var i;
        return w(e) ? e : "string" == (i = typeof e) && !t && e ? _.call(m.querySelectorAll(e), 0) : e && "object" == i && "length" in e ? _.call(e, 0) : e ? [e] : []
    }

    function r(e) {
        return "absolute" === e.position || !0 === e.absolute
    }

    function o(e, t) {
        for (var i, n = t.length; - 1 < --n;)
            if (i = t[n], e.substr(0, i.length) === i) return i.length
    }

    function a(e, t) {
        void 0 === e && (e = "");
        var i = ~e.indexOf("++"),
            n = 1;
        return i && (e = e.split("++").join("")),
            function() {
                return "<" + t + " style='position:relative;display:inline-block;'" + (e ? " class='" + e + (i ? n++ : "") + "'>" : ">")
            }
    }

    function s(e, t, i) {
        var n = e.nodeType;
        if (1 === n || 9 === n || 11 === n)
            for (e = e.firstChild; e; e = e.nextSibling) s(e, t, i);
        else 3 !== n && 4 !== n || (e.nodeValue = e.nodeValue.split(t).join(i))
    }

    function l(e, t) {
        for (var i = t.length; - 1 < --i;) e.push(t[i])
    }

    function c(e, t, i) {
        for (var n; e && e !== t;) {
            if (n = e._next || e.nextSibling) return n.textContent.charAt(0) === i;
            e = e.parentNode || e._parent
        }
    }

    function h(e) {
        var t, i, r = n(e.childNodes),
            o = r.length;
        for (t = 0; t < o; t++)(i = r[t])._isSplit ? h(i) : t && i.previousSibling && 3 === i.previousSibling.nodeType ? (i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue, e.removeChild(i)) : 3 !== i.nodeType && (e.insertBefore(i.firstChild, i), e.removeChild(i))
    }

    function u(e, t) {
        return parseFloat(t[e]) || 0
    }

    function d(e, t, n, o, a, d, p) {
        var f, g, v, y, b, x, w, _, E, M, T, S, A = i(e),
            C = u("paddingLeft", A),
            L = -999,
            D = u("borderBottomWidth", A) + u("borderTopWidth", A),
            P = u("borderLeftWidth", A) + u("borderRightWidth", A),
            R = u("paddingTop", A) + u("paddingBottom", A),
            O = u("paddingLeft", A) + u("paddingRight", A),
            I = u("fontSize", A) * (t.lineThreshold || .2),
            z = A.textAlign,
            N = [],
            B = [],
            F = [],
            k = t.wordDelimiter || " ",
            U = t.tag ? t.tag : t.span ? "span" : "div",
            H = t.type || t.split || "chars,words,lines",
            G = a && ~H.indexOf("lines") ? [] : null,
            j = ~H.indexOf("words"),
            V = ~H.indexOf("chars"),
            W = r(t),
            q = t.linesClass,
            X = ~(q || "").indexOf("++"),
            Y = [],
            Z = "flex" === A.display,
            J = e.style.display;
        for (X && (q = q.split("++").join("")), Z && (e.style.display = "block"), v = (g = e.getElementsByTagName("*")).length, b = [], f = 0; f < v; f++) b[f] = g[f];
        if (G || W)
            for (f = 0; f < v; f++)((x = (y = b[f]).parentNode === e) || W || V && !j) && (S = y.offsetTop, G && x && Math.abs(S - L) > I && ("BR" !== y.nodeName || 0 === f) && (w = [], G.push(w), L = S), W && (y._x = y.offsetLeft, y._y = S, y._w = y.offsetWidth, y._h = y.offsetHeight), G && ((y._isSplit && x || !V && x || j && x || !j && y.parentNode.parentNode === e && !y.parentNode._isSplit) && (w.push(y), y._x -= C, c(y, e, k) && (y._wordEnd = !0)), "BR" === y.nodeName && (y.nextSibling && "BR" === y.nextSibling.nodeName || 0 === f) && G.push([])));
        for (f = 0; f < v; f++)
            if (x = (y = b[f]).parentNode === e, "BR" !== y.nodeName)
                if (W && (E = y.style, j || x || (y._x += y.parentNode._x, y._y += y.parentNode._y), E.left = y._x + "px", E.top = y._y + "px", E.position = "absolute", E.display = "block", E.width = y._w + 1 + "px", E.height = y._h + "px"), !j && V)
                    if (y._isSplit)
                        for (y._next = g = y.nextSibling, y.parentNode.appendChild(y); g && 3 === g.nodeType && " " === g.textContent;) y._next = g.nextSibling, y.parentNode.appendChild(g), g = g.nextSibling;
                    else y.parentNode._isSplit ? (y._parent = y.parentNode, !y.previousSibling && y.firstChild && (y.firstChild._isFirst = !0), y.nextSibling && " " === y.nextSibling.textContent && !y.nextSibling.nextSibling && Y.push(y.nextSibling), y._next = y.nextSibling && y.nextSibling._isFirst ? null : y.nextSibling, y.parentNode.removeChild(y), b.splice(f--, 1), v--) : x || (S = !y.nextSibling && c(y.parentNode, e, k), y.parentNode._parent && y.parentNode._parent.appendChild(y), S && y.parentNode.appendChild(m.createTextNode(" ")), "span" === U && (y.style.display = "inline"), N.push(y));
        else y.parentNode._isSplit && !y._isSplit && "" !== y.innerHTML ? B.push(y) : V && !y._isSplit && ("span" === U && (y.style.display = "inline"), N.push(y));
        else G || W ? (y.parentNode && y.parentNode.removeChild(y), b.splice(f--, 1), v--) : j || e.appendChild(y);
        for (f = Y.length; - 1 < --f;) Y[f].parentNode.removeChild(Y[f]);
        if (G) {
            for (W && (M = m.createElement(U), e.appendChild(M), T = M.offsetWidth + "px", S = M.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(M)), E = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;) e.removeChild(e.firstChild);
            for (_ = " " === k && (!W || !j && !V), f = 0; f < G.length; f++) {
                for (w = G[f], (M = m.createElement(U)).style.cssText = "display:block;text-align:" + z + ";position:" + (W ? "absolute;" : "relative;"), q && (M.className = q + (X ? f + 1 : "")), F.push(M), v = w.length, g = 0; g < v; g++) "BR" !== w[g].nodeName && (y = w[g], M.appendChild(y), _ && y._wordEnd && M.appendChild(m.createTextNode(" ")), W && (0 === g && (M.style.top = y._y + "px", M.style.left = C + S + "px"), y.style.top = "0px", S && (y.style.left = y._x - S + "px")));
                0 === v ? M.innerHTML = "&nbsp;" : j || V || (h(M), s(M, String.fromCharCode(160), " ")), W && (M.style.width = T, M.style.height = y._h + "px"), e.appendChild(M)
            }
            e.style.cssText = E
        }
        W && (p > e.clientHeight && (e.style.height = p - R + "px", e.clientHeight < p && (e.style.height = p + D + "px")), d > e.clientWidth && (e.style.width = d - O + "px", e.clientWidth < d && (e.style.width = d + P + "px"))), Z && (J ? e.style.display = J : e.style.removeProperty("display")), l(n, N), j && l(o, B), l(a, F)
    }

    function p(e, i, n, a) {
        var l, c, h, u, d, p, f, g, v = i.tag ? i.tag : i.span ? "span" : "div",
            y = ~(i.type || i.split || "chars,words,lines").indexOf("chars"),
            w = r(i),
            _ = i.wordDelimiter || " ",
            E = " " !== _ ? "" : w ? "&#173; " : " ",
            M = "</" + v + ">",
            T = 1,
            S = i.specialChars ? "function" == typeof i.specialChars ? i.specialChars : o : null,
            A = m.createElement("div"),
            C = e.parentNode;
        for (C.insertBefore(A, e), A.textContent = e.nodeValue, C.removeChild(e), f = -1 !== (l = function e(t) {
                var i = t.nodeType,
                    n = "";
                if (1 === i || 9 === i || 11 === i) {
                    if ("string" == typeof t.textContent) return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling) n += e(t)
                } else if (3 === i || 4 === i) return t.nodeValue;
                return n
            }(e = A)).indexOf("<"), !1 !== i.reduceWhiteSpace && (l = l.replace(x, " ").replace(b, "")), f && (l = l.split("<").join("{{LT}}")), d = l.length, c = (" " === l.charAt(0) ? E : "") + n(), h = 0; h < d; h++)
            if (p = l.charAt(h), S && (g = S(l.substr(h), i.specialChars))) p = l.substr(h, g || 1), c += y && " " !== p ? a() + p + "</" + v + ">" : p, h += g - 1;
            else if (p === _ && l.charAt(h - 1) !== _ && h) {
            for (c += T ? M : "", T = 0; l.charAt(h + 1) === _;) c += E, h++;
            h === d - 1 ? c += E : ")" !== l.charAt(h + 1) && (c += E + n(), T = 1)
        } else "{" === p && "{{LT}}" === l.substr(h, 6) ? (c += y ? a() + "{{LT}}</" + v + ">" : "{{LT}}", h += 5) : 55296 <= p.charCodeAt(0) && p.charCodeAt(0) <= 56319 || 65024 <= l.charCodeAt(h + 1) && l.charCodeAt(h + 1) <= 65039 ? (u = ((l.substr(h, 12).split(t) || [])[1] || "").length || 2, c += y && " " !== p ? a() + l.substr(h, u) + "</" + v + ">" : l.substr(h, u), h += u - 1) : c += y && " " !== p ? a() + p + "</" + v + ">" : p;
        e.outerHTML = c + (T ? M : ""), f && s(C, "{{LT}}", "<")
    }

    function f(e, t, o, a) {
        var s, l, c = n(e.childNodes),
            h = c.length,
            u = r(t);
        if (3 !== e.nodeType || 1 < h) {
            for (t.absolute = !1, s = 0; s < h; s++)(l = c[s])._next = l._isFirst = l._parent = l._wordEnd = null, 3 === l.nodeType && !/\S+/.test(l.nodeValue) || (u && 3 !== l.nodeType && "inline" === i(l).display && (l.style.display = "inline-block", l.style.position = "relative"), l._isSplit = !0, f(l, t, o, a));
            return t.absolute = u, void(e._isSplit = !0)
        }
        p(e, t, o, a)
    }
    var m, g, v, y, b = /(?:\r|\n|\t\t)/g,
        x = /(?:\s\s+)/g,
        w = Array.isArray,
        _ = [].slice,
        E = ((y = M.prototype).split = function(e) {
            this.isSplit && this.revert(), this.vars = e = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
            for (var t, i, n, r = this.elements.length, o = e.tag ? e.tag : e.span ? "span" : "div", s = a(e.wordsClass, o), l = a(e.charsClass, o); - 1 < --r;) n = this.elements[r], this._originals[r] = n.innerHTML, t = n.clientHeight, i = n.clientWidth, f(n, e, s, l), d(n, e, this.chars, this.words, this.lines, i, t);
            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
        }, y.revert = function() {
            var e = this._originals;
            if (!e) throw "revert() call wasn't scoped properly.";
            return this.elements.forEach((function(t, i) {
                return t.innerHTML = e[i]
            })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
        }, M.create = function(e, t) {
            return new M(e, t)
        }, M);

    function M(e, t) {
        v || (m = document, g = window, v = 1), this.elements = n(e), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t)
    }
    E.version = "3.6.1", e.SplitText = E, e.default = E, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
        value: !0
    }) : delete e.default
}));
var Swiper = function() {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function t(i, n) {
        void 0 === i && (i = {}), void 0 === n && (n = {});
        const r = ["__proto__", "constructor", "prototype"];
        Object.keys(n).filter((e => r.indexOf(e) < 0)).forEach((r => {
            void 0 === i[r] ? i[r] = n[r] : e(n[r]) && e(i[r]) && Object.keys(n[r]).length > 0 && t(i[r], n[r])
        }))
    }
    const i = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };

    function n() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, i), e
    }
    const r = {
        document: i,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function() {
            return this
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function o() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, r), e
    }

    function a(e) {
        return void 0 === e && (e = ""), e.trim().split(" ").filter((e => !!e.trim()))
    }

    function s(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t)
    }

    function l() {
        return Date.now()
    }

    function c(e, t) {
        void 0 === t && (t = "x");
        const i = o();
        let n, r, a;
        const s = function(e) {
            const t = o();
            let i;
            return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i
        }(e);
        return i.WebKitCSSMatrix ? (r = s.transform || s.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), a = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (a = s.MozTransform || s.OTransform || s.MsTransform || s.msTransform || s.transform || s.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = a.toString().split(",")), "x" === t && (r = i.WebKitCSSMatrix ? a.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (r = i.WebKitCSSMatrix ? a.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), r || 0
    }

    function h(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function u() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
            t = ["__proto__", "constructor", "prototype"];
        for (let n = 1; n < arguments.length; n += 1) {
            const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
            if (null != r && (i = r, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
                const i = Object.keys(Object(r)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, n = i.length; t < n; t += 1) {
                    const n = i[t],
                        o = Object.getOwnPropertyDescriptor(r, n);
                    void 0 !== o && o.enumerable && (h(e[n]) && h(r[n]) ? r[n].__swiper__ ? e[n] = r[n] : u(e[n], r[n]) : !h(e[n]) && h(r[n]) ? (e[n] = {}, r[n].__swiper__ ? e[n] = r[n] : u(e[n], r[n])) : e[n] = r[n])
                }
            }
        }
        var i;
        return e
    }

    function d(e, t, i) {
        e.style.setProperty(t, i)
    }

    function p(e) {
        let {
            swiper: t,
            targetPosition: i,
            side: n
        } = e;
        const r = o(),
            a = -t.translate;
        let s, l = null;
        const c = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID);
        const h = i > a ? "next" : "prev",
            u = (e, t) => "next" === h && e >= t || "prev" === h && e <= t,
            d = () => {
                s = (new Date).getTime(), null === l && (l = s);
                const e = Math.max(Math.min((s - l) / c, 1), 0),
                    o = .5 - Math.cos(e * Math.PI) / 2;
                let h = a + o * (i - a);
                if (u(h, i) && (h = i), t.wrapperEl.scrollTo({
                        [n]: h
                    }), u(h, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [n]: h
                    })
                })), void r.cancelAnimationFrame(t.cssModeFrameID);
                t.cssModeFrameID = r.requestAnimationFrame(d)
            };
        d()
    }

    function f(e) {
        return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
    }

    function m(e, t) {
        void 0 === t && (t = "");
        const i = o(),
            n = [...e.children];
        return i.HTMLSlotElement && e instanceof HTMLSlotElement && n.push(...e.assignedElements()), t ? n.filter((e => e.matches(t))) : n
    }

    function g(e) {
        try {
            return void console.warn(e)
        } catch (e) {}
    }

    function v(e, t) {
        void 0 === t && (t = []);
        const i = document.createElement(e);
        return i.classList.add(...Array.isArray(t) ? t : a(t)), i
    }

    function y(e) {
        const t = o(),
            i = n(),
            r = e.getBoundingClientRect(),
            a = i.body,
            s = e.clientTop || a.clientTop || 0,
            l = e.clientLeft || a.clientLeft || 0,
            c = e === t ? t.scrollY : e.scrollTop,
            h = e === t ? t.scrollX : e.scrollLeft;
        return {
            top: r.top + c - s,
            left: r.left + h - l
        }
    }

    function b(e, t) {
        return o().getComputedStyle(e, null).getPropertyValue(t)
    }

    function x(e) {
        let t, i = e;
        if (i) {
            for (t = 0; null !== (i = i.previousSibling);) 1 === i.nodeType && (t += 1);
            return t
        }
    }

    function w(e, t) {
        const i = [];
        let n = e.parentElement;
        for (; n;) t ? n.matches(t) && i.push(n) : i.push(n), n = n.parentElement;
        return i
    }

    function _(e, t) {
        t && e.addEventListener("transitionend", (function i(n) {
            n.target === e && (t.call(e, n), e.removeEventListener("transitionend", i))
        }))
    }

    function E(e, t, i) {
        const n = o();
        return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
    }

    function M(e) {
        return (Array.isArray(e) ? e : [e]).filter((e => !!e))
    }

    function T(e) {
        return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t
    }
    let S, A, C;

    function L() {
        return S || (S = function() {
            const e = o(),
                t = n();
            return {
                smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
            }
        }()), S
    }

    function D(e) {
        return void 0 === e && (e = {}), A || (A = function(e) {
            let {
                userAgent: t
            } = void 0 === e ? {} : e;
            const i = L(),
                n = o(),
                r = n.navigator.platform,
                a = t || n.navigator.userAgent,
                s = {
                    ios: !1,
                    android: !1
                },
                l = n.screen.width,
                c = n.screen.height,
                h = a.match(/(Android);?[\s\/]+([\d.]+)?/);
            let u = a.match(/(iPad).*OS\s([\d_]+)/);
            const d = a.match(/(iPod)(.*OS\s([\d_]+))?/),
                p = !u && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                f = "Win32" === r;
            let m = "MacIntel" === r;
            return !u && m && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${c}`) >= 0 && (u = a.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), m = !1), h && !f && (s.os = "android", s.android = !0), (u || p || d) && (s.os = "ios", s.ios = !0), s
        }(e)), A
    }

    function P() {
        return C || (C = function() {
            const e = o(),
                t = D();
            let i = !1;

            function n() {
                const t = e.navigator.userAgent.toLowerCase();
                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
            }
            if (n()) {
                const t = String(e.navigator.userAgent);
                if (t.includes("Version/")) {
                    const [e, n] = t.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                    i = e < 16 || 16 === e && n < 2
                }
            }
            const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent),
                a = n();
            return {
                isSafari: i || a,
                needPerspectiveFix: i,
                need3dFix: a || r && t.ios,
                isWebView: r
            }
        }()), C
    }
    var R = {
        on(e, t, i) {
            const n = this;
            if (!n.eventsListeners || n.destroyed) return n;
            if ("function" != typeof t) return n;
            const r = i ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][r](t)
            })), n
        },
        once(e, t, i) {
            const n = this;
            if (!n.eventsListeners || n.destroyed) return n;
            if ("function" != typeof t) return n;

            function r() {
                n.off(e, r), r.__emitterProxy && delete r.__emitterProxy;
                for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++) o[a] = arguments[a];
                t.apply(n, o)
            }
            return r.__emitterProxy = t, n.on(e, r, i)
        },
        onAny(e, t) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof e) return i;
            const n = t ? "unshift" : "push";
            return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i
        },
        offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const i = t.eventsAnyListeners.indexOf(e);
            return i >= 0 && t.eventsAnyListeners.splice(i, 1), t
        },
        off(e, t) {
            const i = this;
            return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((n, r) => {
                    (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1)
                }))
            })), i) : i
        },
        emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, i, n;
            for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++) o[a] = arguments[a];
            return "string" == typeof o[0] || Array.isArray(o[0]) ? (t = o[0], i = o.slice(1, o.length), n = e) : (t = o[0].events, i = o[0].data, n = o[0].context || e), i.unshift(n), (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(n, [t, ...i])
                })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(n, i)
                }))
            })), e
        }
    };
    const O = (e, t, i) => {
            t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
        },
        I = (e, t, i) => {
            t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
        },
        z = (e, t) => {
            if (!e || e.destroyed || !e.params) return;
            const i = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
            if (i) {
                let t = i.querySelector(`.${e.params.lazyPreloaderClass}`);
                !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => {
                    i.shadowRoot && (t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove())
                }))), t && t.remove()
            }
        },
        N = (e, t) => {
            if (!e.slides[t]) return;
            const i = e.slides[t].querySelector('[loading="lazy"]');
            i && i.removeAttribute("loading")
        },
        B = e => {
            if (!e || e.destroyed || !e.params) return;
            let t = e.params.lazyPreloadPrevNext;
            const i = e.slides.length;
            if (!i || !t || t < 0) return;
            t = Math.min(t, i);
            const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
                r = e.activeIndex;
            if (e.params.grid && e.params.grid.rows > 1) {
                const i = r,
                    o = [i - t];
                return o.push(...Array.from({
                    length: t
                }).map(((e, t) => i + n + t))), void e.slides.forEach(((t, i) => {
                    o.includes(t.column) && N(e, i)
                }))
            }
            const o = r + n - 1;
            if (e.params.rewind || e.params.loop)
                for (let n = r - t; n <= o + t; n += 1) {
                    const t = (n % i + i) % i;
                    (t < r || t > o) && N(e, t)
                } else
                    for (let n = Math.max(r - t, 0); n <= Math.min(o + t, i - 1); n += 1) n !== r && (n > o || n < r) && N(e, n)
        };
    var F = {
            updateSize: function() {
                const e = this;
                let t, i;
                const n = e.el;
                t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(b(n, "padding-left") || 0, 10) - parseInt(b(n, "padding-right") || 0, 10), i = i - parseInt(b(n, "padding-top") || 0, 10) - parseInt(b(n, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, {
                    width: t,
                    height: i,
                    size: e.isHorizontal() ? t : i
                }))
            },
            updateSlides: function() {
                const e = this;

                function t(t, i) {
                    return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0)
                }
                const i = e.params,
                    {
                        wrapperEl: n,
                        slidesEl: r,
                        size: o,
                        rtlTranslate: a,
                        wrongRTL: s
                    } = e,
                    l = e.virtual && i.virtual.enabled,
                    c = l ? e.virtual.slides.length : e.slides.length,
                    h = m(r, `.${e.params.slideClass}, swiper-slide`),
                    u = l ? e.virtual.slides.length : h.length;
                let p = [];
                const f = [],
                    g = [];
                let v = i.slidesOffsetBefore;
                "function" == typeof v && (v = i.slidesOffsetBefore.call(e));
                let y = i.slidesOffsetAfter;
                "function" == typeof y && (y = i.slidesOffsetAfter.call(e));
                const x = e.snapGrid.length,
                    w = e.slidesGrid.length;
                let _ = i.spaceBetween,
                    M = -v,
                    T = 0,
                    S = 0;
                if (void 0 === o) return;
                "string" == typeof _ && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * o : "string" == typeof _ && (_ = parseFloat(_)), e.virtualSize = -_, h.forEach((e => {
                    a ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = ""
                })), i.centeredSlides && i.cssMode && (d(n, "--swiper-centered-offset-before", ""), d(n, "--swiper-centered-offset-after", ""));
                const A = i.grid && i.grid.rows > 1 && e.grid;
                let C;
                A ? e.grid.initSlides(h) : e.grid && e.grid.unsetSlides();
                const L = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0;
                for (let n = 0; n < u; n += 1) {
                    let r;
                    if (C = 0, h[n] && (r = h[n]), A && e.grid.updateSlide(n, r, h), !h[n] || "none" !== b(r, "display")) {
                        if ("auto" === i.slidesPerView) {
                            L && (h[n].style[e.getDirectionLabel("width")] = "");
                            const o = getComputedStyle(r),
                                a = r.style.transform,
                                s = r.style.webkitTransform;
                            if (a && (r.style.transform = "none"), s && (r.style.webkitTransform = "none"), i.roundLengths) C = e.isHorizontal() ? E(r, "width", !0) : E(r, "height", !0);
                            else {
                                const e = t(o, "width"),
                                    i = t(o, "padding-left"),
                                    n = t(o, "padding-right"),
                                    a = t(o, "margin-left"),
                                    s = t(o, "margin-right"),
                                    l = o.getPropertyValue("box-sizing");
                                if (l && "border-box" === l) C = e + a + s;
                                else {
                                    const {
                                        clientWidth: t,
                                        offsetWidth: o
                                    } = r;
                                    C = e + i + n + a + s + (o - t)
                                }
                            }
                            a && (r.style.transform = a), s && (r.style.webkitTransform = s), i.roundLengths && (C = Math.floor(C))
                        } else C = (o - (i.slidesPerView - 1) * _) / i.slidesPerView, i.roundLengths && (C = Math.floor(C)), h[n] && (h[n].style[e.getDirectionLabel("width")] = `${C}px`);
                        h[n] && (h[n].swiperSlideSize = C), g.push(C), i.centeredSlides ? (M = M + C / 2 + T / 2 + _, 0 === T && 0 !== n && (M = M - o / 2 - _), 0 === n && (M = M - o / 2 - _), Math.abs(M) < .001 && (M = 0), i.roundLengths && (M = Math.floor(M)), S % i.slidesPerGroup == 0 && p.push(M), f.push(M)) : (i.roundLengths && (M = Math.floor(M)), (S - Math.min(e.params.slidesPerGroupSkip, S)) % e.params.slidesPerGroup == 0 && p.push(M), f.push(M), M = M + C + _), e.virtualSize += C + _, T = C, S += 1
                    }
                }
                if (e.virtualSize = Math.max(e.virtualSize, o) + y, a && s && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = `${e.virtualSize+_}px`), i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = `${e.virtualSize+_}px`), A && e.grid.updateWrapperSize(C, p), !i.centeredSlides) {
                    const t = [];
                    for (let n = 0; n < p.length; n += 1) {
                        let r = p[n];
                        i.roundLengths && (r = Math.floor(r)), p[n] <= e.virtualSize - o && t.push(r)
                    }
                    p = t, Math.floor(e.virtualSize - o) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - o)
                }
                if (l && i.loop) {
                    const t = g[0] + _;
                    if (i.slidesPerGroup > 1) {
                        const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup),
                            r = t * i.slidesPerGroup;
                        for (let e = 0; e < n; e += 1) p.push(p[p.length - 1] + r)
                    }
                    for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1) 1 === i.slidesPerGroup && p.push(p[p.length - 1] + t), f.push(f[f.length - 1] + t), e.virtualSize += t
                }
                if (0 === p.length && (p = [0]), 0 !== _) {
                    const t = e.isHorizontal() && a ? "marginLeft" : e.getDirectionLabel("marginRight");
                    h.filter(((e, t) => !(i.cssMode && !i.loop) || t !== h.length - 1)).forEach((e => {
                        e.style[t] = `${_}px`
                    }))
                }
                if (i.centeredSlides && i.centeredSlidesBounds) {
                    let e = 0;
                    g.forEach((t => {
                        e += t + (_ || 0)
                    })), e -= _;
                    const t = e > o ? e - o : 0;
                    p = p.map((e => e <= 0 ? -v : e > t ? t + y : e))
                }
                if (i.centerInsufficientSlides) {
                    let e = 0;
                    g.forEach((t => {
                        e += t + (_ || 0)
                    })), e -= _;
                    const t = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0);
                    if (e + t < o) {
                        const i = (o - e - t) / 2;
                        p.forEach(((e, t) => {
                            p[t] = e - i
                        })), f.forEach(((e, t) => {
                            f[t] = e + i
                        }))
                    }
                }
                if (Object.assign(e, {
                        slides: h,
                        snapGrid: p,
                        slidesGrid: f,
                        slidesSizesGrid: g
                    }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
                    d(n, "--swiper-centered-offset-before", -p[0] + "px"), d(n, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px");
                    const t = -e.snapGrid[0],
                        i = -e.slidesGrid[0];
                    e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i))
                }
                if (u !== c && e.emit("slidesLengthChange"), p.length !== x && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), f.length !== w && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
                    const t = `${i.containerModifierClass}backface-hidden`,
                        n = e.el.classList.contains(t);
                    u <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t)
                }
            },
            updateAutoHeight: function(e) {
                const t = this,
                    i = [],
                    n = t.virtual && t.params.virtual.enabled;
                let r, o = 0;
                "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                const a = e => n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
                if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                    if (t.params.centeredSlides)(t.visibleSlides || []).forEach((e => {
                        i.push(e)
                    }));
                    else
                        for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                            const e = t.activeIndex + r;
                            if (e > t.slides.length && !n) break;
                            i.push(a(e))
                        } else i.push(a(t.activeIndex));
                for (r = 0; r < i.length; r += 1)
                    if (void 0 !== i[r]) {
                        const e = i[r].offsetHeight;
                        o = e > o ? e : o
                    }(o || 0 === o) && (t.wrapperEl.style.height = `${o}px`)
            },
            updateSlidesOffset: function() {
                const e = this,
                    t = e.slides,
                    i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
                for (let n = 0; n < t.length; n += 1) t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment()
            },
            updateSlidesProgress: function(e) {
                void 0 === e && (e = this && this.translate || 0);
                const t = this,
                    i = t.params,
                    {
                        slides: n,
                        rtlTranslate: r,
                        snapGrid: o
                    } = t;
                if (0 === n.length) return;
                void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset();
                let a = -e;
                r && (a = e), t.visibleSlidesIndexes = [], t.visibleSlides = [];
                let s = i.spaceBetween;
                "string" == typeof s && s.indexOf("%") >= 0 ? s = parseFloat(s.replace("%", "")) / 100 * t.size : "string" == typeof s && (s = parseFloat(s));
                for (let e = 0; e < n.length; e += 1) {
                    const l = n[e];
                    let c = l.swiperSlideOffset;
                    i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset);
                    const h = (a + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + s),
                        u = (a - o[0] + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + s),
                        d = -(a - c),
                        p = d + t.slidesSizesGrid[e],
                        f = d >= 0 && d <= t.size - t.slidesSizesGrid[e],
                        m = d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size;
                    m && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e)), O(l, m, i.slideVisibleClass), O(l, f, i.slideFullyVisibleClass), l.progress = r ? -h : h, l.originalProgress = r ? -u : u
                }
            },
            updateProgress: function(e) {
                const t = this;
                if (void 0 === e) {
                    const i = t.rtlTranslate ? -1 : 1;
                    e = t && t.translate && t.translate * i || 0
                }
                const i = t.params,
                    n = t.maxTranslate() - t.minTranslate();
                let {
                    progress: r,
                    isBeginning: o,
                    isEnd: a,
                    progressLoop: s
                } = t;
                const l = o,
                    c = a;
                if (0 === n) r = 0, o = !0, a = !0;
                else {
                    r = (e - t.minTranslate()) / n;
                    const i = Math.abs(e - t.minTranslate()) < 1,
                        s = Math.abs(e - t.maxTranslate()) < 1;
                    o = i || r <= 0, a = s || r >= 1, i && (r = 0), s && (r = 1)
                }
                if (i.loop) {
                    const i = t.getSlideIndexByData(0),
                        n = t.getSlideIndexByData(t.slides.length - 1),
                        r = t.slidesGrid[i],
                        o = t.slidesGrid[n],
                        a = t.slidesGrid[t.slidesGrid.length - 1],
                        l = Math.abs(e);
                    s = l >= r ? (l - r) / a : (l + a - o) / a, s > 1 && (s -= 1)
                }
                Object.assign(t, {
                    progress: r,
                    progressLoop: s,
                    isBeginning: o,
                    isEnd: a
                }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), o && !l && t.emit("reachBeginning toEdge"), a && !c && t.emit("reachEnd toEdge"), (l && !o || c && !a) && t.emit("fromEdge"), t.emit("progress", r)
            },
            updateSlidesClasses: function() {
                const e = this,
                    {
                        slides: t,
                        params: i,
                        slidesEl: n,
                        activeIndex: r
                    } = e,
                    o = e.virtual && i.virtual.enabled,
                    a = e.grid && i.grid && i.grid.rows > 1,
                    s = e => m(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0];
                let l, c, h;
                if (o)
                    if (i.loop) {
                        let t = r - e.virtual.slidesBefore;
                        t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), l = s(`[data-swiper-slide-index="${t}"]`)
                    } else l = s(`[data-swiper-slide-index="${r}"]`);
                else a ? (l = t.find((e => e.column === r)), h = t.find((e => e.column === r + 1)), c = t.find((e => e.column === r - 1))) : l = t[r];
                l && (a || (h = function(e, t) {
                    const i = [];
                    for (; e.nextElementSibling;) {
                        const n = e.nextElementSibling;
                        t ? n.matches(t) && i.push(n) : i.push(n), e = n
                    }
                    return i
                }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && !h && (h = t[0]), c = function(e, t) {
                    const i = [];
                    for (; e.previousElementSibling;) {
                        const n = e.previousElementSibling;
                        t ? n.matches(t) && i.push(n) : i.push(n), e = n
                    }
                    return i
                }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && 0 === !c && (c = t[t.length - 1]))), t.forEach((e => {
                    I(e, e === l, i.slideActiveClass), I(e, e === h, i.slideNextClass), I(e, e === c, i.slidePrevClass)
                })), e.emitSlidesClasses()
            },
            updateActiveIndex: function(e) {
                const t = this,
                    i = t.rtlTranslate ? t.translate : -t.translate,
                    {
                        snapGrid: n,
                        params: r,
                        activeIndex: o,
                        realIndex: a,
                        snapIndex: s
                    } = t;
                let l, c = e;
                const h = e => {
                    let i = e - t.virtual.slidesBefore;
                    return i < 0 && (i = t.virtual.slides.length + i), i >= t.virtual.slides.length && (i -= t.virtual.slides.length), i
                };
                if (void 0 === c && (c = function(e) {
                        const {
                            slidesGrid: t,
                            params: i
                        } = e, n = e.rtlTranslate ? e.translate : -e.translate;
                        let r;
                        for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : n >= t[e] && n < t[e + 1] && (r = e + 1) : n >= t[e] && (r = e);
                        return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0), r
                    }(t)), n.indexOf(i) >= 0) l = n.indexOf(i);
                else {
                    const e = Math.min(r.slidesPerGroupSkip, c);
                    l = e + Math.floor((c - e) / r.slidesPerGroup)
                }
                if (l >= n.length && (l = n.length - 1), c === o && !t.params.loop) return void(l !== s && (t.snapIndex = l, t.emit("snapIndexChange")));
                if (c === o && t.params.loop && t.virtual && t.params.virtual.enabled) return void(t.realIndex = h(c));
                const u = t.grid && r.grid && r.grid.rows > 1;
                let d;
                if (t.virtual && r.virtual.enabled && r.loop) d = h(c);
                else if (u) {
                    const e = t.slides.find((e => e.column === c));
                    let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
                    Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)), d = Math.floor(i / r.grid.rows)
                } else if (t.slides[c]) {
                    const e = t.slides[c].getAttribute("data-swiper-slide-index");
                    d = e ? parseInt(e, 10) : c
                } else d = c;
                Object.assign(t, {
                    previousSnapIndex: s,
                    snapIndex: l,
                    previousRealIndex: a,
                    realIndex: d,
                    previousIndex: o,
                    activeIndex: c
                }), t.initialized && B(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (a !== d && t.emit("realIndexChange"), t.emit("slideChange"))
            },
            updateClickedSlide: function(e, t) {
                const i = this,
                    n = i.params;
                let r = e.closest(`.${n.slideClass}, swiper-slide`);
                !r && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => {
                    !r && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (r = e)
                }));
                let o, a = !1;
                if (r)
                    for (let e = 0; e < i.slides.length; e += 1)
                        if (i.slides[e] === r) {
                            a = !0, o = e;
                            break
                        } if (!r || !a) return i.clickedSlide = void 0, void(i.clickedIndex = void 0);
                i.clickedSlide = r, i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = o, n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
            }
        },
        k = {
            getTranslate: function(e) {
                void 0 === e && (e = this.isHorizontal() ? "x" : "y");
                const {
                    params: t,
                    rtlTranslate: i,
                    translate: n,
                    wrapperEl: r
                } = this;
                if (t.virtualTranslate) return i ? -n : n;
                if (t.cssMode) return n;
                let o = c(r, e);
                return o += this.cssOverflowAdjustment(), i && (o = -o), o || 0
            },
            setTranslate: function(e, t) {
                const i = this,
                    {
                        rtlTranslate: n,
                        params: r,
                        wrapperEl: o,
                        progress: a
                    } = i;
                let s, l = 0,
                    c = 0;
                i.isHorizontal() ? l = n ? -e : e : c = e, r.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : c, r.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(), o.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
                const h = i.maxTranslate() - i.minTranslate();
                s = 0 === h ? 0 : (e - i.minTranslate()) / h, s !== a && i.updateProgress(e), i.emit("setTranslate", i.translate, t)
            },
            minTranslate: function() {
                return -this.snapGrid[0]
            },
            maxTranslate: function() {
                return -this.snapGrid[this.snapGrid.length - 1]
            },
            translateTo: function(e, t, i, n, r) {
                void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0);
                const o = this,
                    {
                        params: a,
                        wrapperEl: s
                    } = o;
                if (o.animating && a.preventInteractionOnTransition) return !1;
                const l = o.minTranslate(),
                    c = o.maxTranslate();
                let h;
                if (h = n && e > l ? l : n && e < c ? c : e, o.updateProgress(h), a.cssMode) {
                    const e = o.isHorizontal();
                    if (0 === t) s[e ? "scrollLeft" : "scrollTop"] = -h;
                    else {
                        if (!o.support.smoothScroll) return p({
                            swiper: o,
                            targetPosition: -h,
                            side: e ? "left" : "top"
                        }), !0;
                        s.scrollTo({
                            [e ? "left" : "top"]: -h,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return 0 === t ? (o.setTransition(0), o.setTranslate(h), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionEnd"))) : (o.setTransition(t), o.setTranslate(h), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function(e) {
                    o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, o.animating = !1, i && o.emit("transitionEnd"))
                }), o.wrapperEl.addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd))), !0
            }
        };

    function U(e) {
        let {
            swiper: t,
            runCallbacks: i,
            direction: n,
            step: r
        } = e;
        const {
            activeIndex: o,
            previousIndex: a
        } = t;
        let s = n;
        if (s || (s = o > a ? "next" : o < a ? "prev" : "reset"), t.emit(`transition${r}`), i && o !== a) {
            if ("reset" === s) return void t.emit(`slideResetTransition${r}`);
            t.emit(`slideChangeTransition${r}`), "next" === s ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`)
        }
    }
    var H = {
            slideTo: function(e, t, i, n, r) {
                void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
                const o = this;
                let a = e;
                a < 0 && (a = 0);
                const {
                    params: s,
                    snapGrid: l,
                    slidesGrid: c,
                    previousIndex: h,
                    activeIndex: u,
                    rtlTranslate: d,
                    wrapperEl: f,
                    enabled: m
                } = o;
                if (!m && !n && !r || o.destroyed || o.animating && s.preventInteractionOnTransition) return !1;
                void 0 === t && (t = o.params.speed);
                const g = Math.min(o.params.slidesPerGroupSkip, a);
                let v = g + Math.floor((a - g) / o.params.slidesPerGroup);
                v >= l.length && (v = l.length - 1);
                const y = -l[v];
                if (s.normalizeSlideIndex)
                    for (let e = 0; e < c.length; e += 1) {
                        const t = -Math.floor(100 * y),
                            i = Math.floor(100 * c[e]),
                            n = Math.floor(100 * c[e + 1]);
                        void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? a = e : t >= i && t < n && (a = e + 1) : t >= i && (a = e)
                    }
                if (o.initialized && a !== u) {
                    if (!o.allowSlideNext && (d ? y > o.translate && y > o.minTranslate() : y < o.translate && y < o.minTranslate())) return !1;
                    if (!o.allowSlidePrev && y > o.translate && y > o.maxTranslate() && (u || 0) !== a) return !1
                }
                let b;
                a !== (h || 0) && i && o.emit("beforeSlideChangeStart"), o.updateProgress(y), b = a > u ? "next" : a < u ? "prev" : "reset";
                const x = o.virtual && o.params.virtual.enabled;
                if ((!x || !r) && (d && -y === o.translate || !d && y === o.translate)) return o.updateActiveIndex(a), s.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), "slide" !== s.effect && o.setTranslate(y), "reset" !== b && (o.transitionStart(i, b), o.transitionEnd(i, b)), !1;
                if (s.cssMode) {
                    const e = o.isHorizontal(),
                        i = d ? y : -y;
                    if (0 === t) x && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), x && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0 ? (o._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => {
                        f[e ? "scrollLeft" : "scrollTop"] = i
                    }))) : f[e ? "scrollLeft" : "scrollTop"] = i, x && requestAnimationFrame((() => {
                        o.wrapperEl.style.scrollSnapType = "", o._immediateVirtual = !1
                    }));
                    else {
                        if (!o.support.smoothScroll) return p({
                            swiper: o,
                            targetPosition: i,
                            side: e ? "left" : "top"
                        }), !0;
                        f.scrollTo({
                            [e ? "left" : "top"]: i,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                const w = P().isSafari;
                return x && !r && w && o.isElement && o.virtual.update(!1, !1, a), o.setTransition(t), o.setTranslate(y), o.updateActiveIndex(a), o.updateSlidesClasses(), o.emit("beforeTransitionStart", t, n), o.transitionStart(i, b), 0 === t ? o.transitionEnd(i, b) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function(e) {
                    o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(i, b))
                }), o.wrapperEl.addEventListener("transitionend", o.onSlideToWrapperTransitionEnd)), !0
            },
            slideToLoop: function(e, t, i, n) {
                void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
                const r = this;
                if (r.destroyed) return;
                void 0 === t && (t = r.params.speed);
                const o = r.grid && r.params.grid && r.params.grid.rows > 1;
                let a = e;
                if (r.params.loop)
                    if (r.virtual && r.params.virtual.enabled) a += r.virtual.slidesBefore;
                    else {
                        let e;
                        if (o) {
                            const t = a * r.params.grid.rows;
                            e = r.slides.find((e => 1 * e.getAttribute("data-swiper-slide-index") === t)).column
                        } else e = r.getSlideIndexByData(a);
                        const t = o ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length,
                            {
                                centeredSlides: i
                            } = r.params;
                        let s = r.params.slidesPerView;
                        "auto" === s ? s = r.slidesPerViewDynamic() : (s = Math.ceil(parseFloat(r.params.slidesPerView, 10)), i && s % 2 == 0 && (s += 1));
                        let l = t - e < s;
                        if (i && (l = l || e < Math.ceil(s / 2)), n && i && "auto" !== r.params.slidesPerView && !o && (l = !1), l) {
                            const n = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
                            r.loopFix({
                                direction: n,
                                slideTo: !0,
                                activeSlideIndex: "next" === n ? e + 1 : e - t + 1,
                                slideRealIndex: "next" === n ? r.realIndex : void 0
                            })
                        }
                        if (o) {
                            const e = a * r.params.grid.rows;
                            a = r.slides.find((t => 1 * t.getAttribute("data-swiper-slide-index") === e)).column
                        } else a = r.getSlideIndexByData(a)
                    } return requestAnimationFrame((() => {
                    r.slideTo(a, t, i, n)
                })), r
            },
            slideNext: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this,
                    {
                        enabled: r,
                        params: o,
                        animating: a
                    } = n;
                if (!r || n.destroyed) return n;
                void 0 === e && (e = n.params.speed);
                let s = o.slidesPerGroup;
                "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (s = Math.max(n.slidesPerViewDynamic("current", !0), 1));
                const l = n.activeIndex < o.slidesPerGroupSkip ? 1 : s,
                    c = n.virtual && o.virtual.enabled;
                if (o.loop) {
                    if (a && !c && o.loopPreventsSliding) return !1;
                    if (n.loopFix({
                            direction: "next"
                        }), n._clientLeft = n.wrapperEl.clientLeft, n.activeIndex === n.slides.length - 1 && o.cssMode) return requestAnimationFrame((() => {
                        n.slideTo(n.activeIndex + l, e, t, i)
                    })), !0
                }
                return o.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i)
            },
            slidePrev: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this,
                    {
                        params: r,
                        snapGrid: o,
                        slidesGrid: a,
                        rtlTranslate: s,
                        enabled: l,
                        animating: c
                    } = n;
                if (!l || n.destroyed) return n;
                void 0 === e && (e = n.params.speed);
                const h = n.virtual && r.virtual.enabled;
                if (r.loop) {
                    if (c && !h && r.loopPreventsSliding) return !1;
                    n.loopFix({
                        direction: "prev"
                    }), n._clientLeft = n.wrapperEl.clientLeft
                }

                function u(e) {
                    return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                }
                const d = u(s ? n.translate : -n.translate),
                    p = o.map((e => u(e))),
                    f = r.freeMode && r.freeMode.enabled;
                let m = o[p.indexOf(d) - 1];
                if (void 0 === m && (r.cssMode || f)) {
                    let e;
                    o.forEach(((t, i) => {
                        d >= t && (e = i)
                    })), void 0 !== e && (m = f ? o[e] : o[e > 0 ? e - 1 : e])
                }
                let g = 0;
                if (void 0 !== m && (g = a.indexOf(m), g < 0 && (g = n.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (g = g - n.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), r.rewind && n.isBeginning) {
                    const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
                    return n.slideTo(r, e, t, i)
                }
                return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame((() => {
                    n.slideTo(g, e, t, i)
                })), !0) : n.slideTo(g, e, t, i)
            },
            slideReset: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this;
                if (!n.destroyed) return void 0 === e && (e = n.params.speed), n.slideTo(n.activeIndex, e, t, i)
            },
            slideToClosest: function(e, t, i, n) {
                void 0 === t && (t = !0), void 0 === n && (n = .5);
                const r = this;
                if (r.destroyed) return;
                void 0 === e && (e = r.params.speed);
                let o = r.activeIndex;
                const a = Math.min(r.params.slidesPerGroupSkip, o),
                    s = a + Math.floor((o - a) / r.params.slidesPerGroup),
                    l = r.rtlTranslate ? r.translate : -r.translate;
                if (l >= r.snapGrid[s]) {
                    const e = r.snapGrid[s];
                    l - e > (r.snapGrid[s + 1] - e) * n && (o += r.params.slidesPerGroup)
                } else {
                    const e = r.snapGrid[s - 1];
                    l - e <= (r.snapGrid[s] - e) * n && (o -= r.params.slidesPerGroup)
                }
                return o = Math.max(o, 0), o = Math.min(o, r.slidesGrid.length - 1), r.slideTo(o, e, t, i)
            },
            slideToClickedSlide: function() {
                const e = this;
                if (e.destroyed) return;
                const {
                    params: t,
                    slidesEl: i
                } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                let r, o = e.clickedIndex;
                const a = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
                if (t.loop) {
                    if (e.animating) return;
                    r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? o < e.loopedSlides - n / 2 || o > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), o = e.getSlideIndex(m(i, `${a}[data-swiper-slide-index="${r}"]`)[0]), s((() => {
                        e.slideTo(o)
                    }))) : e.slideTo(o) : o > e.slides.length - n ? (e.loopFix(), o = e.getSlideIndex(m(i, `${a}[data-swiper-slide-index="${r}"]`)[0]), s((() => {
                        e.slideTo(o)
                    }))) : e.slideTo(o)
                } else e.slideTo(o)
            }
        },
        G = {
            loopCreate: function(e) {
                const t = this,
                    {
                        params: i,
                        slidesEl: n
                    } = t;
                if (!i.loop || t.virtual && t.params.virtual.enabled) return;
                const r = () => {
                        m(n, `.${i.slideClass}, swiper-slide`).forEach(((e, t) => {
                            e.setAttribute("data-swiper-slide-index", t)
                        }))
                    },
                    o = t.grid && i.grid && i.grid.rows > 1,
                    a = i.slidesPerGroup * (o ? i.grid.rows : 1),
                    s = t.slides.length % a != 0,
                    l = o && t.slides.length % i.grid.rows != 0,
                    c = e => {
                        for (let n = 0; n < e; n += 1) {
                            const e = t.isElement ? v("swiper-slide", [i.slideBlankClass]) : v("div", [i.slideClass, i.slideBlankClass]);
                            t.slidesEl.append(e)
                        }
                    };
                s ? (i.loopAddBlankSlides ? (c(a - t.slides.length % a), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : l ? (i.loopAddBlankSlides ? (c(i.grid.rows - t.slides.length % i.grid.rows), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : r(), t.loopFix({
                    slideRealIndex: e,
                    direction: i.centeredSlides ? void 0 : "next"
                })
            },
            loopFix: function(e) {
                let {
                    slideRealIndex: t,
                    slideTo: i = !0,
                    direction: n,
                    setTranslate: r,
                    activeSlideIndex: o,
                    byController: a,
                    byMousewheel: s
                } = void 0 === e ? {} : e;
                const l = this;
                if (!l.params.loop) return;
                l.emit("beforeLoopFix");
                const {
                    slides: c,
                    allowSlidePrev: h,
                    allowSlideNext: u,
                    slidesEl: d,
                    params: p
                } = l, {
                    centeredSlides: f
                } = p;
                if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) return i && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = h, l.allowSlideNext = u, void l.emit("loopFix");
                let m = p.slidesPerView;
                "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)), f && m % 2 == 0 && (m += 1));
                const v = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
                let y = v;
                y % v != 0 && (y += v - y % v), y += p.loopAdditionalSlides, l.loopedSlides = y;
                const b = l.grid && p.grid && p.grid.rows > 1;
                c.length < m + y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : b && "row" === p.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
                const x = [],
                    w = [];
                let _ = l.activeIndex;
                void 0 === o ? o = l.getSlideIndex(c.find((e => e.classList.contains(p.slideActiveClass)))) : _ = o;
                const E = "next" === n || !n,
                    M = "prev" === n || !n;
                let T = 0,
                    S = 0;
                const A = b ? Math.ceil(c.length / p.grid.rows) : c.length,
                    C = (b ? c[o].column : o) + (f && void 0 === r ? -m / 2 + .5 : 0);
                if (C < y) {
                    T = Math.max(y - C, v);
                    for (let e = 0; e < y - C; e += 1) {
                        const t = e - Math.floor(e / A) * A;
                        if (b) {
                            const e = A - t - 1;
                            for (let t = c.length - 1; t >= 0; t -= 1) c[t].column === e && x.push(t)
                        } else x.push(A - t - 1)
                    }
                } else if (C + m > A - y) {
                    S = Math.max(C - (A - 2 * y), v);
                    for (let e = 0; e < S; e += 1) {
                        const t = e - Math.floor(e / A) * A;
                        b ? c.forEach(((e, i) => {
                            e.column === t && w.push(i)
                        })) : w.push(t)
                    }
                }
                if (l.__preventObserver__ = !0, requestAnimationFrame((() => {
                        l.__preventObserver__ = !1
                    })), M && x.forEach((e => {
                        c[e].swiperLoopMoveDOM = !0, d.prepend(c[e]), c[e].swiperLoopMoveDOM = !1
                    })), E && w.forEach((e => {
                        c[e].swiperLoopMoveDOM = !0, d.append(c[e]), c[e].swiperLoopMoveDOM = !1
                    })), l.recalcSlides(), "auto" === p.slidesPerView ? l.updateSlides() : b && (x.length > 0 && M || w.length > 0 && E) && l.slides.forEach(((e, t) => {
                        l.grid.updateSlide(t, e, l.slides)
                    })), p.watchSlidesProgress && l.updateSlidesOffset(), i)
                    if (x.length > 0 && M) {
                        if (void 0 === t) {
                            const e = l.slidesGrid[_],
                                t = l.slidesGrid[_ + T] - e;
                            s ? l.setTranslate(l.translate - t) : (l.slideTo(_ + Math.ceil(T), 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                        } else if (r) {
                            const e = b ? x.length / p.grid.rows : x.length;
                            l.slideTo(l.activeIndex + e, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate
                        }
                    } else if (w.length > 0 && E)
                    if (void 0 === t) {
                        const e = l.slidesGrid[_],
                            t = l.slidesGrid[_ - S] - e;
                        s ? l.setTranslate(l.translate - t) : (l.slideTo(_ - S, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                    } else {
                        const e = b ? w.length / p.grid.rows : w.length;
                        l.slideTo(l.activeIndex - e, 0, !1, !0)
                    } if (l.allowSlidePrev = h, l.allowSlideNext = u, l.controller && l.controller.control && !a) {
                    const e = {
                        slideRealIndex: t,
                        direction: n,
                        setTranslate: r,
                        activeSlideIndex: o,
                        byController: !0
                    };
                    Array.isArray(l.controller.control) ? l.controller.control.forEach((t => {
                        !t.destroyed && t.params.loop && t.loopFix({
                            ...e,
                            slideTo: t.params.slidesPerView === p.slidesPerView && i
                        })
                    })) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                        ...e,
                        slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && i
                    })
                }
                l.emit("loopFix")
            },
            loopDestroy: function() {
                const e = this,
                    {
                        params: t,
                        slidesEl: i
                    } = e;
                if (!t.loop || e.virtual && e.params.virtual.enabled) return;
                e.recalcSlides();
                const n = [];
                e.slides.forEach((e => {
                    const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                    n[t] = e
                })), e.slides.forEach((e => {
                    e.removeAttribute("data-swiper-slide-index")
                })), n.forEach((e => {
                    i.append(e)
                })), e.recalcSlides(), e.slideTo(e.realIndex, 0)
            }
        };

    function j(e, t, i) {
        const n = o(),
            {
                params: r
            } = e,
            a = r.edgeSwipeDetection,
            s = r.edgeSwipeThreshold;
        return !a || !(i <= s || i >= n.innerWidth - s) || "prevent" === a && (t.preventDefault(), !0)
    }

    function V(e) {
        const t = this,
            i = n();
        let r = e;
        r.originalEvent && (r = r.originalEvent);
        const a = t.touchEventsData;
        if ("pointerdown" === r.type) {
            if (null !== a.pointerId && a.pointerId !== r.pointerId) return;
            a.pointerId = r.pointerId
        } else "touchstart" === r.type && 1 === r.targetTouches.length && (a.touchId = r.targetTouches[0].identifier);
        if ("touchstart" === r.type) return void j(t, r, r.targetTouches[0].pageX);
        const {
            params: s,
            touches: c,
            enabled: h
        } = t;
        if (!h) return;
        if (!s.simulateTouch && "mouse" === r.pointerType) return;
        if (t.animating && s.preventInteractionOnTransition) return;
        !t.animating && s.cssMode && s.loop && t.loopFix();
        let u = r.target;
        if ("wrapper" === s.touchEventsTarget && ! function(e, t) {
                const i = o();
                let n = t.contains(e);
                return !n && i.HTMLSlotElement && t instanceof HTMLSlotElement && (n = [...t.assignedElements()].includes(e), n || (n = function(e, t) {
                    const i = [t];
                    for (; i.length > 0;) {
                        const t = i.shift();
                        if (e === t) return !0;
                        i.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : [])
                    }
                }(e, t))), n
            }(u, t.wrapperEl)) return;
        if ("which" in r && 3 === r.which) return;
        if ("button" in r && r.button > 0) return;
        if (a.isTouched && a.isMoved) return;
        const d = !!s.noSwipingClass && "" !== s.noSwipingClass,
            p = r.composedPath ? r.composedPath() : r.path;
        d && r.target && r.target.shadowRoot && p && (u = p[0]);
        const f = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`,
            m = !(!r.target || !r.target.shadowRoot);
        if (s.noSwiping && (m ? function(e, t) {
                return void 0 === t && (t = this),
                    function t(i) {
                        if (!i || i === n() || i === o()) return null;
                        i.assignedSlot && (i = i.assignedSlot);
                        const r = i.closest(e);
                        return r || i.getRootNode ? r || t(i.getRootNode().host) : null
                    }(t)
            }(f, u) : u.closest(f))) return void(t.allowClick = !0);
        if (s.swipeHandler && !u.closest(s.swipeHandler)) return;
        c.currentX = r.pageX, c.currentY = r.pageY;
        const g = c.currentX,
            v = c.currentY;
        if (!j(t, r, g)) return;
        Object.assign(a, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), c.startX = g, c.startY = v, a.touchStartTime = l(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (a.allowThresholdMove = !1);
        let y = !0;
        u.matches(a.focusableElements) && (y = !1, "SELECT" === u.nodeName && (a.isTouched = !1)), i.activeElement && i.activeElement.matches(a.focusableElements) && i.activeElement !== u && ("mouse" === r.pointerType || "mouse" !== r.pointerType && !u.matches(a.focusableElements)) && i.activeElement.blur();
        const b = y && t.allowTouchMove && s.touchStartPreventDefault;
        !s.touchStartForcePreventDefault && !b || u.isContentEditable || r.preventDefault(), s.freeMode && s.freeMode.enabled && t.freeMode && t.animating && !s.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", r)
    }

    function W(e) {
        const t = n(),
            i = this,
            r = i.touchEventsData,
            {
                params: o,
                touches: a,
                rtlTranslate: s,
                enabled: c
            } = i;
        if (!c) return;
        if (!o.simulateTouch && "mouse" === e.pointerType) return;
        let h, u = e;
        if (u.originalEvent && (u = u.originalEvent), "pointermove" === u.type) {
            if (null !== r.touchId) return;
            if (u.pointerId !== r.pointerId) return
        }
        if ("touchmove" === u.type) {
            if (h = [...u.changedTouches].find((e => e.identifier === r.touchId)), !h || h.identifier !== r.touchId) return
        } else h = u;
        if (!r.isTouched) return void(r.startMoving && r.isScrolling && i.emit("touchMoveOpposite", u));
        const d = h.pageX,
            p = h.pageY;
        if (u.preventedByNestedSwiper) return a.startX = d, void(a.startY = p);
        if (!i.allowTouchMove) return u.target.matches(r.focusableElements) || (i.allowClick = !1), void(r.isTouched && (Object.assign(a, {
            startX: d,
            startY: p,
            currentX: d,
            currentY: p
        }), r.touchStartTime = l()));
        if (o.touchReleaseOnEdges && !o.loop)
            if (i.isVertical()) {
                if (p < a.startY && i.translate <= i.maxTranslate() || p > a.startY && i.translate >= i.minTranslate()) return r.isTouched = !1, void(r.isMoved = !1)
            } else if (d < a.startX && i.translate <= i.maxTranslate() || d > a.startX && i.translate >= i.minTranslate()) return;
        if (t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== u.target && "mouse" !== u.pointerType && t.activeElement.blur(), t.activeElement && u.target === t.activeElement && u.target.matches(r.focusableElements)) return r.isMoved = !0, void(i.allowClick = !1);
        r.allowTouchCallbacks && i.emit("touchMove", u), a.previousX = a.currentX, a.previousY = a.currentY, a.currentX = d, a.currentY = p;
        const f = a.currentX - a.startX,
            m = a.currentY - a.startY;
        if (i.params.threshold && Math.sqrt(f ** 2 + m ** 2) < i.params.threshold) return;
        if (void 0 === r.isScrolling) {
            let e;
            i.isHorizontal() && a.currentY === a.startY || i.isVertical() && a.currentX === a.startX ? r.isScrolling = !1 : f * f + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(f)) / Math.PI, r.isScrolling = i.isHorizontal() ? e > o.touchAngle : 90 - e > o.touchAngle)
        }
        if (r.isScrolling && i.emit("touchMoveOpposite", u), void 0 === r.startMoving && (a.currentX === a.startX && a.currentY === a.startY || (r.startMoving = !0)), r.isScrolling || "touchmove" === u.type && r.preventTouchMoveFromPointerMove) return void(r.isTouched = !1);
        if (!r.startMoving) return;
        i.allowClick = !1, !o.cssMode && u.cancelable && u.preventDefault(), o.touchMoveStopPropagation && !o.nested && u.stopPropagation();
        let g = i.isHorizontal() ? f : m,
            v = i.isHorizontal() ? a.currentX - a.previousX : a.currentY - a.previousY;
        o.oneWayMovement && (g = Math.abs(g) * (s ? 1 : -1), v = Math.abs(v) * (s ? 1 : -1)), a.diff = g, g *= o.touchRatio, s && (g = -g, v = -v);
        const y = i.touchesDirection;
        i.swipeDirection = g > 0 ? "prev" : "next", i.touchesDirection = v > 0 ? "prev" : "next";
        const b = i.params.loop && !o.cssMode,
            x = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
        if (!r.isMoved) {
            if (b && x && i.loopFix({
                    direction: i.swipeDirection
                }), r.startTranslate = i.getTranslate(), i.setTransition(0), i.animating) {
                const e = new window.CustomEvent("transitionend", {
                    bubbles: !0,
                    cancelable: !0,
                    detail: {
                        bySwiperTouchMove: !0
                    }
                });
                i.wrapperEl.dispatchEvent(e)
            }
            r.allowMomentumBounce = !1, !o.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", u)
        }
        if ((new Date).getTime(), !1 !== o._loopSwapReset && r.isMoved && r.allowThresholdMove && y !== i.touchesDirection && b && x && Math.abs(g) >= 1) return Object.assign(a, {
            startX: d,
            startY: p,
            currentX: d,
            currentY: p,
            startTranslate: r.currentTranslate
        }), r.loopSwapReset = !0, void(r.startTranslate = r.currentTranslate);
        i.emit("sliderMove", u), r.isMoved = !0, r.currentTranslate = g + r.startTranslate;
        let w = !0,
            _ = o.resistanceRatio;
        if (o.touchReleaseOnEdges && (_ = 0), g > 0 ? (b && x && r.allowThresholdMove && r.currentTranslate > (o.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] - ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.activeIndex + 1] + i.params.spaceBetween : 0) - i.params.spaceBetween : i.minTranslate()) && i.loopFix({
                direction: "prev",
                setTranslate: !0,
                activeSlideIndex: 0
            }), r.currentTranslate > i.minTranslate() && (w = !1, o.resistance && (r.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + r.startTranslate + g) ** _))) : g < 0 && (b && x && r.allowThresholdMove && r.currentTranslate < (o.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween + ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween : 0) : i.maxTranslate()) && i.loopFix({
                direction: "next",
                setTranslate: !0,
                activeSlideIndex: i.slides.length - ("auto" === o.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(o.slidesPerView, 10)))
            }), r.currentTranslate < i.maxTranslate() && (w = !1, o.resistance && (r.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - r.startTranslate - g) ** _))), w && (u.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), i.allowSlidePrev || i.allowSlideNext || (r.currentTranslate = r.startTranslate), o.threshold > 0) {
            if (!(Math.abs(g) > o.threshold || r.allowThresholdMove)) return void(r.currentTranslate = r.startTranslate);
            if (!r.allowThresholdMove) return r.allowThresholdMove = !0, a.startX = a.currentX, a.startY = a.currentY, r.currentTranslate = r.startTranslate, void(a.diff = i.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY)
        }
        o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && i.freeMode || o.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), o.freeMode && o.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(r.currentTranslate), i.setTranslate(r.currentTranslate))
    }

    function q(e) {
        const t = this,
            i = t.touchEventsData;
        let n, r = e;
        if (r.originalEvent && (r = r.originalEvent), "touchend" === r.type || "touchcancel" === r.type) {
            if (n = [...r.changedTouches].find((e => e.identifier === i.touchId)), !n || n.identifier !== i.touchId) return
        } else {
            if (null !== i.touchId) return;
            if (r.pointerId !== i.pointerId) return;
            n = r
        }
        if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && (!["pointercancel", "contextmenu"].includes(r.type) || !t.browser.isSafari && !t.browser.isWebView)) return;
        i.pointerId = null, i.touchId = null;
        const {
            params: o,
            touches: a,
            rtlTranslate: c,
            slidesGrid: h,
            enabled: u
        } = t;
        if (!u) return;
        if (!o.simulateTouch && "mouse" === r.pointerType) return;
        if (i.allowTouchCallbacks && t.emit("touchEnd", r), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && o.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
        o.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const d = l(),
            p = d - i.touchStartTime;
        if (t.allowClick) {
            const e = r.path || r.composedPath && r.composedPath();
            t.updateClickedSlide(e && e[0] || r.target, e), t.emit("tap click", r), p < 300 && d - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", r)
        }
        if (i.lastClickTime = l(), s((() => {
                t.destroyed || (t.allowClick = !0)
            })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === a.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
        let f;
        if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, f = o.followFinger ? c ? t.translate : -t.translate : -i.currentTranslate, o.cssMode) return;
        if (o.freeMode && o.freeMode.enabled) return void t.freeMode.onTouchEnd({
            currentPos: f
        });
        const m = f >= -t.maxTranslate() && !t.params.loop;
        let g = 0,
            v = t.slidesSizesGrid[0];
        for (let e = 0; e < h.length; e += e < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) {
            const t = e < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
            void 0 !== h[e + t] ? (m || f >= h[e] && f < h[e + t]) && (g = e, v = h[e + t] - h[e]) : (m || f >= h[e]) && (g = e, v = h[h.length - 1] - h[h.length - 2])
        }
        let y = null,
            b = null;
        o.rewind && (t.isBeginning ? b = o.virtual && o.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (y = 0));
        const x = (f - h[g]) / v,
            w = g < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
        if (p > o.longSwipesMs) {
            if (!o.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (x >= o.longSwipesRatio ? t.slideTo(o.rewind && t.isEnd ? y : g + w) : t.slideTo(g)), "prev" === t.swipeDirection && (x > 1 - o.longSwipesRatio ? t.slideTo(g + w) : null !== b && x < 0 && Math.abs(x) > o.longSwipesRatio ? t.slideTo(b) : t.slideTo(g))
        } else {
            if (!o.shortSwipes) return void t.slideTo(t.activeIndex);
            !t.navigation || r.target !== t.navigation.nextEl && r.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== y ? y : g + w), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g)) : r.target === t.navigation.nextEl ? t.slideTo(g + w) : t.slideTo(g)
        }
    }

    function X() {
        const e = this,
            {
                params: t,
                el: i
            } = e;
        if (i && 0 === i.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {
            allowSlideNext: n,
            allowSlidePrev: r,
            snapGrid: o
        } = e, a = e.virtual && e.params.virtual.enabled;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
        const s = a && t.loop;
        !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || s ? e.params.loop && !a ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => {
            e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
        }), 500)), e.allowSlidePrev = r, e.allowSlideNext = n, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow()
    }

    function Y(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function Z() {
        const e = this,
            {
                wrapperEl: t,
                rtlTranslate: i,
                enabled: n
            } = e;
        if (!n) return;
        let r;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const o = e.maxTranslate() - e.minTranslate();
        r = 0 === o ? 0 : (e.translate - e.minTranslate()) / o, r !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    function J(e) {
        const t = this;
        z(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
    }

    function Q() {
        const e = this;
        e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
    }
    const $ = (e, t) => {
            const i = n(),
                {
                    params: r,
                    el: o,
                    wrapperEl: a,
                    device: s
                } = e,
                l = !!r.nested,
                c = "on" === t ? "addEventListener" : "removeEventListener",
                h = t;
            o && "string" != typeof o && (i[c]("touchstart", e.onDocumentTouchStart, {
                passive: !1,
                capture: l
            }), o[c]("touchstart", e.onTouchStart, {
                passive: !1
            }), o[c]("pointerdown", e.onTouchStart, {
                passive: !1
            }), i[c]("touchmove", e.onTouchMove, {
                passive: !1,
                capture: l
            }), i[c]("pointermove", e.onTouchMove, {
                passive: !1,
                capture: l
            }), i[c]("touchend", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerup", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointercancel", e.onTouchEnd, {
                passive: !0
            }), i[c]("touchcancel", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerout", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerleave", e.onTouchEnd, {
                passive: !0
            }), i[c]("contextmenu", e.onTouchEnd, {
                passive: !0
            }), (r.preventClicks || r.preventClicksPropagation) && o[c]("click", e.onClick, !0), r.cssMode && a[c]("scroll", e.onScroll), r.updateOnWindowResize ? e[h](s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", X, !0) : e[h]("observerUpdate", X, !0), o[c]("load", e.onLoad, {
                capture: !0
            }))
        },
        K = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var ee = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        swiperElementNodeName: "SWIPER-CONTAINER",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        eventsPrefix: "swiper",
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopAddBlankSlides: !0,
        loopAdditionalSlides: 0,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-blank",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideFullyVisibleClass: "swiper-slide-fully-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function te(e, t) {
        return function(i) {
            void 0 === i && (i = {});
            const n = Object.keys(i)[0],
                r = i[n];
            "object" == typeof r && null !== r ? (!0 === e[n] && (e[n] = {
                enabled: !0
            }), "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0), ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0), n in e && "enabled" in r ? ("object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = {
                enabled: !1
            }), u(t, i)) : u(t, i)) : u(t, i)
        }
    }
    const ie = {
            eventsEmitter: R,
            update: F,
            translate: k,
            transition: {
                setTransition: function(e, t) {
                    const i = this;
                    i.params.cssMode || (i.wrapperEl.style.transitionDuration = `${e}ms`, i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), i.emit("setTransition", e, t)
                },
                transitionStart: function(e, t) {
                    void 0 === e && (e = !0);
                    const i = this,
                        {
                            params: n
                        } = i;
                    n.cssMode || (n.autoHeight && i.updateAutoHeight(), U({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "Start"
                    }))
                },
                transitionEnd: function(e, t) {
                    void 0 === e && (e = !0);
                    const i = this,
                        {
                            params: n
                        } = i;
                    i.animating = !1, n.cssMode || (i.setTransition(0), U({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "End"
                    }))
                }
            },
            slide: H,
            loop: G,
            grabCursor: {
                setGrabCursor: function(e) {
                    const t = this;
                    if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                    const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                    t.isElement && (t.__preventObserver__ = !0), i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => {
                        t.__preventObserver__ = !1
                    }))
                },
                unsetGrabCursor: function() {
                    const e = this;
                    e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => {
                        e.__preventObserver__ = !1
                    })))
                }
            },
            events: {
                attachEvents: function() {
                    const e = this,
                        {
                            params: t
                        } = e;
                    e.onTouchStart = V.bind(e), e.onTouchMove = W.bind(e), e.onTouchEnd = q.bind(e), e.onDocumentTouchStart = Q.bind(e), t.cssMode && (e.onScroll = Z.bind(e)), e.onClick = Y.bind(e), e.onLoad = J.bind(e), $(e, "on")
                },
                detachEvents: function() {
                    $(this, "off")
                }
            },
            breakpoints: {
                setBreakpoint: function() {
                    const e = this,
                        {
                            realIndex: t,
                            initialized: i,
                            params: r,
                            el: o
                        } = e,
                        a = r.breakpoints;
                    if (!a || a && 0 === Object.keys(a).length) return;
                    const s = n(),
                        l = "window" !== r.breakpointsBase && r.breakpointsBase ? "container" : r.breakpointsBase,
                        c = ["window", "container"].includes(r.breakpointsBase) || !r.breakpointsBase ? e.el : s.querySelector(r.breakpointsBase),
                        h = e.getBreakpoint(a, l, c);
                    if (!h || e.currentBreakpoint === h) return;
                    const d = (h in a ? a[h] : void 0) || e.originalParams,
                        p = K(e, r),
                        f = K(e, d),
                        m = e.params.grabCursor,
                        g = d.grabCursor,
                        v = r.enabled;
                    p && !f ? (o.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`), e.emitContainerClasses()) : !p && f && (o.classList.add(`${r.containerModifierClass}grid`), (d.grid.fill && "column" === d.grid.fill || !d.grid.fill && "column" === r.grid.fill) && o.classList.add(`${r.containerModifierClass}grid-column`), e.emitContainerClasses()), m && !g ? e.unsetGrabCursor() : !m && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach((t => {
                        if (void 0 === d[t]) return;
                        const i = r[t] && r[t].enabled,
                            n = d[t] && d[t].enabled;
                        i && !n && e[t].disable(), !i && n && e[t].enable()
                    }));
                    const y = d.direction && d.direction !== r.direction,
                        b = r.loop && (d.slidesPerView !== r.slidesPerView || y),
                        x = r.loop;
                    y && i && e.changeDirection(), u(e.params, d);
                    const w = e.params.enabled,
                        _ = e.params.loop;
                    Object.assign(e, {
                        allowTouchMove: e.params.allowTouchMove,
                        allowSlideNext: e.params.allowSlideNext,
                        allowSlidePrev: e.params.allowSlidePrev
                    }), v && !w ? e.disable() : !v && w && e.enable(), e.currentBreakpoint = h, e.emit("_beforeBreakpoint", d), i && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !x && _ ? (e.loopCreate(t), e.updateSlides()) : x && !_ && e.loopDestroy()), e.emit("breakpoint", d)
                },
                getBreakpoint: function(e, t, i) {
                    if (void 0 === t && (t = "window"), !e || "container" === t && !i) return;
                    let n = !1;
                    const r = o(),
                        a = "window" === t ? r.innerHeight : i.clientHeight,
                        s = Object.keys(e).map((e => {
                            if ("string" == typeof e && 0 === e.indexOf("@")) {
                                const t = parseFloat(e.substr(1));
                                return {
                                    value: a * t,
                                    point: e
                                }
                            }
                            return {
                                value: e,
                                point: e
                            }
                        }));
                    s.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                    for (let e = 0; e < s.length; e += 1) {
                        const {
                            point: o,
                            value: a
                        } = s[e];
                        "window" === t ? r.matchMedia(`(min-width: ${a}px)`).matches && (n = o) : a <= i.clientWidth && (n = o)
                    }
                    return n || "max"
                }
            },
            checkOverflow: {
                checkOverflow: function() {
                    const e = this,
                        {
                            isLocked: t,
                            params: i
                        } = e,
                        {
                            slidesOffsetBefore: n
                        } = i;
                    if (n) {
                        const t = e.slides.length - 1,
                            i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n;
                        e.isLocked = e.size > i
                    } else e.isLocked = 1 === e.snapGrid.length;
                    !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                }
            },
            classes: {
                addClasses: function() {
                    const e = this,
                        {
                            classNames: t,
                            params: i,
                            rtl: n,
                            el: r,
                            device: o
                        } = e,
                        a = function(e, t) {
                            const i = [];
                            return e.forEach((e => {
                                "object" == typeof e ? Object.keys(e).forEach((n => {
                                    e[n] && i.push(t + n)
                                })) : "string" == typeof e && i.push(t + e)
                            })), i
                        }(["initialized", i.direction, {
                            "free-mode": e.params.freeMode && i.freeMode.enabled
                        }, {
                            autoheight: i.autoHeight
                        }, {
                            rtl: n
                        }, {
                            grid: i.grid && i.grid.rows > 1
                        }, {
                            "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                        }, {
                            android: o.android
                        }, {
                            ios: o.ios
                        }, {
                            "css-mode": i.cssMode
                        }, {
                            centered: i.cssMode && i.centeredSlides
                        }, {
                            "watch-progress": i.watchSlidesProgress
                        }], i.containerModifierClass);
                    t.push(...a), r.classList.add(...t), e.emitContainerClasses()
                },
                removeClasses: function() {
                    const {
                        el: e,
                        classNames: t
                    } = this;
                    e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses())
                }
            }
        },
        ne = {};
    class re {
        constructor() {
            let e, t;
            for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++) r[o] = arguments[o];
            1 === r.length && r[0].constructor && "Object" === Object.prototype.toString.call(r[0]).slice(8, -1) ? t = r[0] : [e, t] = r, t || (t = {}), t = u({}, t), e && !t.el && (t.el = e);
            const a = n();
            if (t.el && "string" == typeof t.el && a.querySelectorAll(t.el).length > 1) {
                const e = [];
                return a.querySelectorAll(t.el).forEach((i => {
                    const n = u({}, t, {
                        el: i
                    });
                    e.push(new re(n))
                })), e
            }
            const s = this;
            s.__swiper__ = !0, s.support = L(), s.device = D({
                userAgent: t.userAgent
            }), s.browser = P(), s.eventsListeners = {}, s.eventsAnyListeners = [], s.modules = [...s.__modules__], t.modules && Array.isArray(t.modules) && s.modules.push(...t.modules);
            const l = {};
            s.modules.forEach((e => {
                e({
                    params: t,
                    swiper: s,
                    extendParams: te(t, l),
                    on: s.on.bind(s),
                    once: s.once.bind(s),
                    off: s.off.bind(s),
                    emit: s.emit.bind(s)
                })
            }));
            const c = u({}, ee, l);
            return s.params = u({}, c, ne, t), s.originalParams = u({}, s.params), s.passedParams = u({}, t), s.params && s.params.on && Object.keys(s.params.on).forEach((e => {
                s.on(e, s.params.on[e])
            })), s.params && s.params.onAny && s.onAny(s.params.onAny), Object.assign(s, {
                enabled: s.params.enabled,
                el: e,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === s.params.direction,
                isVertical: () => "vertical" === s.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: s.params.allowSlideNext,
                allowSlidePrev: s.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: s.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    pointerId: null,
                    touchId: null
                },
                allowClick: !0,
                allowTouchMove: s.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), s.emit("_swiper"), s.params.init && s.init(), s
        }
        getDirectionLabel(e) {
            return this.isHorizontal() ? e : {
                width: "height",
                "margin-top": "margin-left",
                "margin-bottom ": "margin-right",
                "margin-left": "margin-top",
                "margin-right": "margin-bottom",
                "padding-left": "padding-top",
                "padding-right": "padding-bottom",
                marginRight: "marginBottom"
            } [e]
        }
        getSlideIndex(e) {
            const {
                slidesEl: t,
                params: i
            } = this, n = x(m(t, `.${i.slideClass}, swiper-slide`)[0]);
            return x(e) - n
        }
        getSlideIndexByData(e) {
            return this.getSlideIndex(this.slides.find((t => 1 * t.getAttribute("data-swiper-slide-index") === e)))
        }
        recalcSlides() {
            const {
                slidesEl: e,
                params: t
            } = this;
            this.slides = m(e, `.${t.slideClass}, swiper-slide`)
        }
        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }
        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }
        setProgress(e, t) {
            const i = this;
            e = Math.min(Math.max(e, 0), 1);
            const n = i.minTranslate(),
                r = (i.maxTranslate() - n) * e + n;
            i.translateTo(r, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
        }
        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }
        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }
        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.forEach((i => {
                const n = e.getSlideClasses(i);
                t.push({
                    slideEl: i,
                    classNames: n
                }), e.emit("_slideClass", i, n)
            })), e.emit("_slideClasses", t)
        }
        slidesPerViewDynamic(e, t) {
            void 0 === e && (e = "current"), void 0 === t && (t = !1);
            const {
                params: i,
                slides: n,
                slidesGrid: r,
                slidesSizesGrid: o,
                size: a,
                activeIndex: s
            } = this;
            let l = 1;
            if ("number" == typeof i.slidesPerView) return i.slidesPerView;
            if (i.centeredSlides) {
                let e, t = n[s] ? Math.ceil(n[s].swiperSlideSize) : 0;
                for (let i = s + 1; i < n.length; i += 1) n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize), l += 1, t > a && (e = !0));
                for (let i = s - 1; i >= 0; i -= 1) n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > a && (e = !0))
            } else if ("current" === e)
                for (let e = s + 1; e < n.length; e += 1)(t ? r[e] + o[e] - r[s] < a : r[e] - r[s] < a) && (l += 1);
            else
                for (let e = s - 1; e >= 0; e -= 1) r[s] - r[e] < a && (l += 1);
            return l
        }
        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {
                snapGrid: t,
                params: i
            } = e;

            function n() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
            }
            let r;
            if (i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => {
                    t.complete && z(e, t)
                })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i.freeMode && i.freeMode.enabled && !i.cssMode) n(), i.autoHeight && e.updateAutoHeight();
            else {
                if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
                    const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
                    r = e.slideTo(t.length - 1, 0, !1, !0)
                } else r = e.slideTo(e.activeIndex, 0, !1, !0);
                r || n()
            }
            i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }
        changeDirection(e, t) {
            void 0 === t && (t = !0);
            const i = this,
                n = i.params.direction;
            return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach((t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            })), i.emit("changeDirection"), t && i.update()), i
        }
        changeLanguageDirection(e) {
            const t = this;
            t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
        }
        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            let i = e || t.params.el;
            if ("string" == typeof i && (i = document.querySelector(i)), !i) return !1;
            i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
            const n = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
            let r = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : m(i, n())[0];
            return !r && t.params.createElements && (r = v("div", t.params.wrapperClass), i.append(r), m(i, `.${t.params.slideClass}`).forEach((e => {
                r.append(e)
            }))), Object.assign(t, {
                el: i,
                wrapperEl: r,
                slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
                hostEl: t.isElement ? i.parentNode.host : i,
                mounted: !0,
                rtl: "rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction")),
                wrongRTL: "-webkit-box" === b(r, "display")
            }), !0
        }
        init(e) {
            const t = this;
            if (t.initialized) return t;
            if (!1 === t.mount(e)) return t;
            t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
            const i = [...t.el.querySelectorAll('[loading="lazy"]')];
            return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach((e => {
                e.complete ? z(t, e) : e.addEventListener("load", (e => {
                    z(t, e.target)
                }))
            })), B(t), t.initialized = !0, B(t), t.emit("init"), t.emit("afterInit"), t
        }
        destroy(e, t) {
            void 0 === e && (e = !0), void 0 === t && (t = !0);
            const i = this,
                {
                    params: n,
                    el: r,
                    wrapperEl: o,
                    slides: a
                } = i;
            return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), r && "string" != typeof r && r.removeAttribute("style"), o && o.removeAttribute("style"), a && a.length && a.forEach((e => {
                e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index")
            }))), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => {
                i.off(e)
            })), !1 !== e && (i.el && "string" != typeof i.el && (i.el.swiper = null), function(e) {
                const t = e;
                Object.keys(t).forEach((e => {
                    try {
                        t[e] = null
                    } catch (e) {}
                    try {
                        delete t[e]
                    } catch (e) {}
                }))
            }(i)), i.destroyed = !0), null
        }
        static extendDefaults(e) {
            u(ne, e)
        }
        static get extendedDefaults() {
            return ne
        }
        static get defaults() {
            return ee
        }
        static installModule(e) {
            re.prototype.__modules__ || (re.prototype.__modules__ = []);
            const t = re.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }
        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => re.installModule(e))), re) : (re.installModule(e), re)
        }
    }

    function oe(e, t, i, n) {
        return e.params.createElements && Object.keys(n).forEach((r => {
            if (!i[r] && !0 === i.auto) {
                let o = m(e.el, `.${n[r]}`)[0];
                o || (o = v("div", n[r]), o.className = n[r], e.el.append(o)), i[r] = o, t[r] = o
            }
        })), i
    }

    function ae(e) {
        return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g,"\\$1").replace(/ /g,".")}`
    }

    function se(e) {
        const t = this,
            {
                params: i,
                slidesEl: n
            } = t;
        i.loop && t.loopDestroy();
        const r = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, n.append(t.children[0]), t.innerHTML = ""
            } else n.append(e)
        };
        if ("object" == typeof e && "length" in e)
            for (let t = 0; t < e.length; t += 1) e[t] && r(e[t]);
        else r(e);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update()
    }

    function le(e) {
        const t = this,
            {
                params: i,
                activeIndex: n,
                slidesEl: r
            } = t;
        i.loop && t.loopDestroy();
        let o = n + 1;
        const a = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, r.prepend(t.children[0]), t.innerHTML = ""
            } else r.prepend(e)
        };
        if ("object" == typeof e && "length" in e) {
            for (let t = 0; t < e.length; t += 1) e[t] && a(e[t]);
            o = n + e.length
        } else a(e);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), t.slideTo(o, 0, !1)
    }

    function ce(e, t) {
        const i = this,
            {
                params: n,
                activeIndex: r,
                slidesEl: o
            } = i;
        let a = r;
        n.loop && (a -= i.loopedSlides, i.loopDestroy(), i.recalcSlides());
        const s = i.slides.length;
        if (e <= 0) return void i.prependSlide(t);
        if (e >= s) return void i.appendSlide(t);
        let l = a > e ? a + 1 : a;
        const c = [];
        for (let t = s - 1; t >= e; t -= 1) {
            const e = i.slides[t];
            e.remove(), c.unshift(e)
        }
        if ("object" == typeof t && "length" in t) {
            for (let e = 0; e < t.length; e += 1) t[e] && o.append(t[e]);
            l = a > e ? a + t.length : a
        } else o.append(t);
        for (let e = 0; e < c.length; e += 1) o.append(c[e]);
        i.recalcSlides(), n.loop && i.loopCreate(), n.observer && !i.isElement || i.update(), n.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1)
    }

    function he(e) {
        const t = this,
            {
                params: i,
                activeIndex: n
            } = t;
        let r = n;
        i.loop && (r -= t.loopedSlides, t.loopDestroy());
        let o, a = r;
        if ("object" == typeof e && "length" in e) {
            for (let i = 0; i < e.length; i += 1) o = e[i], t.slides[o] && t.slides[o].remove(), o < a && (a -= 1);
            a = Math.max(a, 0)
        } else o = e, t.slides[o] && t.slides[o].remove(), o < a && (a -= 1), a = Math.max(a, 0);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), i.loop ? t.slideTo(a + t.loopedSlides, 0, !1) : t.slideTo(a, 0, !1)
    }

    function ue() {
        const e = this,
            t = [];
        for (let i = 0; i < e.slides.length; i += 1) t.push(i);
        e.removeSlide(t)
    }

    function de(e) {
        const {
            effect: t,
            swiper: i,
            on: n,
            setTranslate: r,
            setTransition: o,
            overwriteParams: a,
            perspective: s,
            recreateShadows: l,
            getEffectParams: c
        } = e;
        let h;
        n("beforeInit", (() => {
            if (i.params.effect !== t) return;
            i.classNames.push(`${i.params.containerModifierClass}${t}`), s && s() && i.classNames.push(`${i.params.containerModifierClass}3d`);
            const e = a ? a() : {};
            Object.assign(i.params, e), Object.assign(i.originalParams, e)
        })), n("setTranslate", (() => {
            i.params.effect === t && r()
        })), n("setTransition", ((e, n) => {
            i.params.effect === t && o(n)
        })), n("transitionEnd", (() => {
            if (i.params.effect === t && l) {
                if (!c || !c().slideShadows) return;
                i.slides.forEach((e => {
                    e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((e => e.remove()))
                })), l()
            }
        })), n("virtualUpdate", (() => {
            i.params.effect === t && (i.slides.length || (h = !0), requestAnimationFrame((() => {
                h && i.slides && i.slides.length && (r(), h = !1)
            })))
        }))
    }

    function pe(e, t) {
        const i = f(t);
        return i !== t && (i.style.backfaceVisibility = "hidden", i.style["-webkit-backface-visibility"] = "hidden"), i
    }

    function fe(e) {
        let {
            swiper: t,
            duration: i,
            transformElements: n,
            allSlides: r
        } = e;
        const {
            activeIndex: o
        } = t;
        if (t.params.virtualTranslate && 0 !== i) {
            let e, i = !1;
            e = r ? n : n.filter((e => {
                const i = e.classList.contains("swiper-slide-transform") ? (e => e.parentElement ? e.parentElement : t.slides.find((t => t.shadowRoot && t.shadowRoot === e.parentNode)))(e) : e;
                return t.getSlideIndex(i) === o
            })), e.forEach((e => {
                _(e, (() => {
                    if (i) return;
                    if (!t || t.destroyed) return;
                    i = !0, t.animating = !1;
                    const e = new window.CustomEvent("transitionend", {
                        bubbles: !0,
                        cancelable: !0
                    });
                    t.wrapperEl.dispatchEvent(e)
                }))
            }))
        }
    }

    function me(e, t, i) {
        const n = `swiper-slide-shadow${i?`-${i}`:""}${e?` swiper-slide-shadow-${e}`:""}`,
            r = f(t);
        let o = r.querySelector(`.${n.split(" ").join(".")}`);
        return o || (o = v("div", n.split(" ")), r.append(o)), o
    }
    Object.keys(ie).forEach((e => {
        Object.keys(ie[e]).forEach((t => {
            re.prototype[t] = ie[e][t]
        }))
    })), re.use([function(e) {
        let {
            swiper: t,
            on: i,
            emit: n
        } = e;
        const r = o();
        let a = null,
            s = null;
        const l = () => {
                t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize"))
            },
            c = () => {
                t && !t.destroyed && t.initialized && n("orientationchange")
            };
        i("init", (() => {
            t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (a = new ResizeObserver((e => {
                s = r.requestAnimationFrame((() => {
                    const {
                        width: i,
                        height: n
                    } = t;
                    let r = i,
                        o = n;
                    e.forEach((e => {
                        let {
                            contentBoxSize: i,
                            contentRect: n,
                            target: a
                        } = e;
                        a && a !== t.el || (r = n ? n.width : (i[0] || i).inlineSize, o = n ? n.height : (i[0] || i).blockSize)
                    })), r === i && o === n || l()
                }))
            })), a.observe(t.el)) : (r.addEventListener("resize", l), r.addEventListener("orientationchange", c))
        })), i("destroy", (() => {
            s && r.cancelAnimationFrame(s), a && a.unobserve && t.el && (a.unobserve(t.el), a = null), r.removeEventListener("resize", l), r.removeEventListener("orientationchange", c)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const a = [],
            s = o(),
            l = function(e, i) {
                void 0 === i && (i = {});
                const n = new(s.MutationObserver || s.WebkitMutationObserver)((e => {
                    if (t.__preventObserver__) return;
                    if (1 === e.length) return void r("observerUpdate", e[0]);
                    const i = function() {
                        r("observerUpdate", e[0])
                    };
                    s.requestAnimationFrame ? s.requestAnimationFrame(i) : s.setTimeout(i, 0)
                }));
                n.observe(e, {
                    attributes: void 0 === i.attributes || i.attributes,
                    childList: t.isElement || (void 0 === i.childList || i).childList,
                    characterData: void 0 === i.characterData || i.characterData
                }), a.push(n)
            };
        i({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }), n("init", (() => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = w(t.hostEl);
                    for (let t = 0; t < e.length; t += 1) l(e[t])
                }
                l(t.hostEl, {
                    childList: t.params.observeSlideChildren
                }), l(t.wrapperEl, {
                    attributes: !1
                })
            }
        })), n("destroy", (() => {
            a.forEach((e => {
                e.disconnect()
            })), a.splice(0, a.length)
        }))
    }]);
    const ge = [function(e) {
        let t, {
            swiper: i,
            extendParams: r,
            on: o,
            emit: a
        } = e;
        r({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        const s = n();
        i.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        const l = s.createElement("div");

        function c(e, t) {
            const n = i.params.virtual;
            if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t];
            let r;
            return n.renderSlide ? (r = n.renderSlide.call(i, e, t), "string" == typeof r && (l.innerHTML = r, r = l.children[0])) : r = i.isElement ? v("swiper-slide") : v("div", i.params.slideClass), r.setAttribute("data-swiper-slide-index", t), n.renderSlide || (r.innerHTML = e), n.cache && (i.virtual.cache[t] = r), r
        }

        function h(e, t, n) {
            const {
                slidesPerView: r,
                slidesPerGroup: o,
                centeredSlides: s,
                loop: l,
                initialSlide: h
            } = i.params;
            if (t && !l && h > 0) return;
            const {
                addSlidesBefore: u,
                addSlidesAfter: d
            } = i.params.virtual, {
                from: p,
                to: f,
                slides: g,
                slidesGrid: v,
                offset: y
            } = i.virtual;
            i.params.cssMode || i.updateActiveIndex();
            const b = void 0 === n ? i.activeIndex || 0 : n;
            let x, w, _;
            x = i.rtlTranslate ? "right" : i.isHorizontal() ? "left" : "top", s ? (w = Math.floor(r / 2) + o + d, _ = Math.floor(r / 2) + o + u) : (w = r + (o - 1) + d, _ = (l ? r : o) + u);
            let E = b - _,
                M = b + w;
            l || (E = Math.max(E, 0), M = Math.min(M, g.length - 1));
            let T = (i.slidesGrid[E] || 0) - (i.slidesGrid[0] || 0);

            function S() {
                i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), a("virtualUpdate")
            }
            if (l && b >= _ ? (E -= _, s || (T += i.slidesGrid[0])) : l && b < _ && (E = -_, s && (T += i.slidesGrid[0])), Object.assign(i.virtual, {
                    from: E,
                    to: M,
                    offset: T,
                    slidesGrid: i.slidesGrid,
                    slidesBefore: _,
                    slidesAfter: w
                }), p === E && f === M && !e) return i.slidesGrid !== v && T !== y && i.slides.forEach((e => {
                e.style[x] = T - Math.abs(i.cssOverflowAdjustment()) + "px"
            })), i.updateProgress(), void a("virtualUpdate");
            if (i.params.virtual.renderExternal) return i.params.virtual.renderExternal.call(i, {
                offset: T,
                from: E,
                to: M,
                slides: function() {
                    const e = [];
                    for (let t = E; t <= M; t += 1) e.push(g[t]);
                    return e
                }()
            }), void(i.params.virtual.renderExternalUpdate ? S() : a("virtualUpdate"));
            const A = [],
                C = [],
                L = e => {
                    let t = e;
                    return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t
                };
            if (e) i.slides.filter((e => e.matches(`.${i.params.slideClass}, swiper-slide`))).forEach((e => {
                e.remove()
            }));
            else
                for (let e = p; e <= f; e += 1)
                    if (e < E || e > M) {
                        const t = L(e);
                        i.slides.filter((e => e.matches(`.${i.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`))).forEach((e => {
                            e.remove()
                        }))
                    } const D = l ? -g.length : 0,
                P = l ? 2 * g.length : g.length;
            for (let t = D; t < P; t += 1)
                if (t >= E && t <= M) {
                    const i = L(t);
                    void 0 === f || e ? C.push(i) : (t > f && C.push(i), t < p && A.push(i))
                } if (C.forEach((e => {
                    i.slidesEl.append(c(g[e], e))
                })), l)
                for (let e = A.length - 1; e >= 0; e -= 1) {
                    const t = A[e];
                    i.slidesEl.prepend(c(g[t], t))
                } else A.sort(((e, t) => t - e)), A.forEach((e => {
                    i.slidesEl.prepend(c(g[e], e))
                }));
            m(i.slidesEl, ".swiper-slide, swiper-slide").forEach((e => {
                e.style[x] = T - Math.abs(i.cssOverflowAdjustment()) + "px"
            })), S()
        }
        o("beforeInit", (() => {
            if (!i.params.virtual.enabled) return;
            let e;
            if (void 0 === i.passedParams.virtual.slides) {
                const t = [...i.slidesEl.children].filter((e => e.matches(`.${i.params.slideClass}, swiper-slide`)));
                t && t.length && (i.virtual.slides = [...t], e = !0, t.forEach(((e, t) => {
                    e.setAttribute("data-swiper-slide-index", t), i.virtual.cache[t] = e, e.remove()
                })))
            }
            e || (i.virtual.slides = i.params.virtual.slides), i.classNames.push(`${i.params.containerModifierClass}virtual`), i.params.watchSlidesProgress = !0, i.originalParams.watchSlidesProgress = !0, h(!1, !0)
        })), o("setTranslate", (() => {
            i.params.virtual.enabled && (i.params.cssMode && !i._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
                h()
            }), 100)) : h())
        })), o("init update resize", (() => {
            i.params.virtual.enabled && i.params.cssMode && d(i.wrapperEl, "--swiper-virtual-size", `${i.virtualSize}px`)
        })), Object.assign(i.virtual, {
            appendSlide: function(e) {
                if ("object" == typeof e && "length" in e)
                    for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.push(e[t]);
                else i.virtual.slides.push(e);
                h(!0)
            },
            prependSlide: function(e) {
                const t = i.activeIndex;
                let n = t + 1,
                    r = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.unshift(e[t]);
                    n = t + e.length, r = e.length
                } else i.virtual.slides.unshift(e);
                if (i.params.virtual.cache) {
                    const e = i.virtual.cache,
                        t = {};
                    Object.keys(e).forEach((i => {
                        const n = e[i],
                            o = n.getAttribute("data-swiper-slide-index");
                        o && n.setAttribute("data-swiper-slide-index", parseInt(o, 10) + r), t[parseInt(i, 10) + r] = n
                    })), i.virtual.cache = t
                }
                h(!0), i.slideTo(n, 0)
            },
            removeSlide: function(e) {
                if (null == e) return;
                let t = i.activeIndex;
                if (Array.isArray(e))
                    for (let n = e.length - 1; n >= 0; n -= 1) i.params.virtual.cache && (delete i.virtual.cache[e[n]], Object.keys(i.virtual.cache).forEach((t => {
                        t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
                    }))), i.virtual.slides.splice(e[n], 1), e[n] < t && (t -= 1), t = Math.max(t, 0);
                else i.params.virtual.cache && (delete i.virtual.cache[e], Object.keys(i.virtual.cache).forEach((t => {
                    t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
                }))), i.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
                h(!0), i.slideTo(t, 0)
            },
            removeAllSlides: function() {
                i.virtual.slides = [], i.params.virtual.cache && (i.virtual.cache = {}), h(!0), i.slideTo(0, 0)
            },
            update: h
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: r,
            emit: a
        } = e;
        const s = n(),
            l = o();

        function c(e) {
            if (!t.enabled) return;
            const {
                rtlTranslate: i
            } = t;
            let n = e;
            n.originalEvent && (n = n.originalEvent);
            const r = n.keyCode || n.charCode,
                o = t.params.keyboard.pageUpDown,
                c = o && 33 === r,
                h = o && 34 === r,
                u = 37 === r,
                d = 39 === r,
                p = 38 === r,
                f = 40 === r;
            if (!t.allowSlideNext && (t.isHorizontal() && d || t.isVertical() && f || h)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && u || t.isVertical() && p || c)) return !1;
            if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || s.activeElement && s.activeElement.nodeName && ("input" === s.activeElement.nodeName.toLowerCase() || "textarea" === s.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (c || h || u || d || p || f)) {
                    let e = !1;
                    if (w(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === w(t.el, `.${t.params.slideActiveClass}`).length) return;
                    const n = t.el,
                        r = n.clientWidth,
                        o = n.clientHeight,
                        a = l.innerWidth,
                        s = l.innerHeight,
                        c = y(n);
                    i && (c.left -= n.scrollLeft);
                    const h = [
                        [c.left, c.top],
                        [c.left + r, c.top],
                        [c.left, c.top + o],
                        [c.left + r, c.top + o]
                    ];
                    for (let t = 0; t < h.length; t += 1) {
                        const i = h[t];
                        if (i[0] >= 0 && i[0] <= a && i[1] >= 0 && i[1] <= s) {
                            if (0 === i[0] && 0 === i[1]) continue;
                            e = !0
                        }
                    }
                    if (!e) return
                }
                t.isHorizontal() ? ((c || h || u || d) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((h || d) && !i || (c || u) && i) && t.slideNext(), ((c || u) && !i || (h || d) && i) && t.slidePrev()) : ((c || h || p || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (h || f) && t.slideNext(), (c || p) && t.slidePrev()), a("keyPress", r)
            }
        }

        function h() {
            t.keyboard.enabled || (s.addEventListener("keydown", c), t.keyboard.enabled = !0)
        }

        function u() {
            t.keyboard.enabled && (s.removeEventListener("keydown", c), t.keyboard.enabled = !1)
        }
        t.keyboard = {
            enabled: !1
        }, i({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        }), r("init", (() => {
            t.params.keyboard.enabled && h()
        })), r("destroy", (() => {
            t.keyboard.enabled && u()
        })), Object.assign(t.keyboard, {
            enable: h,
            disable: u
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const a = o();
        let c;
        i({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null,
                noMousewheelClass: "swiper-no-mousewheel"
            }
        }), t.mousewheel = {
            enabled: !1
        };
        let h, u = l();
        const d = [];

        function p() {
            t.enabled && (t.mouseEntered = !0)
        }

        function f() {
            t.enabled && (t.mouseEntered = !1)
        }

        function m(e) {
            return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && l() - u < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && l() - u < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), r("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), r("scroll", e.raw)), u = (new a.Date).getTime(), 1))
        }

        function g(e) {
            let i = e,
                n = !0;
            if (!t.enabled) return;
            if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`)) return;
            const o = t.params.mousewheel;
            t.params.cssMode && i.preventDefault();
            let a = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (a = document.querySelector(t.params.mousewheel.eventsTarget));
            const u = a && a.contains(i.target);
            if (!t.mouseEntered && !u && !o.releaseOnEdges) return !0;
            i.originalEvent && (i = i.originalEvent);
            let p = 0;
            const f = t.rtlTranslate ? -1 : 1,
                g = function(e) {
                    let t = 0,
                        i = 0,
                        n = 0,
                        r = 0;
                    return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, r = 10 * i, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = r, r = 0), (n || r) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, r *= 40) : (n *= 800, r *= 800)), n && !t && (t = n < 1 ? -1 : 1), r && !i && (i = r < 1 ? -1 : 1), {
                        spinX: t,
                        spinY: i,
                        pixelX: n,
                        pixelY: r
                    }
                }(i);
            if (o.forceToAxis)
                if (t.isHorizontal()) {
                    if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
                    p = -g.pixelX * f
                } else {
                    if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
                    p = -g.pixelY
                }
            else p = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * f : -g.pixelY;
            if (0 === p) return !0;
            o.invert && (p = -p);
            let v = t.getTranslate() + p * o.sensitivity;
            if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), n = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), n && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                const e = {
                        time: l(),
                        delta: Math.abs(p),
                        direction: Math.sign(p)
                    },
                    n = h && e.time < h.time + 500 && e.delta <= h.delta && e.direction === h.direction;
                if (!n) {
                    h = void 0;
                    let a = t.getTranslate() + p * o.sensitivity;
                    const l = t.isBeginning,
                        u = t.isEnd;
                    if (a >= t.minTranslate() && (a = t.minTranslate()), a <= t.maxTranslate() && (a = t.maxTranslate()), t.setTransition(0), t.setTranslate(a), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!l && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
                            direction: e.direction < 0 ? "next" : "prev",
                            byMousewheel: !0
                        }), t.params.freeMode.sticky) {
                        clearTimeout(c), c = void 0, d.length >= 15 && d.shift();
                        const i = d.length ? d[d.length - 1] : void 0,
                            n = d[0];
                        if (d.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) d.splice(0);
                        else if (d.length >= 15 && e.time - n.time < 500 && n.delta - e.delta >= 1 && e.delta <= 6) {
                            const i = p > 0 ? .8 : .2;
                            h = e, d.splice(0), c = s((() => {
                                !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, i)
                            }), 0)
                        }
                        c || (c = s((() => {
                            !t.destroyed && t.params && (h = e, d.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5))
                        }), 500))
                    }
                    if (n || r("scroll", i), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), o.releaseOnEdges && (a === t.minTranslate() || a === t.maxTranslate())) return !0
                }
            } else {
                const i = {
                    time: l(),
                    delta: Math.abs(p),
                    direction: Math.sign(p),
                    raw: e
                };
                d.length >= 2 && d.shift();
                const n = d.length ? d[d.length - 1] : void 0;
                if (d.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && m(i) : m(i), function(e) {
                        const i = t.params.mousewheel;
                        if (e.direction < 0) {
                            if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0
                        } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0;
                        return !1
                    }(i)) return !0
            }
            return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1
        }

        function v(e) {
            let i = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (i = document.querySelector(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", p), i[e]("mouseleave", f), i[e]("wheel", g)
        }

        function y() {
            return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0)
        }

        function b() {
            return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0)
        }
        n("init", (() => {
            !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && y()
        })), n("destroy", (() => {
            t.params.cssMode && y(), t.mousewheel.enabled && b()
        })), Object.assign(t.mousewheel, {
            enable: y,
            disable: b
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;

        function o(e) {
            let i;
            return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e) || t.hostEl.querySelector(e), i) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])), e && !i ? e : i)
        }

        function a(e, i) {
            const n = t.params.navigation;
            (e = M(e)).forEach((e => {
                e && (e.classList[i ? "add" : "remove"](...n.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = i), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass))
            }))
        }

        function s() {
            const {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            if (t.params.loop) return a(i, !1), void a(e, !1);
            a(i, t.isBeginning && !t.params.rewind), a(e, t.isEnd && !t.params.rewind)
        }

        function l(e) {
            e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), r("navigationPrev"))
        }

        function c(e) {
            e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), r("navigationNext"))
        }

        function h() {
            const e = t.params.navigation;
            if (t.params.navigation = oe(t, t.originalParams.navigation, t.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                }), !e.nextEl && !e.prevEl) return;
            let i = o(e.nextEl),
                n = o(e.prevEl);
            Object.assign(t.navigation, {
                nextEl: i,
                prevEl: n
            }), i = M(i), n = M(n);
            const r = (i, n) => {
                i && i.addEventListener("click", "next" === n ? c : l), !t.enabled && i && i.classList.add(...e.lockClass.split(" "))
            };
            i.forEach((e => r(e, "next"))), n.forEach((e => r(e, "prev")))
        }

        function u() {
            let {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            e = M(e), i = M(i);
            const n = (e, i) => {
                e.removeEventListener("click", "next" === i ? c : l), e.classList.remove(...t.params.navigation.disabledClass.split(" "))
            };
            e.forEach((e => n(e, "next"))), i.forEach((e => n(e, "prev")))
        }
        i({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }), t.navigation = {
            nextEl: null,
            prevEl: null
        }, n("init", (() => {
            !1 === t.params.navigation.enabled ? d() : (h(), s())
        })), n("toEdge fromEdge lock unlock", (() => {
            s()
        })), n("destroy", (() => {
            u()
        })), n("enable disable", (() => {
            let {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            e = M(e), i = M(i), t.enabled ? s() : [...e, ...i].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass)))
        })), n("click", ((e, i) => {
            let {
                nextEl: n,
                prevEl: o
            } = t.navigation;
            n = M(n), o = M(o);
            const a = i.target;
            let s = o.includes(a) || n.includes(a);
            if (t.isElement && !s) {
                const e = i.path || i.composedPath && i.composedPath();
                e && (s = e.find((e => n.includes(e) || o.includes(e))))
            }
            if (t.params.navigation.hideOnClick && !s) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === a || t.pagination.el.contains(a))) return;
                let e;
                n.length ? e = n[0].classList.contains(t.params.navigation.hiddenClass) : o.length && (e = o[0].classList.contains(t.params.navigation.hiddenClass)), r(!0 === e ? "navigationShow" : "navigationHide"), [...n, ...o].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass)))
            }
        }));
        const d = () => {
            t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), u()
        };
        Object.assign(t.navigation, {
            enable: () => {
                t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), h(), s()
            },
            disable: d,
            update: s,
            init: h,
            destroy: u
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const o = "swiper-pagination";
        let a;
        i({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${o}-bullet`,
                bulletActiveClass: `${o}-bullet-active`,
                modifierClass: `${o}-`,
                currentClass: `${o}-current`,
                totalClass: `${o}-total`,
                hiddenClass: `${o}-hidden`,
                progressbarFillClass: `${o}-progressbar-fill`,
                progressbarOppositeClass: `${o}-progressbar-opposite`,
                clickableClass: `${o}-clickable`,
                lockClass: `${o}-lock`,
                horizontalClass: `${o}-horizontal`,
                verticalClass: `${o}-vertical`,
                paginationDisabledClass: `${o}-disabled`
            }
        }), t.pagination = {
            el: null,
            bullets: []
        };
        let s = 0;

        function l() {
            return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
        }

        function c(e, i) {
            const {
                bulletActiveClass: n
            } = t.params.pagination;
            e && (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${n}-${i}`), (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${n}-${i}-${i}`))
        }

        function h(e) {
            const i = e.target.closest(ae(t.params.pagination.bulletClass));
            if (!i) return;
            e.preventDefault();
            const n = x(i) * t.params.slidesPerGroup;
            if (t.params.loop) {
                if (t.realIndex === n) return;
                const e = (r = t.realIndex, o = n, (o %= a = t.slides.length) == 1 + (r %= a) ? "next" : o === r - 1 ? "previous" : void 0);
                "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(n)
            } else t.slideTo(n);
            var r, o, a
        }

        function u() {
            const e = t.rtl,
                i = t.params.pagination;
            if (l()) return;
            let n, o, h = t.pagination.el;
            h = M(h);
            const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                d = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (o = t.previousRealIndex || 0, n = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (n = t.snapIndex, o = t.previousSnapIndex) : (o = t.previousIndex || 0, n = t.activeIndex || 0), "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const r = t.pagination.bullets;
                let l, u, d;
                if (i.dynamicBullets && (a = E(r[0], t.isHorizontal() ? "width" : "height", !0), h.forEach((e => {
                        e.style[t.isHorizontal() ? "width" : "height"] = a * (i.dynamicMainBullets + 4) + "px"
                    })), i.dynamicMainBullets > 1 && void 0 !== o && (s += n - (o || 0), s > i.dynamicMainBullets - 1 ? s = i.dynamicMainBullets - 1 : s < 0 && (s = 0)), l = Math.max(n - s, 0), u = l + (Math.min(r.length, i.dynamicMainBullets) - 1), d = (u + l) / 2), r.forEach((e => {
                        const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${i.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat();
                        e.classList.remove(...t)
                    })), h.length > 1) r.forEach((e => {
                    const r = x(e);
                    r === n ? e.classList.add(...i.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), i.dynamicBullets && (r >= l && r <= u && e.classList.add(...`${i.bulletActiveClass}-main`.split(" ")), r === l && c(e, "prev"), r === u && c(e, "next"))
                }));
                else {
                    const e = r[n];
                    if (e && e.classList.add(...i.bulletActiveClass.split(" ")), t.isElement && r.forEach(((e, t) => {
                            e.setAttribute("part", t === n ? "bullet-active" : "bullet")
                        })), i.dynamicBullets) {
                        const e = r[l],
                            t = r[u];
                        for (let e = l; e <= u; e += 1) r[e] && r[e].classList.add(...`${i.bulletActiveClass}-main`.split(" "));
                        c(e, "prev"), c(t, "next")
                    }
                }
                if (i.dynamicBullets) {
                    const n = Math.min(r.length, i.dynamicMainBullets + 4),
                        o = (a * n - a) / 2 - d * a,
                        s = e ? "right" : "left";
                    r.forEach((e => {
                        e.style[t.isHorizontal() ? s : "top"] = `${o}px`
                    }))
                }
            }
            h.forEach(((e, o) => {
                if ("fraction" === i.type && (e.querySelectorAll(ae(i.currentClass)).forEach((e => {
                        e.textContent = i.formatFractionCurrent(n + 1)
                    })), e.querySelectorAll(ae(i.totalClass)).forEach((e => {
                        e.textContent = i.formatFractionTotal(d)
                    }))), "progressbar" === i.type) {
                    let r;
                    r = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                    const o = (n + 1) / d;
                    let a = 1,
                        s = 1;
                    "horizontal" === r ? a = o : s = o, e.querySelectorAll(ae(i.progressbarFillClass)).forEach((e => {
                        e.style.transform = `translate3d(0,0,0) scaleX(${a}) scaleY(${s})`, e.style.transitionDuration = `${t.params.speed}ms`
                    }))
                }
                "custom" === i.type && i.renderCustom ? (e.innerHTML = i.renderCustom(t, n + 1, d), 0 === o && r("paginationRender", e)) : (0 === o && r("paginationRender", e), r("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)
            }))
        }

        function d() {
            const e = t.params.pagination;
            if (l()) return;
            const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
            let n = t.pagination.el;
            n = M(n);
            let o = "";
            if ("bullets" === e.type) {
                let n = t.params.loop ? Math.ceil(i / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && n > i && (n = i);
                for (let i = 0; i < n; i += 1) e.renderBullet ? o += e.renderBullet.call(t, i, e.bulletClass) : o += `<${e.bulletElement} ${t.isElement?'part="bullet"':""} class="${e.bulletClass}"></${e.bulletElement}>`
            }
            "fraction" === e.type && (o = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (o = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], n.forEach((i => {
                "custom" !== e.type && (i.innerHTML = o || ""), "bullets" === e.type && t.pagination.bullets.push(...i.querySelectorAll(ae(e.bulletClass)))
            })), "custom" !== e.type && r("paginationRender", n[0])
        }

        function p() {
            t.params.pagination = oe(t, t.originalParams.pagination, t.params.pagination, {
                el: "swiper-pagination"
            });
            const e = t.params.pagination;
            if (!e.el) return;
            let i;
            "string" == typeof e.el && t.isElement && (i = t.el.querySelector(e.el)), i || "string" != typeof e.el || (i = [...document.querySelectorAll(e.el)]), i || (i = e.el), i && 0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(i) && i.length > 1 && (i = [...t.el.querySelectorAll(e.el)], i.length > 1 && (i = i.find((e => w(e, ".swiper")[0] === t.el)))), Array.isArray(i) && 1 === i.length && (i = i[0]), Object.assign(t.pagination, {
                el: i
            }), i = M(i), i.forEach((i => {
                "bullets" === e.type && e.clickable && i.classList.add(...(e.clickableClass || "").split(" ")), i.classList.add(e.modifierClass + e.type), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.classList.add(`${e.modifierClass}${e.type}-dynamic`), s = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.classList.add(e.progressbarOppositeClass), e.clickable && i.addEventListener("click", h), t.enabled || i.classList.add(e.lockClass)
            })))
        }

        function f() {
            const e = t.params.pagination;
            if (l()) return;
            let i = t.pagination.el;
            i && (i = M(i), i.forEach((i => {
                i.classList.remove(e.hiddenClass), i.classList.remove(e.modifierClass + e.type), i.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (i.classList.remove(...(e.clickableClass || "").split(" ")), i.removeEventListener("click", h))
            }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" "))))
        }
        n("changeDirection", (() => {
            if (!t.pagination || !t.pagination.el) return;
            const e = t.params.pagination;
            let {
                el: i
            } = t.pagination;
            i = M(i), i.forEach((i => {
                i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            }))
        })), n("init", (() => {
            !1 === t.params.pagination.enabled ? m() : (p(), d(), u())
        })), n("activeIndexChange", (() => {
            void 0 === t.snapIndex && u()
        })), n("snapIndexChange", (() => {
            u()
        })), n("snapGridLengthChange", (() => {
            d(), u()
        })), n("destroy", (() => {
            f()
        })), n("enable disable", (() => {
            let {
                el: e
            } = t.pagination;
            e && (e = M(e), e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))))
        })), n("lock unlock", (() => {
            u()
        })), n("click", ((e, i) => {
            const n = i.target,
                o = M(t.pagination.el);
            if (t.params.pagination.el && t.params.pagination.hideOnClick && o && o.length > 0 && !n.classList.contains(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && n === t.navigation.nextEl || t.navigation.prevEl && n === t.navigation.prevEl)) return;
                const e = o[0].classList.contains(t.params.pagination.hiddenClass);
                r(!0 === e ? "paginationShow" : "paginationHide"), o.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass)))
            }
        }));
        const m = () => {
            t.el.classList.add(t.params.pagination.paginationDisabledClass);
            let {
                el: e
            } = t.pagination;
            e && (e = M(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), f()
        };
        Object.assign(t.pagination, {
            enable: () => {
                t.el.classList.remove(t.params.pagination.paginationDisabledClass);
                let {
                    el: e
                } = t.pagination;
                e && (e = M(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), p(), d(), u()
            },
            disable: m,
            render: d,
            update: u,
            init: p,
            destroy: f
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: r,
            emit: o
        } = e;
        const l = n();
        let c, h, u, d, p = !1,
            f = null,
            m = null;

        function g() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e,
                rtlTranslate: i
            } = t, {
                dragEl: n,
                el: r
            } = e, o = t.params.scrollbar, a = t.params.loop ? t.progressLoop : t.progress;
            let s = h,
                l = (u - h) * a;
            i ? (l = -l, l > 0 ? (s = h - l, l = 0) : -l + h > u && (s = u + l)) : l < 0 ? (s = h + l, l = 0) : l + h > u && (s = u - l), t.isHorizontal() ? (n.style.transform = `translate3d(${l}px, 0, 0)`, n.style.width = `${s}px`) : (n.style.transform = `translate3d(0px, ${l}px, 0)`, n.style.height = `${s}px`), o.hide && (clearTimeout(f), r.style.opacity = 1, f = setTimeout((() => {
                r.style.opacity = 0, r.style.transitionDuration = "400ms"
            }), 1e3))
        }

        function b() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e
            } = t, {
                dragEl: i,
                el: n
            } = e;
            i.style.width = "", i.style.height = "", u = t.isHorizontal() ? n.offsetWidth : n.offsetHeight, d = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), h = "auto" === t.params.scrollbar.dragSize ? u * d : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i.style.width = `${h}px` : i.style.height = `${h}px`, n.style.display = d >= 1 ? "none" : "", t.params.scrollbar.hide && (n.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
        }

        function x(e) {
            return t.isHorizontal() ? e.clientX : e.clientY
        }

        function w(e) {
            const {
                scrollbar: i,
                rtlTranslate: n
            } = t, {
                el: r
            } = i;
            let o;
            o = (x(e) - y(r)[t.isHorizontal() ? "left" : "top"] - (null !== c ? c : h / 2)) / (u - h), o = Math.max(Math.min(o, 1), 0), n && (o = 1 - o);
            const a = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * o;
            t.updateProgress(a), t.setTranslate(a), t.updateActiveIndex(), t.updateSlidesClasses()
        }

        function _(e) {
            const i = t.params.scrollbar,
                {
                    scrollbar: n,
                    wrapperEl: r
                } = t,
                {
                    el: a,
                    dragEl: s
                } = n;
            p = !0, c = e.target === s ? x(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), r.style.transitionDuration = "100ms", s.style.transitionDuration = "100ms", w(e), clearTimeout(m), a.style.transitionDuration = "0ms", i.hide && (a.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), o("scrollbarDragStart", e)
        }

        function E(e) {
            const {
                scrollbar: i,
                wrapperEl: n
            } = t, {
                el: r,
                dragEl: a
            } = i;
            p && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, w(e), n.style.transitionDuration = "0ms", r.style.transitionDuration = "0ms", a.style.transitionDuration = "0ms", o("scrollbarDragMove", e))
        }

        function T(e) {
            const i = t.params.scrollbar,
                {
                    scrollbar: n,
                    wrapperEl: r
                } = t,
                {
                    el: a
                } = n;
            p && (p = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", r.style.transitionDuration = ""), i.hide && (clearTimeout(m), m = s((() => {
                a.style.opacity = 0, a.style.transitionDuration = "400ms"
            }), 1e3)), o("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest())
        }

        function S(e) {
            const {
                scrollbar: i,
                params: n
            } = t, r = i.el;
            if (!r) return;
            const o = r,
                a = !!n.passiveListeners && {
                    passive: !1,
                    capture: !1
                },
                s = !!n.passiveListeners && {
                    passive: !0,
                    capture: !1
                };
            if (!o) return;
            const c = "on" === e ? "addEventListener" : "removeEventListener";
            o[c]("pointerdown", _, a), l[c]("pointermove", E, a), l[c]("pointerup", T, s)
        }

        function A() {
            const {
                scrollbar: e,
                el: i
            } = t;
            t.params.scrollbar = oe(t, t.originalParams.scrollbar, t.params.scrollbar, {
                el: "swiper-scrollbar"
            });
            const n = t.params.scrollbar;
            if (!n.el) return;
            let r, o;
            if ("string" == typeof n.el && t.isElement && (r = t.el.querySelector(n.el)), r || "string" != typeof n.el) r || (r = n.el);
            else if (r = l.querySelectorAll(n.el), !r.length) return;
            t.params.uniqueNavElements && "string" == typeof n.el && r.length > 1 && 1 === i.querySelectorAll(n.el).length && (r = i.querySelector(n.el)), r.length > 0 && (r = r[0]), r.classList.add(t.isHorizontal() ? n.horizontalClass : n.verticalClass), r && (o = r.querySelector(ae(t.params.scrollbar.dragClass)), o || (o = v("div", t.params.scrollbar.dragClass), r.append(o))), Object.assign(e, {
                el: r,
                dragEl: o
            }), n.draggable && t.params.scrollbar.el && t.scrollbar.el && S("on"), r && r.classList[t.enabled ? "remove" : "add"](...a(t.params.scrollbar.lockClass))
        }

        function C() {
            const e = t.params.scrollbar,
                i = t.scrollbar.el;
            i && i.classList.remove(...a(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && S("off")
        }
        i({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }), t.scrollbar = {
            el: null,
            dragEl: null
        }, r("changeDirection", (() => {
            if (!t.scrollbar || !t.scrollbar.el) return;
            const e = t.params.scrollbar;
            let {
                el: i
            } = t.scrollbar;
            i = M(i), i.forEach((i => {
                i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            }))
        })), r("init", (() => {
            !1 === t.params.scrollbar.enabled ? L() : (A(), b(), g())
        })), r("update resize observerUpdate lock unlock changeDirection", (() => {
            b()
        })), r("setTranslate", (() => {
            g()
        })), r("setTransition", ((e, i) => {
            ! function(e) {
                t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`)
            }(i)
        })), r("enable disable", (() => {
            const {
                el: e
            } = t.scrollbar;
            e && e.classList[t.enabled ? "remove" : "add"](...a(t.params.scrollbar.lockClass))
        })), r("destroy", (() => {
            C()
        }));
        const L = () => {
            t.el.classList.add(...a(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...a(t.params.scrollbar.scrollbarDisabledClass)), C()
        };
        Object.assign(t.scrollbar, {
            enable: () => {
                t.el.classList.remove(...a(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...a(t.params.scrollbar.scrollbarDisabledClass)), A(), b(), g()
            },
            disable: L,
            updateSize: b,
            setTranslate: g,
            init: A,
            destroy: C
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            parallax: {
                enabled: !1
            }
        });
        const r = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
            o = (e, i) => {
                const {
                    rtl: n
                } = t, r = n ? -1 : 1, o = e.getAttribute("data-swiper-parallax") || "0";
                let a = e.getAttribute("data-swiper-parallax-x"),
                    s = e.getAttribute("data-swiper-parallax-y");
                const l = e.getAttribute("data-swiper-parallax-scale"),
                    c = e.getAttribute("data-swiper-parallax-opacity"),
                    h = e.getAttribute("data-swiper-parallax-rotate");
                if (a || s ? (a = a || "0", s = s || "0") : t.isHorizontal() ? (a = o, s = "0") : (s = o, a = "0"), a = a.indexOf("%") >= 0 ? parseInt(a, 10) * i * r + "%" : a * i * r + "px", s = s.indexOf("%") >= 0 ? parseInt(s, 10) * i + "%" : s * i + "px", null != c) {
                    const t = c - (c - 1) * (1 - Math.abs(i));
                    e.style.opacity = t
                }
                let u = `translate3d(${a}, ${s}, 0px)`;
                null != l && (u += ` scale(${l-(l-1)*(1-Math.abs(i))})`), h && null != h && (u += ` rotate(${h*i*-1}deg)`), e.style.transform = u
            },
            a = () => {
                const {
                    el: e,
                    slides: i,
                    progress: n,
                    snapGrid: a,
                    isElement: s
                } = t, l = m(e, r);
                t.isElement && l.push(...m(t.hostEl, r)), l.forEach((e => {
                    o(e, n)
                })), i.forEach(((e, i) => {
                    let s = e.progress;
                    t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (s += Math.ceil(i / 2) - n * (a.length - 1)), s = Math.min(Math.max(s, -1), 1), e.querySelectorAll(`${r}, [data-swiper-parallax-rotate]`).forEach((e => {
                        o(e, s)
                    }))
                }))
            };
        n("beforeInit", (() => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
        })), n("init", (() => {
            t.params.parallax.enabled && a()
        })), n("setTranslate", (() => {
            t.params.parallax.enabled && a()
        })), n("setTransition", ((e, i) => {
            t.params.parallax.enabled && function(e) {
                void 0 === e && (e = t.params.speed);
                const {
                    el: i,
                    hostEl: n
                } = t, o = [...i.querySelectorAll(r)];
                t.isElement && o.push(...n.querySelectorAll(r)), o.forEach((t => {
                    let i = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (i = 0), t.style.transitionDuration = `${i}ms`
                }))
            }(i)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const a = o();
        i({
            zoom: {
                enabled: !1,
                limitToOriginalSize: !1,
                maxRatio: 3,
                minRatio: 1,
                panOnMouseMove: !1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }), t.zoom = {
            enabled: !1
        };
        let s = 1,
            l = !1,
            h = !1,
            u = {
                x: 0,
                y: 0
            };
        let d, p;
        const f = [],
            g = {
                originX: 0,
                originY: 0,
                slideEl: void 0,
                slideWidth: void 0,
                slideHeight: void 0,
                imageEl: void 0,
                imageWrapEl: void 0,
                maxRatio: 3
            },
            v = {
                isTouched: void 0,
                isMoved: void 0,
                currentX: void 0,
                currentY: void 0,
                minX: void 0,
                minY: void 0,
                maxX: void 0,
                maxY: void 0,
                width: void 0,
                height: void 0,
                startX: void 0,
                startY: void 0,
                touchesStart: {},
                touchesCurrent: {}
            },
            b = {
                x: void 0,
                y: void 0,
                prevPositionX: void 0,
                prevPositionY: void 0,
                prevTime: void 0
            };
        let x, _ = 1;

        function E() {
            if (f.length < 2) return 1;
            const e = f[0].pageX,
                t = f[0].pageY,
                i = f[1].pageX,
                n = f[1].pageY;
            return Math.sqrt((i - e) ** 2 + (n - t) ** 2)
        }

        function M() {
            const e = t.params.zoom,
                i = g.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
            if (e.limitToOriginalSize && g.imageEl && g.imageEl.naturalWidth) {
                const e = g.imageEl.naturalWidth / g.imageEl.offsetWidth;
                return Math.min(e, i)
            }
            return i
        }

        function T(e) {
            const i = t.isElement ? "swiper-slide" : `.${t.params.slideClass}`;
            return !!e.target.matches(i) || t.slides.filter((t => t.contains(e.target))).length > 0
        }

        function S(e) {
            const i = `.${t.params.zoom.containerClass}`;
            return !!e.target.matches(i) || [...t.hostEl.querySelectorAll(i)].filter((t => t.contains(e.target))).length > 0
        }

        function A(e) {
            if ("mouse" === e.pointerType && f.splice(0, f.length), !T(e)) return;
            const i = t.params.zoom;
            if (d = !1, p = !1, f.push(e), !(f.length < 2)) {
                if (d = !0, g.scaleStart = E(), !g.slideEl) {
                    g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), g.slideEl || (g.slideEl = t.slides[t.activeIndex]);
                    let n = g.slideEl.querySelector(`.${i.containerClass}`);
                    if (n && (n = n.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = n, g.imageWrapEl = n ? w(g.imageEl, `.${i.containerClass}`)[0] : void 0, !g.imageWrapEl) return void(g.imageEl = void 0);
                    g.maxRatio = M()
                }
                if (g.imageEl) {
                    const [e, t] = function() {
                        if (f.length < 2) return {
                            x: null,
                            y: null
                        };
                        const e = g.imageEl.getBoundingClientRect();
                        return [(f[0].pageX + (f[1].pageX - f[0].pageX) / 2 - e.x - a.scrollX) / s, (f[0].pageY + (f[1].pageY - f[0].pageY) / 2 - e.y - a.scrollY) / s]
                    }();
                    g.originX = e, g.originY = t, g.imageEl.style.transitionDuration = "0ms"
                }
                l = !0
            }
        }

        function C(e) {
            if (!T(e)) return;
            const i = t.params.zoom,
                n = t.zoom,
                r = f.findIndex((t => t.pointerId === e.pointerId));
            r >= 0 && (f[r] = e), f.length < 2 || (p = !0, g.scaleMove = E(), g.imageEl && (n.scale = g.scaleMove / g.scaleStart * s, n.scale > g.maxRatio && (n.scale = g.maxRatio - 1 + (n.scale - g.maxRatio + 1) ** .5), n.scale < i.minRatio && (n.scale = i.minRatio + 1 - (i.minRatio - n.scale + 1) ** .5), g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`))
        }

        function L(e) {
            if (!T(e)) return;
            if ("mouse" === e.pointerType && "pointerout" === e.type) return;
            const i = t.params.zoom,
                n = t.zoom,
                r = f.findIndex((t => t.pointerId === e.pointerId));
            r >= 0 && f.splice(r, 1), d && p && (d = !1, p = !1, g.imageEl && (n.scale = Math.max(Math.min(n.scale, g.maxRatio), i.minRatio), g.imageEl.style.transitionDuration = `${t.params.speed}ms`, g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`, s = n.scale, l = !1, n.scale > 1 && g.slideEl ? g.slideEl.classList.add(`${i.zoomedSlideClass}`) : n.scale <= 1 && g.slideEl && g.slideEl.classList.remove(`${i.zoomedSlideClass}`), 1 === n.scale && (g.originX = 0, g.originY = 0, g.slideEl = void 0)))
        }

        function D() {
            t.touchEventsData.preventTouchMoveFromPointerMove = !1
        }

        function P(e) {
            const i = "mouse" === e.pointerType && t.params.zoom.panOnMouseMove;
            if (!T(e) || !S(e)) return;
            const n = t.zoom;
            if (!g.imageEl) return;
            if (!v.isTouched || !g.slideEl) return void(i && O(e));
            if (i) return void O(e);
            v.isMoved || (v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, v.startX = c(g.imageWrapEl, "x") || 0, v.startY = c(g.imageWrapEl, "y") || 0, g.slideWidth = g.slideEl.offsetWidth, g.slideHeight = g.slideEl.offsetHeight, g.imageWrapEl.style.transitionDuration = "0ms");
            const r = v.width * n.scale,
                o = v.height * n.scale;
            if (v.minX = Math.min(g.slideWidth / 2 - r / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - o / 2, 0), v.maxY = -v.minY, v.touchesCurrent.x = f.length > 0 ? f[0].pageX : e.pageX, v.touchesCurrent.y = f.length > 0 ? f[0].pageY : e.pageY, Math.max(Math.abs(v.touchesCurrent.x - v.touchesStart.x), Math.abs(v.touchesCurrent.y - v.touchesStart.y)) > 5 && (t.allowClick = !1), !v.isMoved && !l) {
                if (t.isHorizontal() && (Math.floor(v.minX) === Math.floor(v.startX) && v.touchesCurrent.x < v.touchesStart.x || Math.floor(v.maxX) === Math.floor(v.startX) && v.touchesCurrent.x > v.touchesStart.x)) return v.isTouched = !1, void D();
                if (!t.isHorizontal() && (Math.floor(v.minY) === Math.floor(v.startY) && v.touchesCurrent.y < v.touchesStart.y || Math.floor(v.maxY) === Math.floor(v.startY) && v.touchesCurrent.y > v.touchesStart.y)) return v.isTouched = !1, void D()
            }
            e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(x), t.touchEventsData.preventTouchMoveFromPointerMove = !0, x = setTimeout((() => {
                t.destroyed || D()
            })), v.isMoved = !0;
            const a = (n.scale - s) / (g.maxRatio - t.params.zoom.minRatio),
                {
                    originX: h,
                    originY: u
                } = g;
            v.currentX = v.touchesCurrent.x - v.touchesStart.x + v.startX + a * (v.width - 2 * h), v.currentY = v.touchesCurrent.y - v.touchesStart.y + v.startY + a * (v.height - 2 * u), v.currentX < v.minX && (v.currentX = v.minX + 1 - (v.minX - v.currentX + 1) ** .8), v.currentX > v.maxX && (v.currentX = v.maxX - 1 + (v.currentX - v.maxX + 1) ** .8), v.currentY < v.minY && (v.currentY = v.minY + 1 - (v.minY - v.currentY + 1) ** .8), v.currentY > v.maxY && (v.currentY = v.maxY - 1 + (v.currentY - v.maxY + 1) ** .8), b.prevPositionX || (b.prevPositionX = v.touchesCurrent.x), b.prevPositionY || (b.prevPositionY = v.touchesCurrent.y), b.prevTime || (b.prevTime = Date.now()), b.x = (v.touchesCurrent.x - b.prevPositionX) / (Date.now() - b.prevTime) / 2, b.y = (v.touchesCurrent.y - b.prevPositionY) / (Date.now() - b.prevTime) / 2, Math.abs(v.touchesCurrent.x - b.prevPositionX) < 2 && (b.x = 0), Math.abs(v.touchesCurrent.y - b.prevPositionY) < 2 && (b.y = 0), b.prevPositionX = v.touchesCurrent.x, b.prevPositionY = v.touchesCurrent.y, b.prevTime = Date.now(), g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
        }

        function R() {
            const e = t.zoom;
            g.slideEl && t.activeIndex !== t.slides.indexOf(g.slideEl) && (g.imageEl && (g.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), g.imageWrapEl && (g.imageWrapEl.style.transform = "translate3d(0,0,0)"), g.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`), e.scale = 1, s = 1, g.slideEl = void 0, g.imageEl = void 0, g.imageWrapEl = void 0, g.originX = 0, g.originY = 0)
        }

        function O(e) {
            if (s <= 1 || !g.imageWrapEl) return;
            if (!T(e) || !S(e)) return;
            const t = a.getComputedStyle(g.imageWrapEl).transform,
                i = new a.DOMMatrix(t);
            if (!h) return h = !0, u.x = e.clientX, u.y = e.clientY, v.startX = i.e, v.startY = i.f, v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, g.slideWidth = g.slideEl.offsetWidth, void(g.slideHeight = g.slideEl.offsetHeight);
            const n = -3 * (e.clientX - u.x),
                r = -3 * (e.clientY - u.y),
                o = v.width * s,
                l = v.height * s,
                c = g.slideWidth,
                d = g.slideHeight,
                p = Math.min(c / 2 - o / 2, 0),
                f = -p,
                m = Math.min(d / 2 - l / 2, 0),
                y = -m,
                b = Math.max(Math.min(v.startX + n, f), p),
                x = Math.max(Math.min(v.startY + r, y), m);
            g.imageWrapEl.style.transitionDuration = "0ms", g.imageWrapEl.style.transform = `translate3d(${b}px, ${x}px, 0)`, u.x = e.clientX, u.y = e.clientY, v.startX = b, v.startY = x
        }

        function I(e) {
            const i = t.zoom,
                n = t.params.zoom;
            if (!g.slideEl) {
                e && e.target && (g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), g.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : g.slideEl = t.slides[t.activeIndex]);
                let i = g.slideEl.querySelector(`.${n.containerClass}`);
                i && (i = i.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = i, g.imageWrapEl = i ? w(g.imageEl, `.${n.containerClass}`)[0] : void 0
            }
            if (!g.imageEl || !g.imageWrapEl) return;
            let r, o, l, c, h, u, d, p, f, b, x, _, E, T, S, A, C, L;
            t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), g.slideEl.classList.add(`${n.zoomedSlideClass}`), void 0 === v.touchesStart.x && e ? (r = e.pageX, o = e.pageY) : (r = v.touchesStart.x, o = v.touchesStart.y);
            const D = "number" == typeof e ? e : null;
            1 === s && D && (r = void 0, o = void 0, v.touchesStart.x = void 0, v.touchesStart.y = void 0);
            const P = M();
            i.scale = D || P, s = D || P, !e || 1 === s && D ? (d = 0, p = 0) : (C = g.slideEl.offsetWidth, L = g.slideEl.offsetHeight, l = y(g.slideEl).left + a.scrollX, c = y(g.slideEl).top + a.scrollY, h = l + C / 2 - r, u = c + L / 2 - o, f = g.imageEl.offsetWidth || g.imageEl.clientWidth, b = g.imageEl.offsetHeight || g.imageEl.clientHeight, x = f * i.scale, _ = b * i.scale, E = Math.min(C / 2 - x / 2, 0), T = Math.min(L / 2 - _ / 2, 0), S = -E, A = -T, d = h * i.scale, p = u * i.scale, d < E && (d = E), d > S && (d = S), p < T && (p = T), p > A && (p = A)), D && 1 === i.scale && (g.originX = 0, g.originY = 0), g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = `translate3d(${d}px, ${p}px,0)`, g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${i.scale})`
        }

        function z() {
            const e = t.zoom,
                i = t.params.zoom;
            if (!g.slideEl) {
                t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : g.slideEl = t.slides[t.activeIndex];
                let e = g.slideEl.querySelector(`.${i.containerClass}`);
                e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = e, g.imageWrapEl = e ? w(g.imageEl, `.${i.containerClass}`)[0] : void 0
            }
            g.imageEl && g.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, s = 1, v.touchesStart.x = void 0, v.touchesStart.y = void 0, g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = "translate3d(0,0,0)", g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = "translate3d(0,0,0) scale(1)", g.slideEl.classList.remove(`${i.zoomedSlideClass}`), g.slideEl = void 0, g.originX = 0, g.originY = 0, t.params.zoom.panOnMouseMove && (u = {
                x: 0,
                y: 0
            }, h && (h = !1, v.startX = 0, v.startY = 0)))
        }

        function N(e) {
            const i = t.zoom;
            i.scale && 1 !== i.scale ? z() : I(e)
        }

        function B() {
            return {
                passiveListener: !!t.params.passiveListeners && {
                    passive: !0,
                    capture: !1
                },
                activeListenerWithCapture: !t.params.passiveListeners || {
                    passive: !1,
                    capture: !0
                }
            }
        }

        function F() {
            const e = t.zoom;
            if (e.enabled) return;
            e.enabled = !0;
            const {
                passiveListener: i,
                activeListenerWithCapture: n
            } = B();
            t.wrapperEl.addEventListener("pointerdown", A, i), t.wrapperEl.addEventListener("pointermove", C, n), ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                t.wrapperEl.addEventListener(e, L, i)
            })), t.wrapperEl.addEventListener("pointermove", P, n)
        }

        function k() {
            const e = t.zoom;
            if (!e.enabled) return;
            e.enabled = !1;
            const {
                passiveListener: i,
                activeListenerWithCapture: n
            } = B();
            t.wrapperEl.removeEventListener("pointerdown", A, i), t.wrapperEl.removeEventListener("pointermove", C, n), ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                t.wrapperEl.removeEventListener(e, L, i)
            })), t.wrapperEl.removeEventListener("pointermove", P, n)
        }
        Object.defineProperty(t.zoom, "scale", {
            get: () => _,
            set(e) {
                if (_ !== e) {
                    const t = g.imageEl,
                        i = g.slideEl;
                    r("zoomChange", e, t, i)
                }
                _ = e
            }
        }), n("init", (() => {
            t.params.zoom.enabled && F()
        })), n("destroy", (() => {
            k()
        })), n("touchStart", ((e, i) => {
            t.zoom.enabled && function(e) {
                const i = t.device;
                if (!g.imageEl) return;
                if (v.isTouched) return;
                i.android && e.cancelable && e.preventDefault(), v.isTouched = !0;
                const n = f.length > 0 ? f[0] : e;
                v.touchesStart.x = n.pageX, v.touchesStart.y = n.pageY
            }(i)
        })), n("touchEnd", ((e, i) => {
            t.zoom.enabled && function() {
                const e = t.zoom;
                if (f.length = 0, !g.imageEl) return;
                if (!v.isTouched || !v.isMoved) return v.isTouched = !1, void(v.isMoved = !1);
                v.isTouched = !1, v.isMoved = !1;
                let i = 300,
                    n = 300;
                const r = b.x * i,
                    o = v.currentX + r,
                    a = b.y * n,
                    s = v.currentY + a;
                0 !== b.x && (i = Math.abs((o - v.currentX) / b.x)), 0 !== b.y && (n = Math.abs((s - v.currentY) / b.y));
                const l = Math.max(i, n);
                v.currentX = o, v.currentY = s;
                const c = v.width * e.scale,
                    h = v.height * e.scale;
                v.minX = Math.min(g.slideWidth / 2 - c / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - h / 2, 0), v.maxY = -v.minY, v.currentX = Math.max(Math.min(v.currentX, v.maxX), v.minX), v.currentY = Math.max(Math.min(v.currentY, v.maxY), v.minY), g.imageWrapEl.style.transitionDuration = `${l}ms`, g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
            }()
        })), n("doubleTap", ((e, i) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && N(i)
        })), n("transitionEnd", (() => {
            t.zoom.enabled && t.params.zoom.enabled && R()
        })), n("slideChange", (() => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && R()
        })), Object.assign(t.zoom, {
            enable: F,
            disable: k,
            in: I,
            out: z,
            toggle: N
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;

        function r(e, t) {
            const i = function() {
                let e, t, i;
                return (n, r) => {
                    for (t = -1, e = n.length; e - t > 1;) i = e + t >> 1, n[i] <= r ? t = i : e = i;
                    return e
                }
            }();
            let n, r;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function(e) {
                return e ? (r = i(this.x, e), n = r - 1, (e - this.x[n]) * (this.y[r] - this.y[n]) / (this.x[r] - this.x[n]) + this.y[n]) : 0
            }, this
        }

        function o() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
        }
        i({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }), t.controller = {
            control: void 0
        }, n("beforeInit", (() => {
            "undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement) ? ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach((e => {
                if (t.controller.control || (t.controller.control = []), e && e.swiper) t.controller.control.push(e.swiper);
                else if (e) {
                    const i = `${t.params.eventsPrefix}init`,
                        n = r => {
                            t.controller.control.push(r.detail[0]), t.update(), e.removeEventListener(i, n)
                        };
                    e.addEventListener(i, n)
                }
            })) : t.controller.control = t.params.controller.control
        })), n("update", (() => {
            o()
        })), n("resize", (() => {
            o()
        })), n("observerUpdate", (() => {
            o()
        })), n("setTranslate", ((e, i, n) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(i, n)
        })), n("setTransition", ((e, i, n) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(i, n)
        })), Object.assign(t.controller, {
            setTranslate: function(e, i) {
                const n = t.controller.control;
                let o, a;
                const s = t.constructor;

                function l(e) {
                    if (e.destroyed) return;
                    const i = t.rtlTranslate ? -t.translate : t.translate;
                    "slide" === t.params.controller.by && (function(e) {
                        t.controller.spline = t.params.loop ? new r(t.slidesGrid, e.slidesGrid) : new r(t.snapGrid, e.snapGrid)
                    }(e), a = -t.controller.spline.interpolate(-i)), a && "container" !== t.params.controller.by || (o = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(o) && Number.isFinite(o) || (o = 1), a = (i - t.minTranslate()) * o + e.minTranslate()), t.params.controller.inverse && (a = e.maxTranslate() - a), e.updateProgress(a), e.setTranslate(a, t), e.updateActiveIndex(), e.updateSlidesClasses()
                }
                if (Array.isArray(n))
                    for (let e = 0; e < n.length; e += 1) n[e] !== i && n[e] instanceof s && l(n[e]);
                else n instanceof s && i !== n && l(n)
            },
            setTransition: function(e, i) {
                const n = t.constructor,
                    r = t.controller.control;
                let o;

                function a(i) {
                    i.destroyed || (i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && s((() => {
                        i.updateAutoHeight()
                    })), _(i.wrapperEl, (() => {
                        r && i.transitionEnd()
                    }))))
                }
                if (Array.isArray(r))
                    for (o = 0; o < r.length; o += 1) r[o] !== i && r[o] instanceof n && a(r[o]);
                else r instanceof n && i !== r && a(r)
            }
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: r
        } = e;
        i({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                containerRole: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null,
                scrollOnFocus: !0
            }
        }), t.a11y = {
            clicked: !1
        };
        let o, a, s = null,
            l = (new Date).getTime();

        function c(e) {
            const t = s;
            0 !== t.length && (t.innerHTML = "", t.innerHTML = e)
        }

        function h(e) {
            (e = M(e)).forEach((e => {
                e.setAttribute("tabIndex", "0")
            }))
        }

        function u(e) {
            (e = M(e)).forEach((e => {
                e.setAttribute("tabIndex", "-1")
            }))
        }

        function d(e, t) {
            (e = M(e)).forEach((e => {
                e.setAttribute("role", t)
            }))
        }

        function p(e, t) {
            (e = M(e)).forEach((e => {
                e.setAttribute("aria-roledescription", t)
            }))
        }

        function f(e, t) {
            (e = M(e)).forEach((e => {
                e.setAttribute("aria-label", t)
            }))
        }

        function m(e) {
            (e = M(e)).forEach((e => {
                e.setAttribute("aria-disabled", !0)
            }))
        }

        function g(e) {
            (e = M(e)).forEach((e => {
                e.setAttribute("aria-disabled", !1)
            }))
        }

        function y(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode) return;
            const i = t.params.a11y,
                n = e.target;
            if (!t.pagination || !t.pagination.el || n !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(ae(t.params.pagination.bulletClass))) {
                if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) {
                    const e = M(t.navigation.prevEl);
                    M(t.navigation.nextEl).includes(n) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? c(i.lastSlideMessage) : c(i.nextSlideMessage)), e.includes(n) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? c(i.firstSlideMessage) : c(i.prevSlideMessage))
                }
                t.pagination && n.matches(ae(t.params.pagination.bulletClass)) && n.click()
            }
        }

        function b() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }

        function w() {
            return b() && t.params.pagination.clickable
        }
        const _ = (e, t, i) => {
                h(e), "BUTTON" !== e.tagName && (d(e, "button"), e.addEventListener("keydown", y)), f(e, i),
                    function(e, t) {
                        (e = M(e)).forEach((e => {
                            e.setAttribute("aria-controls", t)
                        }))
                    }(e, t)
            },
            E = e => {
                a && a !== e.target && !a.contains(e.target) && (o = !0), t.a11y.clicked = !0
            },
            T = () => {
                o = !1, requestAnimationFrame((() => {
                    requestAnimationFrame((() => {
                        t.destroyed || (t.a11y.clicked = !1)
                    }))
                }))
            },
            S = e => {
                l = (new Date).getTime()
            },
            A = e => {
                if (t.a11y.clicked || !t.params.a11y.scrollOnFocus) return;
                if ((new Date).getTime() - l < 100) return;
                const i = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
                if (!i || !t.slides.includes(i)) return;
                a = i;
                const n = t.slides.indexOf(i) === t.activeIndex,
                    r = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i);
                n || r || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame((() => {
                    o || (t.params.loop ? t.slideToLoop(parseInt(i.getAttribute("data-swiper-slide-index")), 0) : t.slideTo(t.slides.indexOf(i), 0), o = !1)
                })))
            },
            C = () => {
                const e = t.params.a11y;
                e.itemRoleDescriptionMessage && p(t.slides, e.itemRoleDescriptionMessage), e.slideRole && d(t.slides, e.slideRole);
                const i = t.slides.length;
                e.slideLabelMessage && t.slides.forEach(((n, r) => {
                    const o = t.params.loop ? parseInt(n.getAttribute("data-swiper-slide-index"), 10) : r;
                    f(n, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, i))
                }))
            };
        r("beforeInit", (() => {
            s = v("span", t.params.a11y.notificationClass), s.setAttribute("aria-live", "assertive"), s.setAttribute("aria-atomic", "true")
        })), r("afterInit", (() => {
            t.params.a11y.enabled && (() => {
                const e = t.params.a11y;
                t.el.append(s);
                const i = t.el;
                e.containerRoleDescriptionMessage && p(i, e.containerRoleDescriptionMessage), e.containerMessage && f(i, e.containerMessage), e.containerRole && d(i, e.containerRole);
                const r = t.wrapperEl,
                    o = e.id || r.getAttribute("id") || `swiper-wrapper-${a=16,void 0===a&&(a=16),"x".repeat(a).replace(/x/g,(()=>Math.round(16*Math.random()).toString(16)))}`;
                var a;
                const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
                var c;
                c = o, M(r).forEach((e => {
                        e.setAttribute("id", c)
                    })),
                    function(e, t) {
                        (e = M(e)).forEach((e => {
                            e.setAttribute("aria-live", t)
                        }))
                    }(r, l), C();
                let {
                    nextEl: h,
                    prevEl: u
                } = t.navigation ? t.navigation : {};
                h = M(h), u = M(u), h && h.forEach((t => _(t, o, e.nextSlideMessage))), u && u.forEach((t => _(t, o, e.prevSlideMessage))), w() && M(t.pagination.el).forEach((e => {
                    e.addEventListener("keydown", y)
                })), n().addEventListener("visibilitychange", S), t.el.addEventListener("focus", A, !0), t.el.addEventListener("focus", A, !0), t.el.addEventListener("pointerdown", E, !0), t.el.addEventListener("pointerup", T, !0)
            })()
        })), r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
            t.params.a11y.enabled && C()
        })), r("fromEdge toEdge afterInit lock unlock", (() => {
            t.params.a11y.enabled && function() {
                if (t.params.loop || t.params.rewind || !t.navigation) return;
                const {
                    nextEl: e,
                    prevEl: i
                } = t.navigation;
                i && (t.isBeginning ? (m(i), u(i)) : (g(i), h(i))), e && (t.isEnd ? (m(e), u(e)) : (g(e), h(e)))
            }()
        })), r("paginationUpdate", (() => {
            t.params.a11y.enabled && function() {
                const e = t.params.a11y;
                b() && t.pagination.bullets.forEach((i => {
                    t.params.pagination.clickable && (h(i), t.params.pagination.renderBullet || (d(i, "button"), f(i, e.paginationBulletMessage.replace(/\{\{index\}\}/, x(i) + 1)))), i.matches(ae(t.params.pagination.bulletActiveClass)) ? i.setAttribute("aria-current", "true") : i.removeAttribute("aria-current")
                }))
            }()
        })), r("destroy", (() => {
            t.params.a11y.enabled && function() {
                s && s.remove();
                let {
                    nextEl: e,
                    prevEl: i
                } = t.navigation ? t.navigation : {};
                e = M(e), i = M(i), e && e.forEach((e => e.removeEventListener("keydown", y))), i && i.forEach((e => e.removeEventListener("keydown", y))), w() && M(t.pagination.el).forEach((e => {
                    e.removeEventListener("keydown", y)
                })), n().removeEventListener("visibilitychange", S), t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", A, !0), t.el.removeEventListener("pointerdown", E, !0), t.el.removeEventListener("pointerup", T, !0))
            }()
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            history: {
                enabled: !1,
                root: "",
                replaceState: !1,
                key: "slides",
                keepQuery: !1
            }
        });
        let r = !1,
            a = {};
        const s = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
            l = e => {
                const t = o();
                let i;
                i = e ? new URL(e) : t.location;
                const n = i.pathname.slice(1).split("/").filter((e => "" !== e)),
                    r = n.length;
                return {
                    key: n[r - 2],
                    value: n[r - 1]
                }
            },
            c = (e, i) => {
                const n = o();
                if (!r || !t.params.history.enabled) return;
                let a;
                a = t.params.url ? new URL(t.params.url) : n.location;
                const l = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${i}"]`) : t.slides[i];
                let c = s(l.getAttribute("data-history"));
                if (t.params.history.root.length > 0) {
                    let i = t.params.history.root;
                    "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e?`${e}/`:""}${c}`
                } else a.pathname.includes(e) || (c = `${e?`${e}/`:""}${c}`);
                t.params.history.keepQuery && (c += a.search);
                const h = n.history.state;
                h && h.value === c || (t.params.history.replaceState ? n.history.replaceState({
                    value: c
                }, null, c) : n.history.pushState({
                    value: c
                }, null, c))
            },
            h = (e, i, n) => {
                if (i)
                    for (let r = 0, o = t.slides.length; r < o; r += 1) {
                        const o = t.slides[r];
                        if (s(o.getAttribute("data-history")) === i) {
                            const i = t.getSlideIndex(o);
                            t.slideTo(i, e, n)
                        }
                    } else t.slideTo(0, e, n)
            },
            u = () => {
                a = l(t.params.url), h(t.params.speed, a.value, !1)
            };
        n("init", (() => {
            t.params.history.enabled && (() => {
                const e = o();
                if (t.params.history) {
                    if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
                    r = !0, a = l(t.params.url), a.key || a.value ? (h(0, a.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", u)) : t.params.history.replaceState || e.addEventListener("popstate", u)
                }
            })()
        })), n("destroy", (() => {
            t.params.history.enabled && (() => {
                const e = o();
                t.params.history.replaceState || e.removeEventListener("popstate", u)
            })()
        })), n("transitionEnd _freeModeNoMomentumRelease", (() => {
            r && c(t.params.history.key, t.activeIndex)
        })), n("slideChange", (() => {
            r && t.params.cssMode && c(t.params.history.key, t.activeIndex)
        }))
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            emit: r,
            on: a
        } = e, s = !1;
        const l = n(),
            c = o();
        i({
            hashNavigation: {
                enabled: !1,
                replaceState: !1,
                watchState: !1,
                getSlideIndex(e, i) {
                    if (t.virtual && t.params.virtual.enabled) {
                        const e = t.slides.find((e => e.getAttribute("data-hash") === i));
                        return e ? parseInt(e.getAttribute("data-swiper-slide-index"), 10) : 0
                    }
                    return t.getSlideIndex(m(t.slidesEl, `.${t.params.slideClass}[data-hash="${i}"], swiper-slide[data-hash="${i}"]`)[0])
                }
            }
        });
        const h = () => {
                r("hashChange");
                const e = l.location.hash.replace("#", ""),
                    i = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
                if (e !== (i ? i.getAttribute("data-hash") : "")) {
                    const i = t.params.hashNavigation.getSlideIndex(t, e);
                    if (void 0 === i || Number.isNaN(i)) return;
                    t.slideTo(i)
                }
            },
            u = () => {
                if (!s || !t.params.hashNavigation.enabled) return;
                const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex],
                    i = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
                t.params.hashNavigation.replaceState && c.history && c.history.replaceState ? (c.history.replaceState(null, null, `#${i}` || ""), r("hashSet")) : (l.location.hash = i || "", r("hashSet"))
            };
        a("init", (() => {
            t.params.hashNavigation.enabled && (() => {
                if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                s = !0;
                const e = l.location.hash.replace("#", "");
                if (e) {
                    const i = 0,
                        n = t.params.hashNavigation.getSlideIndex(t, e);
                    t.slideTo(n || 0, i, t.params.runCallbacksOnInit, !0)
                }
                t.params.hashNavigation.watchState && c.addEventListener("hashchange", h)
            })()
        })), a("destroy", (() => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && c.removeEventListener("hashchange", h)
        })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
            s && u()
        })), a("slideChange", (() => {
            s && t.params.cssMode && u()
        }))
    }, function(e) {
        let t, i, {
            swiper: r,
            extendParams: o,
            on: a,
            emit: s,
            params: l
        } = e;
        r.autoplay = {
            running: !1,
            paused: !1,
            timeLeft: 0
        }, o({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !1,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        });
        let c, h, u, d, p, f, m, g, v = l && l.autoplay ? l.autoplay.delay : 3e3,
            y = l && l.autoplay ? l.autoplay.delay : 3e3,
            b = (new Date).getTime();

        function x(e) {
            r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener("transitionend", x), g || e.detail && e.detail.bySwiperTouchMove || S())
        }
        const w = () => {
                if (r.destroyed || !r.autoplay.running) return;
                r.autoplay.paused ? h = !0 : h && (y = c, h = !1);
                const e = r.autoplay.paused ? c : b + y - (new Date).getTime();
                r.autoplay.timeLeft = e, s("autoplayTimeLeft", e, e / v), i = requestAnimationFrame((() => {
                    w()
                }))
            },
            _ = e => {
                if (r.destroyed || !r.autoplay.running) return;
                cancelAnimationFrame(i), w();
                let n = void 0 === e ? r.params.autoplay.delay : e;
                v = r.params.autoplay.delay, y = r.params.autoplay.delay;
                const o = (() => {
                    let e;
                    if (e = r.virtual && r.params.virtual.enabled ? r.slides.find((e => e.classList.contains("swiper-slide-active"))) : r.slides[r.activeIndex], e) return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
                })();
                !Number.isNaN(o) && o > 0 && void 0 === e && (n = o, v = o, y = o), c = n;
                const a = r.params.speed,
                    l = () => {
                        r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(a, !0, !0), s("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, a, !0, !0), s("autoplay")) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(a, !0, !0), s("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, a, !0, !0), s("autoplay")), r.params.cssMode && (b = (new Date).getTime(), requestAnimationFrame((() => {
                            _()
                        }))))
                    };
                return n > 0 ? (clearTimeout(t), t = setTimeout((() => {
                    l()
                }), n)) : requestAnimationFrame((() => {
                    l()
                })), n
            },
            E = () => {
                b = (new Date).getTime(), r.autoplay.running = !0, _(), s("autoplayStart")
            },
            M = () => {
                r.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(i), s("autoplayStop")
            },
            T = (e, i) => {
                if (r.destroyed || !r.autoplay.running) return;
                clearTimeout(t), e || (m = !0);
                const n = () => {
                    s("autoplayPause"), r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener("transitionend", x) : S()
                };
                if (r.autoplay.paused = !0, i) return f && (c = r.params.autoplay.delay), f = !1, void n();
                const o = c || r.params.autoplay.delay;
                c = o - ((new Date).getTime() - b), r.isEnd && c < 0 && !r.params.loop || (c < 0 && (c = 0), n())
            },
            S = () => {
                r.isEnd && c < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (b = (new Date).getTime(), m ? (m = !1, _(c)) : _(), r.autoplay.paused = !1, s("autoplayResume"))
            },
            A = () => {
                if (r.destroyed || !r.autoplay.running) return;
                const e = n();
                "hidden" === e.visibilityState && (m = !0, T(!0)), "visible" === e.visibilityState && S()
            },
            C = e => {
                "mouse" === e.pointerType && (m = !0, g = !0, r.animating || r.autoplay.paused || T(!0))
            },
            L = e => {
                "mouse" === e.pointerType && (g = !1, r.autoplay.paused && S())
            };
        a("init", (() => {
            r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener("pointerenter", C), r.el.addEventListener("pointerleave", L)), n().addEventListener("visibilitychange", A), E())
        })), a("destroy", (() => {
            r.el && "string" != typeof r.el && (r.el.removeEventListener("pointerenter", C), r.el.removeEventListener("pointerleave", L)), n().removeEventListener("visibilitychange", A), r.autoplay.running && M()
        })), a("_freeModeStaticRelease", (() => {
            (d || m) && S()
        })), a("_freeModeNoMomentumRelease", (() => {
            r.params.autoplay.disableOnInteraction ? M() : T(!0, !0)
        })), a("beforeTransitionStart", ((e, t, i) => {
            !r.destroyed && r.autoplay.running && (i || !r.params.autoplay.disableOnInteraction ? T(!0, !0) : M())
        })), a("sliderFirstMove", (() => {
            !r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? M() : (u = !0, d = !1, m = !1, p = setTimeout((() => {
                m = !0, d = !0, T(!0)
            }), 200)))
        })), a("touchEnd", (() => {
            if (!r.destroyed && r.autoplay.running && u) {
                if (clearTimeout(p), clearTimeout(t), r.params.autoplay.disableOnInteraction) return d = !1, void(u = !1);
                d && r.params.cssMode && S(), d = !1, u = !1
            }
        })), a("slideChange", (() => {
            !r.destroyed && r.autoplay.running && (f = !0)
        })), Object.assign(r.autoplay, {
            start: E,
            stop: M,
            pause: T,
            resume: S
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: r
        } = e;
        i({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let o = !1,
            a = !1;

        function s() {
            const e = t.thumbs.swiper;
            if (!e || e.destroyed) return;
            const i = e.clickedIndex,
                n = e.clickedSlide;
            if (n && n.classList.contains(t.params.thumbs.slideThumbActiveClass)) return;
            if (null == i) return;
            let r;
            r = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : i, t.params.loop ? t.slideToLoop(r) : t.slideTo(r)
        }

        function l() {
            const {
                thumbs: e
            } = t.params;
            if (o) return !1;
            o = !0;
            const i = t.constructor;
            if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Object.assign(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), t.thumbs.swiper.update();
            else if (h(e.swiper)) {
                const n = Object.assign({}, e.swiper);
                Object.assign(n, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }), t.thumbs.swiper = new i(n), a = !0
            }
            return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", s), !0
        }

        function c(e) {
            const i = t.thumbs.swiper;
            if (!i || i.destroyed) return;
            const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
            let r = 1;
            const o = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (r = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (r = 1), r = Math.floor(r), i.slides.forEach((e => e.classList.remove(o))), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                for (let e = 0; e < r; e += 1) m(i.slidesEl, `[data-swiper-slide-index="${t.realIndex+e}"]`).forEach((e => {
                    e.classList.add(o)
                }));
            else
                for (let e = 0; e < r; e += 1) i.slides[t.realIndex + e] && i.slides[t.realIndex + e].classList.add(o);
            const a = t.params.thumbs.autoScrollOffset,
                s = a && !i.params.loop;
            if (t.realIndex !== i.realIndex || s) {
                const r = i.activeIndex;
                let o, l;
                if (i.params.loop) {
                    const e = i.slides.find((e => e.getAttribute("data-swiper-slide-index") === `${t.realIndex}`));
                    o = i.slides.indexOf(e), l = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else o = t.realIndex, l = o > t.previousIndex ? "next" : "prev";
                s && (o += "next" === l ? a : -1 * a), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(o) < 0 && (i.params.centeredSlides ? o = o > r ? o - Math.floor(n / 2) + 1 : o + Math.floor(n / 2) - 1 : o > r && i.params.slidesPerGroup, i.slideTo(o, e ? 0 : void 0))
            }
        }
        t.thumbs = {
            swiper: null
        }, r("beforeInit", (() => {
            const {
                thumbs: e
            } = t.params;
            if (e && e.swiper)
                if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
                    const i = n(),
                        r = () => {
                            const n = "string" == typeof e.swiper ? i.querySelector(e.swiper) : e.swiper;
                            if (n && n.swiper) e.swiper = n.swiper, l(), c(!0);
                            else if (n) {
                                const i = `${t.params.eventsPrefix}init`,
                                    r = o => {
                                        e.swiper = o.detail[0], n.removeEventListener(i, r), l(), c(!0), e.swiper.update(), t.update()
                                    };
                                n.addEventListener(i, r)
                            }
                            return n
                        },
                        o = () => {
                            t.destroyed || r() || requestAnimationFrame(o)
                        };
                    requestAnimationFrame(o)
                } else l(), c(!0)
        })), r("slideChange update resize observerUpdate", (() => {
            c()
        })), r("setTransition", ((e, i) => {
            const n = t.thumbs.swiper;
            n && !n.destroyed && n.setTransition(i)
        })), r("beforeDestroy", (() => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && a && e.destroy()
        })), Object.assign(t.thumbs, {
            init: l,
            update: c
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            emit: n,
            once: r
        } = e;
        i({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }), Object.assign(t, {
            freeMode: {
                onTouchStart: function() {
                    if (t.params.cssMode) return;
                    const e = t.getTranslate();
                    t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
                        currentPos: t.rtl ? t.translate : -t.translate
                    })
                },
                onTouchMove: function() {
                    if (t.params.cssMode) return;
                    const {
                        touchEventsData: e,
                        touches: i
                    } = t;
                    0 === e.velocities.length && e.velocities.push({
                        position: i[t.isHorizontal() ? "startX" : "startY"],
                        time: e.touchStartTime
                    }), e.velocities.push({
                        position: i[t.isHorizontal() ? "currentX" : "currentY"],
                        time: l()
                    })
                },
                onTouchEnd: function(e) {
                    let {
                        currentPos: i
                    } = e;
                    if (t.params.cssMode) return;
                    const {
                        params: o,
                        wrapperEl: a,
                        rtlTranslate: s,
                        snapGrid: c,
                        touchEventsData: h
                    } = t, u = l() - h.touchStartTime;
                    if (i < -t.minTranslate()) t.slideTo(t.activeIndex);
                    else if (i > -t.maxTranslate()) t.slides.length < c.length ? t.slideTo(c.length - 1) : t.slideTo(t.slides.length - 1);
                    else {
                        if (o.freeMode.momentum) {
                            if (h.velocities.length > 1) {
                                const e = h.velocities.pop(),
                                    i = h.velocities.pop(),
                                    n = e.position - i.position,
                                    r = e.time - i.time;
                                t.velocity = n / r, t.velocity /= 2, Math.abs(t.velocity) < o.freeMode.minimumVelocity && (t.velocity = 0), (r > 150 || l() - e.time > 300) && (t.velocity = 0)
                            } else t.velocity = 0;
                            t.velocity *= o.freeMode.momentumVelocityRatio, h.velocities.length = 0;
                            let e = 1e3 * o.freeMode.momentumRatio;
                            const i = t.velocity * e;
                            let u = t.translate + i;
                            s && (u = -u);
                            let d, p = !1;
                            const f = 20 * Math.abs(t.velocity) * o.freeMode.momentumBounceRatio;
                            let m;
                            if (u < t.maxTranslate()) o.freeMode.momentumBounce ? (u + t.maxTranslate() < -f && (u = t.maxTranslate() - f), d = t.maxTranslate(), p = !0, h.allowMomentumBounce = !0) : u = t.maxTranslate(), o.loop && o.centeredSlides && (m = !0);
                            else if (u > t.minTranslate()) o.freeMode.momentumBounce ? (u - t.minTranslate() > f && (u = t.minTranslate() + f), d = t.minTranslate(), p = !0, h.allowMomentumBounce = !0) : u = t.minTranslate(), o.loop && o.centeredSlides && (m = !0);
                            else if (o.freeMode.sticky) {
                                let e;
                                for (let t = 0; t < c.length; t += 1)
                                    if (c[t] > -u) {
                                        e = t;
                                        break
                                    } u = Math.abs(c[e] - u) < Math.abs(c[e - 1] - u) || "next" === t.swipeDirection ? c[e] : c[e - 1], u = -u
                            }
                            if (m && r("transitionEnd", (() => {
                                    t.loopFix()
                                })), 0 !== t.velocity) {
                                if (e = s ? Math.abs((-u - t.translate) / t.velocity) : Math.abs((u - t.translate) / t.velocity), o.freeMode.sticky) {
                                    const i = Math.abs((s ? -u : u) - t.translate),
                                        n = t.slidesSizesGrid[t.activeIndex];
                                    e = i < n ? o.speed : i < 2 * n ? 1.5 * o.speed : 2.5 * o.speed
                                }
                            } else if (o.freeMode.sticky) return void t.slideToClosest();
                            o.freeMode.momentumBounce && p ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating = !0, _(a, (() => {
                                t && !t.destroyed && h.allowMomentumBounce && (n("momentumBounce"), t.setTransition(o.speed), setTimeout((() => {
                                    t.setTranslate(d), _(a, (() => {
                                        t && !t.destroyed && t.transitionEnd()
                                    }))
                                }), 0))
                            }))) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(u), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, _(a, (() => {
                                t && !t.destroyed && t.transitionEnd()
                            })))) : t.updateProgress(u), t.updateActiveIndex(), t.updateSlidesClasses()
                        } else {
                            if (o.freeMode.sticky) return void t.slideToClosest();
                            o.freeMode && n("_freeModeNoMomentumRelease")
                        }(!o.freeMode.momentum || u >= o.longSwipesMs) && (n("_freeModeStaticRelease"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                    }
                }
            }
        })
    }, function(e) {
        let t, i, n, r, {
            swiper: o,
            extendParams: a,
            on: s
        } = e;
        a({
            grid: {
                rows: 1,
                fill: "column"
            }
        });
        const l = () => {
            let e = o.params.spaceBetween;
            return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * o.size : "string" == typeof e && (e = parseFloat(e)), e
        };
        s("init", (() => {
            r = o.params.grid && o.params.grid.rows > 1
        })), s("update", (() => {
            const {
                params: e,
                el: t
            } = o, i = e.grid && e.grid.rows > 1;
            r && !i ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), n = 1, o.emitContainerClasses()) : !r && i && (t.classList.add(`${e.containerModifierClass}grid`), "column" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`), o.emitContainerClasses()), r = i
        })), o.grid = {
            initSlides: e => {
                const {
                    slidesPerView: r
                } = o.params, {
                    rows: a,
                    fill: s
                } = o.params.grid, l = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : e.length;
                n = Math.floor(l / a), t = Math.floor(l / a) === l / a ? l : Math.ceil(l / a) * a, "auto" !== r && "row" === s && (t = Math.max(t, r * a)), i = t / a
            },
            unsetSlides: () => {
                o.slides && o.slides.forEach((e => {
                    e.swiperSlideGridSet && (e.style.height = "", e.style[o.getDirectionLabel("margin-top")] = "")
                }))
            },
            updateSlide: (e, r, a) => {
                const {
                    slidesPerGroup: s
                } = o.params, c = l(), {
                    rows: h,
                    fill: u
                } = o.params.grid, d = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : a.length;
                let p, f, m;
                if ("row" === u && s > 1) {
                    const i = Math.floor(e / (s * h)),
                        n = e - h * s * i,
                        o = 0 === i ? s : Math.min(Math.ceil((d - i * h * s) / h), s);
                    m = Math.floor(n / o), f = n - m * o + i * s, p = f + m * t / h, r.style.order = p
                } else "column" === u ? (f = Math.floor(e / h), m = e - f * h, (f > n || f === n && m === h - 1) && (m += 1, m >= h && (m = 0, f += 1))) : (m = Math.floor(e / i), f = e - m * i);
                r.row = m, r.column = f, r.style.height = `calc((100% - ${(h-1)*c}px) / ${h})`, r.style[o.getDirectionLabel("margin-top")] = 0 !== m ? c && `${c}px` : "", r.swiperSlideGridSet = !0
            },
            updateWrapperSize: (e, i) => {
                const {
                    centeredSlides: n,
                    roundLengths: r
                } = o.params, a = l(), {
                    rows: s
                } = o.params.grid;
                if (o.virtualSize = (e + a) * t, o.virtualSize = Math.ceil(o.virtualSize / s) - a, o.params.cssMode || (o.wrapperEl.style[o.getDirectionLabel("width")] = `${o.virtualSize+a}px`), n) {
                    const e = [];
                    for (let t = 0; t < i.length; t += 1) {
                        let n = i[t];
                        r && (n = Math.floor(n)), i[t] < o.virtualSize + i[0] && e.push(n)
                    }
                    i.splice(0, i.length), i.push(...e)
                }
            }
        }
    }, function(e) {
        let {
            swiper: t
        } = e;
        Object.assign(t, {
            appendSlide: se.bind(t),
            prependSlide: le.bind(t),
            addSlide: ce.bind(t),
            removeSlide: he.bind(t),
            removeAllSlides: ue.bind(t)
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            fadeEffect: {
                crossFade: !1
            }
        }), de({
            effect: "fade",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e
                } = t;
                t.params.fadeEffect;
                for (let i = 0; i < e.length; i += 1) {
                    const e = t.slides[i];
                    let n = -e.swiperSlideOffset;
                    t.params.virtualTranslate || (n -= t.translate);
                    let r = 0;
                    t.isHorizontal() || (r = n, n = 0);
                    const o = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0),
                        a = pe(0, e);
                    a.style.opacity = o, a.style.transform = `translate3d(${n}px, ${r}px, 0px)`
                }
            },
            setTransition: e => {
                const i = t.slides.map((e => f(e)));
                i.forEach((t => {
                    t.style.transitionDuration = `${e}ms`
                })), fe({
                    swiper: t,
                    duration: e,
                    transformElements: i,
                    allSlides: !0
                })
            },
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            cubeEffect: {
                slideShadows: !0,
                shadow: !0,
                shadowOffset: 20,
                shadowScale: .94
            }
        });
        const r = (e, t, i) => {
            let n = i ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                r = i ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            n || (n = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "left" : "top")).split(" ")), e.append(n)), r || (r = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "right" : "bottom")).split(" ")), e.append(r)), n && (n.style.opacity = Math.max(-t, 0)), r && (r.style.opacity = Math.max(t, 0))
        };
        de({
            effect: "cube",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    el: e,
                    wrapperEl: i,
                    slides: n,
                    width: o,
                    height: a,
                    rtlTranslate: s,
                    size: l,
                    browser: c
                } = t, h = T(t), u = t.params.cubeEffect, d = t.isHorizontal(), p = t.virtual && t.params.virtual.enabled;
                let f, m = 0;
                u.shadow && (d ? (f = t.wrapperEl.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), t.wrapperEl.append(f)), f.style.height = `${o}px`) : (f = e.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), e.append(f))));
                for (let e = 0; e < n.length; e += 1) {
                    const t = n[e];
                    let i = e;
                    p && (i = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
                    let o = 90 * i,
                        a = Math.floor(o / 360);
                    s && (o = -o, a = Math.floor(-o / 360));
                    const c = Math.max(Math.min(t.progress, 1), -1);
                    let f = 0,
                        g = 0,
                        v = 0;
                    i % 4 == 0 ? (f = 4 * -a * l, v = 0) : (i - 1) % 4 == 0 ? (f = 0, v = 4 * -a * l) : (i - 2) % 4 == 0 ? (f = l + 4 * a * l, v = l) : (i - 3) % 4 == 0 && (f = -l, v = 3 * l + 4 * l * a), s && (f = -f), d || (g = f, f = 0);
                    const y = `rotateX(${h(d?0:-o)}deg) rotateY(${h(d?o:0)}deg) translate3d(${f}px, ${g}px, ${v}px)`;
                    c <= 1 && c > -1 && (m = 90 * i + 90 * c, s && (m = 90 * -i - 90 * c)), t.style.transform = y, u.slideShadows && r(t, c, d)
                }
                if (i.style.transformOrigin = `50% 50% -${l/2}px`, i.style["-webkit-transform-origin"] = `50% 50% -${l/2}px`, u.shadow)
                    if (d) f.style.transform = `translate3d(0px, ${o/2+u.shadowOffset}px, ${-o/2}px) rotateX(89.99deg) rotateZ(0deg) scale(${u.shadowScale})`;
                    else {
                        const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
                            t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                            i = u.shadowScale,
                            n = u.shadowScale / t,
                            r = u.shadowOffset;
                        f.style.transform = `scale3d(${i}, 1, ${n}) translate3d(0px, ${a/2+r}px, ${-a/2/n}px) rotateX(-89.99deg)`
                    } const g = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -l / 2 : 0;
                i.style.transform = `translate3d(0px,0,${g}px) rotateX(${h(t.isHorizontal()?0:m)}deg) rotateY(${h(t.isHorizontal()?-m:0)}deg)`, i.style.setProperty("--swiper-cube-translate-z", `${g}px`)
            },
            setTransition: e => {
                const {
                    el: i,
                    slides: n
                } = t;
                if (n.forEach((t => {
                        t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                            t.style.transitionDuration = `${e}ms`
                        }))
                    })), t.params.cubeEffect.shadow && !t.isHorizontal()) {
                    const t = i.querySelector(".swiper-cube-shadow");
                    t && (t.style.transitionDuration = `${e}ms`)
                }
            },
            recreateShadows: () => {
                const e = t.isHorizontal();
                t.slides.forEach((t => {
                    const i = Math.max(Math.min(t.progress, 1), -1);
                    r(t, i, e)
                }))
            },
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            flipEffect: {
                slideShadows: !0,
                limitRotation: !0
            }
        });
        const r = (e, i) => {
            let n = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                r = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            n || (n = me("flip", e, t.isHorizontal() ? "left" : "top")), r || (r = me("flip", e, t.isHorizontal() ? "right" : "bottom")), n && (n.style.opacity = Math.max(-i, 0)), r && (r.style.opacity = Math.max(i, 0))
        };
        de({
            effect: "flip",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    rtlTranslate: i
                } = t, n = t.params.flipEffect, o = T(t);
                for (let a = 0; a < e.length; a += 1) {
                    const s = e[a];
                    let l = s.progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(s.progress, 1), -1));
                    const c = s.swiperSlideOffset;
                    let h = -180 * l,
                        u = 0,
                        d = t.params.cssMode ? -c - t.translate : -c,
                        p = 0;
                    t.isHorizontal() ? i && (h = -h) : (p = d, d = 0, u = -h, h = 0), s.style.zIndex = -Math.abs(Math.round(l)) + e.length, n.slideShadows && r(s, l);
                    const f = `translate3d(${d}px, ${p}px, 0px) rotateX(${o(u)}deg) rotateY(${o(h)}deg)`;
                    pe(0, s).style.transform = f
                }
            },
            setTransition: e => {
                const i = t.slides.map((e => f(e)));
                i.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), fe({
                    swiper: t,
                    duration: e,
                    transformElements: i
                })
            },
            recreateShadows: () => {
                t.params.flipEffect, t.slides.forEach((e => {
                    let i = e.progress;
                    t.params.flipEffect.limitRotation && (i = Math.max(Math.min(e.progress, 1), -1)), r(e, i)
                }))
            },
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0
            }
        }), de({
            effect: "coverflow",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    width: e,
                    height: i,
                    slides: n,
                    slidesSizesGrid: r
                } = t, o = t.params.coverflowEffect, a = t.isHorizontal(), s = t.translate, l = a ? e / 2 - s : i / 2 - s, c = a ? o.rotate : -o.rotate, h = o.depth, u = T(t);
                for (let e = 0, t = n.length; e < t; e += 1) {
                    const t = n[e],
                        i = r[e],
                        s = (l - t.swiperSlideOffset - i / 2) / i,
                        d = "function" == typeof o.modifier ? o.modifier(s) : s * o.modifier;
                    let p = a ? c * d : 0,
                        f = a ? 0 : c * d,
                        m = -h * Math.abs(d),
                        g = o.stretch;
                    "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(o.stretch) / 100 * i);
                    let v = a ? 0 : g * d,
                        y = a ? g * d : 0,
                        b = 1 - (1 - o.scale) * Math.abs(d);
                    Math.abs(y) < .001 && (y = 0), Math.abs(v) < .001 && (v = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(f) < .001 && (f = 0), Math.abs(b) < .001 && (b = 0);
                    const x = `translate3d(${y}px,${v}px,${m}px)  rotateX(${u(f)}deg) rotateY(${u(p)}deg) scale(${b})`;
                    if (pe(0, t).style.transform = x, t.style.zIndex = 1 - Math.abs(Math.round(d)), o.slideShadows) {
                        let e = a ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"),
                            i = a ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
                        e || (e = me("coverflow", t, a ? "left" : "top")), i || (i = me("coverflow", t, a ? "right" : "bottom")), e && (e.style.opacity = d > 0 ? d : 0), i && (i.style.opacity = -d > 0 ? -d : 0)
                    }
                }
            },
            setTransition: e => {
                t.slides.map((e => f(e))).forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                }))
            },
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            creativeEffect: {
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const r = e => "string" == typeof e ? e : `${e}px`;
        de({
            effect: "creative",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    wrapperEl: i,
                    slidesSizesGrid: n
                } = t, o = t.params.creativeEffect, {
                    progressMultiplier: a
                } = o, s = t.params.centeredSlides, l = T(t);
                if (s) {
                    const e = n[0] / 2 - t.params.slidesOffsetBefore || 0;
                    i.style.transform = `translateX(calc(50% - ${e}px))`
                }
                for (let i = 0; i < e.length; i += 1) {
                    const n = e[i],
                        c = n.progress,
                        h = Math.min(Math.max(n.progress, -o.limitProgress), o.limitProgress);
                    let u = h;
                    s || (u = Math.min(Math.max(n.originalProgress, -o.limitProgress), o.limitProgress));
                    const d = n.swiperSlideOffset,
                        p = [t.params.cssMode ? -d - t.translate : -d, 0, 0],
                        f = [0, 0, 0];
                    let m = !1;
                    t.isHorizontal() || (p[1] = p[0], p[0] = 0);
                    let g = {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        scale: 1,
                        opacity: 1
                    };
                    h < 0 ? (g = o.next, m = !0) : h > 0 && (g = o.prev, m = !0), p.forEach(((e, t) => {
                        p[t] = `calc(${e}px + (${r(g.translate[t])} * ${Math.abs(h*a)}))`
                    })), f.forEach(((e, t) => {
                        let i = g.rotate[t] * Math.abs(h * a);
                        f[t] = i
                    })), n.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                    const v = p.join(", "),
                        y = `rotateX(${l(f[0])}deg) rotateY(${l(f[1])}deg) rotateZ(${l(f[2])}deg)`,
                        b = u < 0 ? `scale(${1+(1-g.scale)*u*a})` : `scale(${1-(1-g.scale)*u*a})`,
                        x = u < 0 ? 1 + (1 - g.opacity) * u * a : 1 - (1 - g.opacity) * u * a,
                        w = `translate3d(${v}) ${y} ${b}`;
                    if (m && g.shadow || !m) {
                        let e = n.querySelector(".swiper-slide-shadow");
                        if (!e && g.shadow && (e = me("creative", n)), e) {
                            const t = o.shadowPerProgress ? h * (1 / o.limitProgress) : h;
                            e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                        }
                    }
                    const _ = pe(0, n);
                    _.style.transform = w, _.style.opacity = x, g.origin && (_.style.transformOrigin = g.origin)
                }
            },
            setTransition: e => {
                const i = t.slides.map((e => f(e)));
                i.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), fe({
                    swiper: t,
                    duration: e,
                    transformElements: i,
                    allSlides: !0
                })
            },
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function(e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            cardsEffect: {
                slideShadows: !0,
                rotate: !0,
                perSlideRotate: 2,
                perSlideOffset: 8
            }
        }), de({
            effect: "cards",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    activeIndex: i,
                    rtlTranslate: n
                } = t, r = t.params.cardsEffect, {
                    startTranslate: o,
                    isTouched: a
                } = t.touchEventsData, s = n ? -t.translate : t.translate;
                for (let l = 0; l < e.length; l += 1) {
                    const c = e[l],
                        h = c.progress,
                        u = Math.min(Math.max(h, -4), 4);
                    let d = c.swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (d -= e[0].swiperSlideOffset);
                    let p = t.params.cssMode ? -d - t.translate : -d,
                        f = 0;
                    const m = -100 * Math.abs(u);
                    let g = 1,
                        v = -r.perSlideRotate * u,
                        y = r.perSlideOffset - .75 * Math.abs(u);
                    const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
                        x = (b === i || b === i - 1) && u > 0 && u < 1 && (a || t.params.cssMode) && s < o,
                        w = (b === i || b === i + 1) && u < 0 && u > -1 && (a || t.params.cssMode) && s > o;
                    if (x || w) {
                        const e = (1 - Math.abs((Math.abs(u) - .5) / .5)) ** .5;
                        v += -28 * u * e, g += -.5 * e, y += 96 * e, f = -25 * e * Math.abs(u) + "%"
                    }
                    if (p = u < 0 ? `calc(${p}px ${n?"-":"+"} (${y*Math.abs(u)}%))` : u > 0 ? `calc(${p}px ${n?"-":"+"} (-${y*Math.abs(u)}%))` : `${p}px`, !t.isHorizontal()) {
                        const e = f;
                        f = p, p = e
                    }
                    const _ = u < 0 ? "" + (1 + (1 - g) * u) : "" + (1 - (1 - g) * u),
                        E = `\n        translate3d(${p}, ${f}, ${m}px)\n        rotateZ(${r.rotate?n?-v:v:0}deg)\n        scale(${_})\n      `;
                    if (r.slideShadows) {
                        let e = c.querySelector(".swiper-slide-shadow");
                        e || (e = me("cards", c)), e && (e.style.opacity = Math.min(Math.max((Math.abs(u) - .5) / .5, 0), 1))
                    }
                    c.style.zIndex = -Math.abs(Math.round(h)) + e.length, pe(0, c).style.transform = E
                }
            },
            setTransition: e => {
                const i = t.slides.map((e => f(e)));
                i.forEach((t => {
                    t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }))
                })), fe({
                    swiper: t,
                    duration: e,
                    transformElements: i
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({
                _loopSwapReset: !1,
                watchSlidesProgress: !0,
                loopAdditionalSlides: 3,
                centeredSlides: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }];
    return re.use(ge), re
}();
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).THREE = {})
}(this, (function(e) {
    function t() {}

    function i(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function n(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function r(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }

    function o() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function a(e, t, n, r, s, l, c, h, u, d) {
        Object.defineProperty(this, "id", {
            value: mo++
        }), this.uuid = uo.generateUUID(), this.name = "", this.image = void 0 !== e ? e : a.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : a.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== s ? s : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null
    }

    function s(e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function l(e, t, i) {
        this.width = e, this.height = t, this.scissor = new s(0, 0, e, t), this.scissorTest = !1, this.viewport = new s(0, 0, e, t), i = i || {}, this.texture = new a(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function c(e, t, i) {
        l.call(this, e, t, i), this.samples = 4
    }

    function h(e, t, i) {
        l.call(this, e, t, i)
    }

    function u(e, t, i, n, r, o, s, l, c, h, u, d) {
        a.call(this, null, o, s, l, c, h, n, r, u, d), this.image = {
            data: e,
            width: t,
            height: i
        }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
    }

    function d(e, t) {
        this.min = void 0 !== e ? e : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new r(-1 / 0, -1 / 0, -1 / 0)
    }

    function p(e, t) {
        this.center = void 0 !== e ? e : new r, this.radius = void 0 !== t ? t : 0
    }

    function f(e, t) {
        this.normal = void 0 !== e ? e : new r(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function m(e, t, i, n, r, o) {
        this.planes = [void 0 !== e ? e : new f, void 0 !== t ? t : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== o ? o : new f]
    }

    function g() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function v(e) {
        var t, i = {};
        for (t in e)
            for (var n in i[t] = {}, e[t]) {
                var r = e[t][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[t][n] = r.clone() : Array.isArray(r) ? i[t][n] = r.slice() : i[t][n] = r
            }
        return i
    }

    function y(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n, r = v(e[i]);
            for (n in r) t[n] = r[n]
        }
        return t
    }

    function b(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }

    function x() {
        function e(r, o) {
            !1 !== i && (n(r, o), t.requestAnimationFrame(e))
        }
        var t = null,
            i = !1,
            n = null;
        return {
            start: function() {
                !0 !== i && null !== n && (t.requestAnimationFrame(e), i = !0)
            },
            stop: function() {
                i = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(e) {
                t = e
            }
        }
    }

    function w(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
            },
            remove: function(i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = t.get(i);
                n && (e.deleteBuffer(n.buffer), t.delete(i))
            },
            update: function(i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = t.get(i);
                if (void 0 === r) t.set(i, function(t, i) {
                    var n = t.array,
                        r = t.dynamic ? 35048 : 35044,
                        o = e.createBuffer();
                    return e.bindBuffer(i, o), e.bufferData(i, n, r), t.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
                        buffer: o,
                        type: i,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(i, n));
                else if (r.version < i.version) {
                    var o = i,
                        a = o.array,
                        s = o.updateRange;
                    e.bindBuffer(n, r.buffer), !1 === o.dynamic ? e.bufferData(n, a, 35044) : -1 === s.count ? e.bufferSubData(n, 0, a) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1), r.version = i.version
                }
            }
        }
    }

    function _(e, t, i, n, o, a) {
        this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new b, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== a ? a : 0
    }

    function E(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || E.DefaultOrder
    }

    function M() {
        this.mask = 1
    }

    function T() {
        Object.defineProperty(this, "id", {
            value: wo++
        }), this.uuid = uo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = T.DefaultUp.clone();
        var e = new r,
            t = new E,
            i = new n,
            a = new r(1, 1, 1);
        t.onChange((function() {
            i.setFromEuler(t, !1)
        })), i.onChange((function() {
            t.setFromQuaternion(i, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: a
            },
            modelViewMatrix: {
                value: new g
            },
            normalMatrix: {
                value: new o
            }
        }), this.matrix = new g, this.matrixWorld = new g, this.matrixAutoUpdate = T.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new M, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function S() {
        Object.defineProperty(this, "id", {
            value: _o += 2
        }), this.uuid = uo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function A(e, t, i) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function C(e, t, i) {
        A.call(this, new Int8Array(e), t, i)
    }

    function L(e, t, i) {
        A.call(this, new Uint8Array(e), t, i)
    }

    function D(e, t, i) {
        A.call(this, new Uint8ClampedArray(e), t, i)
    }

    function P(e, t, i) {
        A.call(this, new Int16Array(e), t, i)
    }

    function R(e, t, i) {
        A.call(this, new Uint16Array(e), t, i)
    }

    function O(e, t, i) {
        A.call(this, new Int32Array(e), t, i)
    }

    function I(e, t, i) {
        A.call(this, new Uint32Array(e), t, i)
    }

    function z(e, t, i) {
        A.call(this, new Float32Array(e), t, i)
    }

    function N(e, t, i) {
        A.call(this, new Float64Array(e), t, i)
    }

    function B() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function F(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]);
        return t
    }

    function k() {
        Object.defineProperty(this, "id", {
            value: Eo += 2
        }), this.uuid = uo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    function U(e, t, i, n, r, o) {
        S.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        }, this.fromBufferGeometry(new H(e, t, i, n, r, o)), this.mergeVertices()
    }

    function H(e, t, i, n, o, a) {
        function s(e, t, i, n, o, a, s, m, g, v, y) {
            var b = a / g,
                x = s / v,
                w = a / 2,
                _ = s / 2,
                E = m / 2;
            s = g + 1;
            var M, T, S = v + 1,
                A = a = 0,
                C = new r;
            for (T = 0; T < S; T++) {
                var L = T * x - _;
                for (M = 0; M < s; M++) C[e] = (M * b - w) * n, C[t] = L * o, C[i] = E, h.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[i] = 0 < m ? 1 : -1, u.push(C.x, C.y, C.z), d.push(M / g), d.push(1 - T / v), a += 1
            }
            for (T = 0; T < v; T++)
                for (M = 0; M < g; M++) e = p + M + s * (T + 1), t = p + (M + 1) + s * (T + 1), i = p + (M + 1) + s * T, c.push(p + M + s * T, e, i), c.push(e, t, i), A += 6;
            l.addGroup(f, A, y), f += A, p += a
        }
        k.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: o,
            depthSegments: a
        };
        var l = this;
        e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, a = Math.floor(a) || 1;
        var c = [],
            h = [],
            u = [],
            d = [],
            p = 0,
            f = 0;
        s("z", "y", "x", -1, -1, i, t, e, a, o, 0), s("z", "y", "x", 1, -1, i, t, -e, a, o, 1), s("x", "z", "y", 1, 1, e, i, t, n, a, 2), s("x", "z", "y", 1, -1, e, i, -t, n, a, 3), s("x", "y", "z", 1, -1, e, t, i, n, o, 4), s("x", "y", "z", -1, -1, e, t, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
    }

    function G(e, t, i, n) {
        S.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new j(e, t, i, n)), this.mergeVertices()
    }

    function j(e, t, i, n) {
        k.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r = (e = e || 1) / 2,
            o = (t = t || 1) / 2,
            a = (i = Math.floor(i) || 1) + 1,
            s = (n = Math.floor(n) || 1) + 1,
            l = e / i,
            c = t / n,
            h = [],
            u = [],
            d = [],
            p = [];
        for (e = 0; e < s; e++) {
            var f = e * c - o;
            for (t = 0; t < a; t++) u.push(t * l - r, -f, 0), d.push(0, 0, 1), p.push(t / i), p.push(1 - e / n)
        }
        for (e = 0; e < n; e++)
            for (t = 0; t < i; t++) r = t + a * (e + 1), o = t + 1 + a * (e + 1), s = t + 1 + a * e, h.push(t + a * e, r, s), h.push(r, o, s);
        this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
    }

    function V() {
        Object.defineProperty(this, "id", {
            value: Mo++
        }), this.uuid = uo.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function W(e) {
        V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function q(e, t) {
        this.origin = void 0 !== e ? e : new r, this.direction = void 0 !== t ? t : new r
    }

    function X(e, t, i) {
        this.a = void 0 !== e ? e : new r, this.b = void 0 !== t ? t : new r, this.c = void 0 !== i ? i : new r
    }

    function Y(e) {
        V.call(this), this.type = "MeshBasicMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Z(e, t) {
        T.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Y({
            color: 16777215 * Math.random()
        }), this.drawMode = 0, this.updateMorphTargets()
    }

    function J(e, t, i, n) {
        function r(e, i) {
            t.buffers.color.setClear(e.r, e.g, e.b, i, n)
        }
        var o, a, s = new b(0),
            l = 0,
            c = null,
            h = 0;
        return {
            getClearColor: function() {
                return s
            },
            setClearColor: function(e, t) {
                s.set(e), r(s, l = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(e) {
                r(s, l = e)
            },
            render: function(t, n, u, d) {
                n = n.background, (u = (u = e.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null), null === n ? (r(s, l), c = null, h = 0) : n && n.isColor && (r(n, 1), d = !0, c = null, h = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === a && ((a = new Z(new H(1, 1, 1), new W({
                    type: "BackgroundCubeMaterial",
                    uniforms: v(xo.cube.uniforms),
                    vertexShader: xo.cube.vertexShader,
                    fragmentShader: xo.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function(e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, Object.defineProperty(a.material, "map", {
                    get: function() {
                        return this.uniforms.tCube.value
                    }
                }), i.update(a)), d = n.isWebGLRenderTargetCube ? n.texture : n, a.material.uniforms.tCube.value = d, a.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && h === d.version || (a.material.needsUpdate = !0, c = n, h = d.version), t.unshift(a, a.geometry, a.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new Z(new j(2, 2), new W({
                    type: "BackgroundMaterial",
                    uniforms: v(xo.background.uniforms),
                    vertexShader: xo.background.vertexShader,
                    fragmentShader: xo.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), c === n && h === n.version || (o.material.needsUpdate = !0, c = n, h = n.version), t.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }

    function Q(e, t, i, n) {
        var r;
        this.setMode = function(e) {
            r = e
        }, this.render = function(t, n) {
            e.drawArrays(r, t, n), i.update(n, r)
        }, this.renderInstances = function(o, a, s) {
            if (n.isWebGL2) var l = e;
            else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), i.update(s, r, o.maxInstancedCount)
        }
    }

    function $(e, t, i) {
        function n(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var r, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
            a = void 0 !== i.precision ? i.precision : "highp",
            s = n(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s), i = !0 === i.logarithmicDepthBuffer, s = e.getParameter(34930);
        var l = e.getParameter(35660),
            c = e.getParameter(3379),
            h = e.getParameter(34076),
            u = e.getParameter(34921),
            d = e.getParameter(36347),
            p = e.getParameter(36348),
            f = e.getParameter(36349),
            m = 0 < l,
            g = o || !!t.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== r) return r;
                var i = t.get("EXT_texture_filter_anisotropic");
                return r = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: a,
            logarithmicDepthBuffer: i,
            maxTextures: s,
            maxVertexTextures: l,
            maxTextureSize: c,
            maxCubemapSize: h,
            maxAttributes: u,
            maxVertexUniforms: d,
            maxVaryings: p,
            maxFragmentUniforms: f,
            vertexTextures: m,
            floatFragmentTextures: g,
            floatVertexTextures: m && g,
            maxSamples: o ? e.getParameter(36183) : 0
        }
    }

    function K() {
        function e() {
            h.value !== n && (h.value = n, h.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
        }

        function t(e, t, n, r) {
            var o = null !== e ? e.length : 0,
                a = null;
            if (0 !== o) {
                if (a = h.value, !0 !== r || null === a)
                    for (r = n + 4 * o, t = t.matrixWorldInverse, c.getNormalMatrix(t), (null === a || a.length < r) && (a = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) l.copy(e[r]).applyMatrix4(t, c), l.normal.toArray(a, n), a[n + 3] = l.constant;
                h.value = a, h.needsUpdate = !0
            }
            return i.numPlanes = o, a
        }
        var i = this,
            n = null,
            r = 0,
            a = !1,
            s = !1,
            l = new f,
            c = new o,
            h = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function(e, i, o) {
            var s = 0 !== e.length || i || 0 !== r || a;
            return a = i, n = t(e, o, 0), r = e.length, s
        }, this.beginShadows = function() {
            s = !0, t(null)
        }, this.endShadows = function() {
            s = !1, e()
        }, this.setState = function(i, o, l, c, u, d) {
            if (!a || null === i || 0 === i.length || s && !l) s ? t(null) : e();
            else {
                var p = 4 * (l = s ? 0 : r),
                    f = u.clippingState || null;
                for (h.value = f, f = t(i, c, p, d), i = 0; i !== p; ++i) f[i] = n[i];
                u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
            }
        }
    }

    function ee(e) {
        var t = {};
        return {
            get: function(i) {
                if (void 0 !== t[i]) return t[i];
                switch (i) {
                    case "WEBGL_depth_texture":
                        var n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        n = e.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n
            }
        }
    }

    function te(e, t, i) {
        function n(e) {
            var a = e.target;
            for (var s in null !== (e = r[a.id]).index && t.remove(e.index), e.attributes) t.remove(e.attributes[s]);
            a.removeEventListener("dispose", n), delete r[a.id], (s = o[e.id]) && (t.remove(s), delete o[e.id]), i.memory.geometries--
        }
        var r = {},
            o = {};
        return {
            get: function(e, t) {
                var o = r[t.id];
                return o || (t.addEventListener("dispose", n), t.isBufferGeometry ? o = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new k).setFromObject(e)), o = t._bufferGeometry), r[t.id] = o, i.memory.geometries++, o)
            },
            update: function(e) {
                var i = e.index,
                    n = e.attributes;
                for (var r in null !== i && t.update(i, 34963), n) t.update(n[r], 34962);
                for (r in e = e.morphAttributes) {
                    n = 0;
                    for (var o = (i = e[r]).length; n < o; n++) t.update(i[n], 34962)
                }
            },
            getWireframeAttribute: function(e) {
                var i = o[e.id];
                if (i) return i;
                i = [];
                var n = e.index,
                    r = e.attributes;
                if (null !== n) {
                    r = 0;
                    for (var a = (n = n.array).length; r < a; r += 3) {
                        var s = n[r + 0],
                            l = n[r + 1],
                            c = n[r + 2];
                        i.push(s, l, l, c, c, s)
                    }
                } else
                    for (n = r.position.array, r = 0, a = n.length / 3 - 1; r < a; r += 3) s = r + 0, l = r + 1, c = r + 2, i.push(s, l, l, c, c, s);
                return i = new(65535 < F(i) ? I : R)(i, 1), t.update(i, 34963), o[e.id] = i
            }
        }
    }

    function ie(e, t, i, n) {
        var r, o, a;
        this.setMode = function(e) {
            r = e
        }, this.setIndex = function(e) {
            o = e.type, a = e.bytesPerElement
        }, this.render = function(t, n) {
            e.drawElements(r, n, o, t * a), i.update(n, r)
        }, this.renderInstances = function(s, l, c) {
            if (n.isWebGL2) var h = e;
            else if (null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, o, l * a, s.maxInstancedCount), i.update(c, r, s.maxInstancedCount)
        }
    }

    function ne(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function(e, i, n) {
                switch (n = n || 1, t.calls++, i) {
                    case 4:
                        t.triangles += e / 3 * n;
                        break;
                    case 5:
                    case 6:
                        t.triangles += n * (e - 2);
                        break;
                    case 1:
                        t.lines += e / 2 * n;
                        break;
                    case 3:
                        t.lines += n * (e - 1);
                        break;
                    case 2:
                        t.lines += n * e;
                        break;
                    case 0:
                        t.points += n * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function re(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function oe(e) {
        var t = {},
            i = new Float32Array(8);
        return {
            update: function(n, r, o, a) {
                var s = n.morphTargetInfluences,
                    l = s.length;
                if (void 0 === (n = t[r.id])) {
                    n = [];
                    for (var c = 0; c < l; c++) n[c] = [c, 0];
                    t[r.id] = n
                }
                var h = o.morphTargets && r.morphAttributes.position;
                for (o = o.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
                    var u = n[c];
                    0 !== u[1] && (h && r.removeAttribute("morphTarget" + c), o && r.removeAttribute("morphNormal" + c))
                }
                for (c = 0; c < l; c++)(u = n[c])[0] = c, u[1] = s[c];
                for (n.sort(re), c = 0; 8 > c; c++)(u = n[c]) && (s = u[0], l = u[1]) ? (h && r.addAttribute("morphTarget" + c, h[s]), o && r.addAttribute("morphNormal" + c, o[s]), i[c] = l) : i[c] = 0;
                a.getUniforms().setValue(e, "morphTargetInfluences", i)
            }
        }
    }

    function ae(e, t) {
        var i = {};
        return {
            update: function(n) {
                var r = t.render.frame,
                    o = n.geometry,
                    a = e.get(n, o);
                return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), e.update(a), i[a.id] = r), a
            },
            dispose: function() {
                i = {}
            }
        }
    }

    function se(e, t, i, n, r, o, s, l, c, h) {
        e = void 0 !== e ? e : [], a.call(this, e, void 0 !== t ? t : 301, i, n, r, o, void 0 !== s ? s : 1022, l, c, h), this.flipY = !1
    }

    function le(e, t, i, n) {
        a.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function ce(e, t, i, n) {
        a.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function he(e, t, i) {
        var n = e[0];
        if (0 >= n || 0 < n) return e;
        var r = t * i,
            o = Lo[r];
        if (void 0 === o && (o = new Float32Array(r), Lo[r] = o), 0 !== t)
            for (n.toArray(o, 0), n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(o, r);
        return o
    }

    function ue(e, t) {
        if (e.length !== t.length) return !1;
        for (var i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i]) return !1;
        return !0
    }

    function de(e, t) {
        for (var i = 0, n = t.length; i < n; i++) e[i] = t[i]
    }

    function pe(e, t) {
        var i = Do[t];
        void 0 === i && (i = new Int32Array(t), Do[t] = i);
        for (var n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
        return i
    }

    function fe(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
    }

    function me(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y) : ue(i, t) || (e.uniform2fv(this.addr, t), de(i, t))
    }

    function ge(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b) : ue(i, t) || (e.uniform3fv(this.addr, t), de(i, t))
    }

    function ve(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w) : ue(i, t) || (e.uniform4fv(this.addr, t), de(i, t))
    }

    function ye(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix2fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Oo.set(n), e.uniformMatrix2fv(this.addr, !1, Oo), de(i, n))
    }

    function be(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix3fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Ro.set(n), e.uniformMatrix3fv(this.addr, !1, Ro), de(i, n))
    }

    function xe(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? ue(i, t) || (e.uniformMatrix4fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Po.set(n), e.uniformMatrix4fv(this.addr, !1, Po), de(i, n))
    }

    function we(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || To, r)
    }

    function _e(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || So, r)
    }

    function Ee(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || Ao, r)
    }

    function Me(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || Co, r)
    }

    function Te(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
    }

    function Se(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform2iv(this.addr, t), de(i, t))
    }

    function Ae(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform3iv(this.addr, t), de(i, t))
    }

    function Ce(e, t) {
        var i = this.cache;
        ue(i, t) || (e.uniform4iv(this.addr, t), de(i, t))
    }

    function Le(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function De(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function Pe(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function Re(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function Oe(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function Ie(e, t) {
        t = he(t, this.size, 2), e.uniform2fv(this.addr, t)
    }

    function ze(e, t) {
        t = he(t, this.size, 3), e.uniform3fv(this.addr, t)
    }

    function Ne(e, t) {
        t = he(t, this.size, 4), e.uniform4fv(this.addr, t)
    }

    function Be(e, t) {
        t = he(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t)
    }

    function Fe(e, t) {
        t = he(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t)
    }

    function ke(e, t) {
        t = he(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t)
    }

    function Ue(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTexture2D(t[e] || To, r[e])
    }

    function He(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTextureCube(t[e] || Co, r[e])
    }

    function Ge(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return fe;
                case 35664:
                    return me;
                case 35665:
                    return ge;
                case 35666:
                    return ve;
                case 35674:
                    return ye;
                case 35675:
                    return be;
                case 35676:
                    return xe;
                case 35678:
                case 36198:
                    return we;
                case 35679:
                    return Ee;
                case 35680:
                    return Me;
                case 36289:
                    return _e;
                case 5124:
                case 35670:
                    return Te;
                case 35667:
                case 35671:
                    return Se;
                case 35668:
                case 35672:
                    return Ae;
                case 35669:
                case 35673:
                    return Ce
            }
        }(t.type)
    }

    function je(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return Le;
                case 35664:
                    return Ie;
                case 35665:
                    return ze;
                case 35666:
                    return Ne;
                case 35674:
                    return Be;
                case 35675:
                    return Fe;
                case 35676:
                    return ke;
                case 35678:
                    return Ue;
                case 35680:
                    return He;
                case 5124:
                case 35670:
                    return De;
                case 35667:
                case 35671:
                    return Pe;
                case 35668:
                case 35672:
                    return Re;
                case 35669:
                case 35673:
                    return Oe
            }
        }(t.type)
    }

    function Ve(e) {
        this.id = e, this.seq = [], this.map = {}
    }

    function We(e, t) {
        this.seq = [], this.map = {};
        for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) {
            var r = e.getActiveUniform(t, n),
                o = e.getUniformLocation(t, r.name),
                a = this,
                s = r.name,
                l = s.length;
            for (Io.lastIndex = 0;;) {
                var c = Io.exec(s),
                    h = Io.lastIndex,
                    u = c[1],
                    d = c[3];
                if ("]" === c[2] && (u |= 0), void 0 === d || "[" === d && h + 2 === l) {
                    s = a, r = void 0 === d ? new Ge(u, r, o) : new je(u, r, o), s.seq.push(r), s.map[r.id] = r;
                    break
                }
                void 0 === (d = a.map[u]) && (d = new Ve(u), u = a, a = d, u.seq.push(a), u.map[a.id] = a), a = d
            }
        }
    }

    function qe(e, t, i, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, i), e.compileShader(r), !0 === n && (!1 === e.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(r), function(e) {
            e = e.split("\n");
            for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(i))), r
    }

    function Xe(e) {
        switch (e) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + e)
        }
    }

    function Ye(e, t) {
        return "vec4 " + e + "( vec4 value ) { return " + (t = Xe(t))[0] + "ToLinear" + t[1] + "; }"
    }

    function Ze(e, t) {
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = Xe(t))[0] + t[1] + "; }"
    }

    function Je(e, t) {
        switch (t) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Uncharted2";
                break;
            case 4:
                t = "OptimizedCineon";
                break;
            case 5:
                t = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }

    function Qe(e) {
        return "" !== e
    }

    function $e(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function Ke(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function et(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function(e, t) {
            if (void 0 === (e = go[t])) throw Error("Can not resolve #include <" + t + ">");
            return et(e)
        }))
    }

    function tt(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function(e, t, i, n) {
            for (e = "", t = parseInt(t); t < parseInt(i); t++) e += n.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        }))
    }

    function it(e, t, i, n, r, o, a, s) {
        var l = e.context,
            c = n.defines,
            h = r.vertexShader,
            u = r.fragmentShader,
            d = "SHADOWMAP_TYPE_BASIC";
        1 === o.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT");
        var p = "ENVMAP_TYPE_CUBE",
            f = "ENVMAP_MODE_REFLECTION",
            m = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (n.envMap.mapping) {
                case 301:
                case 302:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case 302:
                case 304:
                    f = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case 0:
                    m = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    m = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    m = "ENVMAP_BLENDING_ADD"
            }
        }
        var g, v, y = 0 < e.gammaFactor ? e.gammaFactor : 1,
            b = a.isWebGL2 ? "" : function(e, t, i) {
                return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qe).join("\n")
            }(n.extensions, o, t),
            x = function(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    !1 !== n && i.push("#define " + t + " " + n)
                }
                return i.join("\n")
            }(c),
            w = l.createProgram();
        return n.isRawShaderMaterial ? (0 < (c = [x].filter(Qe).join("\n")).length && (c += "\n"), 0 < (t = [b, x].filter(Qe).join("\n")).length && (t += "\n")) : (c = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qe).join("\n"), t = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? go.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? Je("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? go.encodings_pars_fragment : "", o.mapEncoding ? Ye("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ye("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ye("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ye("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? Ze("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qe).join("\n")), h = Ke(h = $e(h = et(h), o), o), u = Ke(u = $e(u = et(u), o), o), h = tt(h), u = tt(u), a.isWebGL2 && !n.isRawShaderMaterial && (a = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== h.match(d) && null !== u.match(d) && (a = !0, h = h.replace(d, ""), u = u.replace(d, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, t = ["#version 300 es\n\n#define varying in", a ? "" : "out highp vec4 pc_fragColor;", a ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t), u = t + u, h = qe(l, 35633, c + h, e.debug.checkShaderErrors), u = qe(l, 35632, u, e.debug.checkShaderErrors), l.attachShader(w, h), l.attachShader(w, u), void 0 !== n.index0AttributeName ? l.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(w, 0, "position"), l.linkProgram(w), e.debug.checkShaderErrors && (e = l.getProgramInfoLog(w).trim(), o = l.getShaderInfoLog(h).trim(), a = l.getShaderInfoLog(u).trim(), p = d = !0, !1 === l.getProgramParameter(w, 35714) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(w, 35715), "gl.getProgramInfoLog", e, o, a)) : "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== o && "" !== a || (p = !1), p && (this.diagnostics = {
            runnable: d,
            material: n,
            programLog: e,
            vertexShader: {
                log: o,
                prefix: c
            },
            fragmentShader: {
                log: a,
                prefix: t
            }
        })), l.deleteShader(h), l.deleteShader(u), this.getUniforms = function() {
            return void 0 === g && (g = new We(l, w, s)), g
        }, this.getAttributes = function() {
            if (void 0 === v) {
                for (var e = {}, t = l.getProgramParameter(w, 35721), i = 0; i < t; i++) {
                    var n = l.getActiveAttrib(w, i).name;
                    e[n] = l.getAttribLocation(w, n)
                }
                v = e
            }
            return v
        }, this.destroy = function() {
            l.deleteProgram(w), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = r.name, this.id = zo++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = h, this.fragmentShader = u, this
    }

    function nt(e, t, i, n) {
        function r(e, t) {
            if (e) e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding);
            else var i = 3e3;
            return 3e3 === i && t && (i = 3007), i
        }
        var o = [],
            a = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            s = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(t, n, o, s, l, c, h) {
            var u = a[t.type];
            if (h.isSkinnedMesh) {
                var d = h.skeleton.bones;
                if (i.floatVertexTextures) d = 1024;
                else {
                    var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length);
                    p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p
                }
            } else d = 0;
            p = i.precision, null !== t.precision && (p = i.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", p, "instead.");
            var f = e.getRenderTarget();
            return {
                shaderID: u,
                precision: p,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: r(f ? f.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: r(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: r(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: r(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: 1 === t.normalMapType,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                fog: !!s,
                useFog: t.fog,
                fogExp: s && s.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: t.skinning && 0 < d,
                maxBones: d,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && 0 < o.length,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: 2 === t.side,
                flipSided: 1 === t.side,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }, this.getProgramCode = function(t, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            for (r = 0; r < s.length; r++) n.push(i[s[r]]);
            return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.push(e.gammaFactor), n.join()
        }, this.acquireProgram = function(r, a, s, l) {
            for (var c, h = 0, u = o.length; h < u; h++) {
                var d = o[h];
                if (d.code === l) {
                    ++(c = d).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new it(e, t, l, r, a, s, i, n), o.push(c)), c
        }, this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = o.indexOf(e);
                o[t] = o[o.length - 1], o.pop(), e.destroy()
            }
        }, this.programs = o
    }

    function rt() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var i = e.get(t);
                return void 0 === i && (i = {}, e.set(t, i)), i
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, i, n) {
                e.get(t)[i] = n
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function ot(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function at(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function st() {
        function e(e, n, r, a, s, l) {
            var c = t[i];
            return void 0 === c ? (c = {
                id: e.id,
                object: e,
                geometry: n,
                material: r,
                program: r.program || o,
                groupOrder: a,
                renderOrder: e.renderOrder,
                z: s,
                group: l
            }, t[i] = c) : (c.id = e.id, c.object = e, c.geometry = n, c.material = r, c.program = r.program || o, c.groupOrder = a, c.renderOrder = e.renderOrder, c.z = s, c.group = l), i++, c
        }
        var t = [],
            i = 0,
            n = [],
            r = [],
            o = {
                id: -1
            };
        return {
            opaque: n,
            transparent: r,
            init: function() {
                i = 0, n.length = 0, r.length = 0
            },
            push: function(t, i, o, a, s, l) {
                t = e(t, i, o, a, s, l), (!0 === o.transparent ? r : n).push(t)
            },
            unshift: function(t, i, o, a, s, l) {
                t = e(t, i, o, a, s, l), (!0 === o.transparent ? r : n).unshift(t)
            },
            sort: function() {
                1 < n.length && n.sort(ot), 1 < r.length && r.sort(at)
            }
        }
    }

    function lt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function(i, n) {
                var r = t[i.id];
                if (void 0 === r) {
                    var o = new st;
                    t[i.id] = {}, t[i.id][n.id] = o, i.addEventListener("dispose", e)
                } else void 0 === (o = r[n.id]) && (o = new st, r[n.id] = o);
                return o
            },
            dispose: function() {
                t = {}
            }
        }
    }

    function ct() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                switch (t.type) {
                    case "DirectionalLight":
                        var n = {
                            direction: new r,
                            color: new b,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new r,
                            direction: new r,
                            color: new b,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new r,
                            color: new b,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new r,
                            skyColor: new b,
                            groundColor: new b
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new b,
                            position: new r,
                            halfWidth: new r,
                            halfHeight: new r
                        }
                }
                return e[t.id] = n
            }
        }
    }

    function ht() {
        for (var e = new ct, t = {
                id: No++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, i = 0; 9 > i; i++) t.probe.push(new r);
        var n = new r,
            o = new g,
            a = new g;
        return {
            setup: function(i, r, s) {
                for (var l = 0, c = 0, h = 0, u = 0; 9 > u; u++) t.probe[u].set(0, 0, 0);
                var d = 0,
                    p = 0,
                    f = 0,
                    m = 0,
                    g = 0;
                s = s.matrixWorldInverse, u = 0;
                for (var v = i.length; u < v; u++) {
                    var y = i[u],
                        b = y.color,
                        x = y.intensity,
                        w = y.distance,
                        _ = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight) l += b.r * x, c += b.g * x, h += b.b * x;
                    else if (y.isLightProbe)
                        for (_ = 0; 9 > _; _++) t.probe[_].addScaledVector(y.sh.coefficients[_], x);
                    else if (y.isDirectionalLight) {
                        var E = e.get(y);
                        E.color.copy(y.color).multiplyScalar(y.intensity), E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(s), (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.directionalShadowMap[d] = _, t.directionalShadowMatrix[d] = y.shadow.matrix, t.directional[d] = E, d++
                    } else y.isSpotLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), E.color.copy(b).multiplyScalar(x), E.distance = w, E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(s), E.coneCos = Math.cos(y.angle), E.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.spotShadowMap[f] = _, t.spotShadowMatrix[f] = y.shadow.matrix, t.spot[f] = E, f++) : y.isRectAreaLight ? ((E = e.get(y)).color.copy(b).multiplyScalar(x), E.position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), a.identity(), o.copy(y.matrixWorld), o.premultiply(s), a.extractRotation(o), E.halfWidth.set(.5 * y.width, 0, 0), E.halfHeight.set(0, .5 * y.height, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), t.rectArea[m] = E, m++) : y.isPointLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(s), E.color.copy(y.color).multiplyScalar(y.intensity), E.distance = y.distance, E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize, E.shadowCameraNear = x.camera.near, E.shadowCameraFar = x.camera.far), t.pointShadowMap[p] = _, t.pointShadowMatrix[p] = y.shadow.matrix, t.point[p] = E, p++) : y.isHemisphereLight && ((E = e.get(y)).direction.setFromMatrixPosition(y.matrixWorld), E.direction.transformDirection(s), E.direction.normalize(), E.skyColor.copy(y.color).multiplyScalar(x), E.groundColor.copy(y.groundColor).multiplyScalar(x), t.hemi[g] = E, g++)
                }
                t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = d, t.spot.length = f, t.rectArea.length = m, t.point.length = p, t.hemi.length = g, t.hash.stateID = t.id, t.hash.directionalLength = d, t.hash.pointLength = p, t.hash.spotLength = f, t.hash.rectAreaLength = m, t.hash.hemiLength = g, t.hash.shadowsLength = r.length
            },
            state: t
        }
    }

    function ut() {
        var e = new ht,
            t = [],
            i = [];
        return {
            init: function() {
                t.length = 0, i.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: i,
                lights: e
            },
            setupLights: function(n) {
                e.setup(t, i, n)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }

    function dt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function(i, n) {
                if (void 0 === t[i.id]) {
                    var r = new ut;
                    t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)
                } else void 0 === t[i.id][n.id] ? (r = new ut, t[i.id][n.id] = r) : r = t[i.id][n.id];
                return r
            },
            dispose: function() {
                t = {}
            }
        }
    }

    function pt(e) {
        V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(e)
    }

    function ft(e) {
        V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(e)
    }

    function mt(e, t, n) {
        function o(t, i, n, r, o, a) {
            var s = t.geometry,
                l = v,
                c = t.customDepthMaterial;
            return n && (l = y, c = t.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (s && s.isBufferGeometry ? c = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (c = s.morphTargets && 0 < s.morphTargets.length)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), s = 0, c && (s |= 1), (t = t.isSkinnedMesh && i.skinning) && (s |= 2), l = l[s]), e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (s = l.uuid, c = i.uuid, void 0 === (t = b[s]) && (t = {}, b[s] = t), void 0 === (s = t[c]) && (s = l.clone(), t[c] = s), l = s), l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : x[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = a), l
        }

        function a(i, n, r, s) {
            if (!1 !== i.visible) {
                if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || c.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                    var l = t.update(i),
                        h = i.material;
                    if (Array.isArray(h))
                        for (var u = l.groups, d = 0, p = u.length; d < p; d++) {
                            var m = u[d],
                                g = h[m.materialIndex];
                            g && g.visible && (g = o(i, g, s, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, m))
                        } else h.visible && (g = o(i, h, s, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, null))
                }
                for (l = 0, h = (i = i.children).length; l < h; l++) a(i[l], n, r, s)
            }
        }
        var c = new m,
            h = new g,
            u = new i,
            d = new i(n, n),
            p = new r,
            f = new r,
            v = Array(4),
            y = Array(4),
            b = {},
            x = {
                0: 1,
                1: 0,
                2: 2
            },
            w = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)],
            _ = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)],
            E = [new s, new s, new s, new s, new s, new s];
        for (n = 0; 4 !== n; ++n) {
            var M = !!(1 & n),
                T = !!(2 & n),
                S = new pt({
                    depthPacking: 3201,
                    morphTargets: M,
                    skinning: T
                });
            v[n] = S, M = new ft({
                morphTargets: M,
                skinning: T
            }), y[n] = M
        }
        var A = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, i, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== t.length) {
                var r = e.getRenderTarget(),
                    o = e.getActiveCubeFace(),
                    s = e.getActiveMipMapLevel(),
                    m = e.state;
                m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
                for (var g, v = 0, y = t.length; v < y; v++) {
                    var b = t[v];
                    g = b.shadow;
                    var x = b && b.isPointLight;
                    if (void 0 === g) console.warn("THREE.WebGLShadowMap:", b, "has no shadow.");
                    else {
                        var M = g.camera;
                        if (u.copy(g.mapSize), u.min(d), x) {
                            var T = u.x,
                                S = u.y;
                            E[0].set(2 * T, S, T, S), E[1].set(0, S, T, S), E[2].set(3 * T, S, T, S), E[3].set(T, S, T, S), E[4].set(3 * T, 0, T, S), E[5].set(T, 0, T, S), u.x *= 4, u.y *= 2
                        }
                        for (null === g.map && (g.map = new l(u.x, u.y, {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            }), g.map.texture.name = b.name + ".shadowMap", M.updateProjectionMatrix()), g.isSpotLightShadow && g.update(b), T = g.map, S = g.matrix, f.setFromMatrixPosition(b.matrixWorld), M.position.copy(f), x ? (g = 6, S.makeTranslation(-f.x, -f.y, -f.z)) : (g = 1, p.setFromMatrixPosition(b.target.matrixWorld), M.lookAt(p), M.updateMatrixWorld(), S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), S.multiply(M.projectionMatrix), S.multiply(M.matrixWorldInverse)), e.setRenderTarget(T), e.clear(), b = 0; b < g; b++) x && (p.copy(M.position), p.add(w[b]), M.up.copy(_[b]), M.lookAt(p), M.updateMatrixWorld(), m.viewport(E[b])), h.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), c.setFromMatrix(h), a(i, n, M, x)
                    }
                }
                A.needsUpdate = !1, e.setRenderTarget(r, o, s)
            }
        }
    }

    function gt(e, t, i, n) {
        function r(t, i, n) {
            var r = new Uint8Array(4),
                o = e.createTexture();
            for (e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }

        function o(i, r) {
            y[i] = 1, 0 === b[i] && (e.enableVertexAttribArray(i), b[i] = 1), x[i] !== r && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), x[i] = r)
        }

        function a(t) {
            !0 !== w[t] && (e.enable(t), w[t] = !0)
        }

        function l(t) {
            !1 !== w[t] && (e.disable(t), w[t] = !1)
        }

        function c(t, n, r, o, s, c, h, u) {
            if (0 === t) M && (l(3042), M = !1);
            else if (M || (a(3042), M = !0), 5 !== t) {
                if (t !== T || u !== R) {
                    if (100 === S && 100 === L || (e.blendEquation(32774), L = S = 100), u) switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    P = D = C = A = null, T = t, R = u
                }
            } else s = s || n, c = c || r, h = h || o, n === S && s === L || (e.blendEquationSeparate(i.convert(n), i.convert(s)), S = n, L = s), r === A && o === C && c === D && h === P || (e.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(c), i.convert(h)), A = r, C = o, D = c, P = h), T = t, R = null
        }

        function h(t) {
            O !== t && (t ? e.frontFace(2304) : e.frontFace(2305), O = t)
        }

        function u(t) {
            0 !== t ? (a(2884), t !== I && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : l(2884), I = t
        }

        function d(t, i, n) {
            t ? (a(32823), (N !== i || B !== n) && (e.polygonOffset(i, n), N = i, B = n)) : l(32823)
        }

        function p(t) {
            void 0 === t && (t = 33984 + F - 1), U !== t && (e.activeTexture(t), U = t)
        }
        var f = new function() {
                var t = !1,
                    i = new s,
                    n = null,
                    r = new s(0, 0, 0, 0);
                return {
                    setMask: function(i) {
                        n === i || t || (e.colorMask(i, i, i, i), n = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, n, o, a, s) {
                        !0 === s && (t *= a, n *= a, o *= a), i.set(t, n, o, a), !1 === r.equals(i) && (e.clearColor(t, n, o, a), r.copy(i))
                    },
                    reset: function() {
                        t = !1, n = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            m = new function() {
                var t = !1,
                    i = null,
                    n = null,
                    r = null;
                return {
                    setTest: function(e) {
                        e ? a(2929) : l(2929)
                    },
                    setMask: function(n) {
                        i === n || t || (e.depthMask(n), i = n)
                    },
                    setFunc: function(t) {
                        if (n !== t) {
                            if (t) switch (t) {
                                case 0:
                                    e.depthFunc(512);
                                    break;
                                case 1:
                                    e.depthFunc(519);
                                    break;
                                case 2:
                                    e.depthFunc(513);
                                    break;
                                case 3:
                                default:
                                    e.depthFunc(515);
                                    break;
                                case 4:
                                    e.depthFunc(514);
                                    break;
                                case 5:
                                    e.depthFunc(518);
                                    break;
                                case 6:
                                    e.depthFunc(516);
                                    break;
                                case 7:
                                    e.depthFunc(517)
                            } else e.depthFunc(515);
                            n = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        r !== t && (e.clearDepth(t), r = t)
                    },
                    reset: function() {
                        t = !1, r = n = i = null
                    }
                }
            },
            g = new function() {
                var t = !1,
                    i = null,
                    n = null,
                    r = null,
                    o = null,
                    s = null,
                    c = null,
                    h = null,
                    u = null;
                return {
                    setTest: function(e) {
                        e ? a(2960) : l(2960)
                    },
                    setMask: function(n) {
                        i === n || t || (e.stencilMask(n), i = n)
                    },
                    setFunc: function(t, i, a) {
                        n === t && r === i && o === a || (e.stencilFunc(t, i, a), n = t, r = i, o = a)
                    },
                    setOp: function(t, i, n) {
                        s === t && c === i && h === n || (e.stencilOp(t, i, n), s = t, c = i, h = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        u !== t && (e.clearStencil(t), u = t)
                    },
                    reset: function() {
                        t = !1, u = h = c = s = o = r = n = i = null
                    }
                }
            },
            v = e.getParameter(34921),
            y = new Uint8Array(v),
            b = new Uint8Array(v),
            x = new Uint8Array(v),
            w = {},
            _ = null,
            E = null,
            M = null,
            T = null,
            S = null,
            A = null,
            C = null,
            L = null,
            D = null,
            P = null,
            R = !1,
            O = null,
            I = null,
            z = null,
            N = null,
            B = null,
            F = e.getParameter(35661),
            k = !1;
        v = 0, -1 !== (v = e.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), k = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), k = 2 <= v);
        var U = null,
            H = {},
            G = new s,
            j = new s,
            V = {};
        return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), a(2929), m.setFunc(3), h(!1), u(1), a(2884), c(0), {
            buffers: {
                color: f,
                depth: m,
                stencil: g
            },
            initAttributes: function() {
                for (var e = 0, t = y.length; e < t; e++) y[e] = 0
            },
            enableAttribute: function(e) {
                o(e, 0)
            },
            enableAttributeAndDivisor: o,
            disableUnusedAttributes: function() {
                for (var t = 0, i = b.length; t !== i; ++t) b[t] !== y[t] && (e.disableVertexAttribArray(t), b[t] = 0)
            },
            enable: a,
            disable: l,
            getCompressedTextureFormats: function() {
                if (null === _ && (_ = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var i = e.getParameter(34467), n = 0; n < i.length; n++) _.push(i[n]);
                return _
            },
            useProgram: function(t) {
                return E !== t && (e.useProgram(t), E = t, !0)
            },
            setBlending: c,
            setMaterial: function(e, t) {
                2 === e.side ? l(2884) : a(2884);
                var i = 1 === e.side;
                t && (i = !i), h(i), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), d(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: h,
            setCullFace: u,
            setLineWidth: function(t) {
                t !== z && (k && e.lineWidth(t), z = t)
            },
            setPolygonOffset: d,
            setScissorTest: function(e) {
                e ? a(3089) : l(3089)
            },
            activeTexture: p,
            bindTexture: function(t, i) {
                null === U && p();
                var n = H[U];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, H[U] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || V[t]), n.type = t, n.texture = i)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === G.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), G.copy(t))
            },
            viewport: function(t) {
                !1 === j.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), j.copy(t))
            },
            reset: function() {
                for (var t = 0; t < b.length; t++) 1 === b[t] && (e.disableVertexAttribArray(t), b[t] = 0);
                w = {}, U = _ = null, H = {}, I = O = T = E = null, f.reset(), m.reset(), g.reset()
            }
        }
    }

    function vt(e, t, i, n, r, o, a) {
        function s(e, t) {
            return A ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function l(e, t, i, n) {
            var r = 1;
            if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), 1 > r || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (n = t ? uo.floorPowerOfTwo : Math.floor)(r * e.width), r = n(r * e.height), void 0 === T && (T = s(t, r)), (i = i ? s(t, r) : T).width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + r + ")."), i;
                "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
            }
            return e
        }

        function c(e) {
            return uo.isPowerOfTwo(e.width) && uo.isPowerOfTwo(e.height)
        }

        function h(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }

        function u(t, i, r, o) {
            e.generateMipmap(t), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }

        function d(e, i) {
            if (!r.isWebGL2) return e;
            var n = e;
            return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
        }

        function p(e) {
            return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
        }

        function f(t) {
            (t = t.target).removeEventListener("dispose", f);
            var i = n.get(t);
            void 0 !== i.__webglInit && (e.deleteTexture(i.__webglTexture), n.remove(t)), t.isVideoTexture && delete S[t.id], a.memory.textures--
        }

        function m(t) {
            (t = t.target).removeEventListener("dispose", m);
            var i = n.get(t),
                r = n.get(t.texture);
            if (t) {
                if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                    for (r = 0; 6 > r; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(t.texture), n.remove(t)
            }
            a.memory.textures--
        }

        function g(e, t) {
            var r = n.get(e);
            if (e.isVideoTexture) {
                var o = e.id,
                    s = a.render.frame;
                S[o] !== s && (S[o] = s, e.update())
            }
            if (0 < e.version && r.__version !== e.version)
                if (void 0 === (o = e.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void w(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                } i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture)
        }

        function v(t, a) {
            var s = n.get(t);
            if (6 === t.image.length)
                if (0 < t.version && s.__version !== t.version) {
                    x(s, t), i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture), e.pixelStorei(37440, t.flipY), a = t && t.isCompressedTexture;
                    for (var p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; 6 > m; m++) f[m] = a || p ? p ? t.image[m].image : t.image[m] : l(t.image[m], !1, !0, r.maxCubemapSize);
                    var g = f[0],
                        v = c(g) || r.isWebGL2,
                        y = o.convert(t.format),
                        w = o.convert(t.type),
                        _ = d(y, w);
                    for (b(34067, t, v), m = 0; 6 > m; m++)
                        if (a)
                            for (var E, M = f[m].mipmaps, T = 0, S = M.length; T < S; T++) E = M[T], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, T, _, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, T, _, E.width, E.height, 0, y, w, E.data);
                        else p ? i.texImage2D(34069 + m, 0, _, f[m].width, f[m].height, 0, y, w, f[m].data) : i.texImage2D(34069 + m, 0, _, y, w, f[m]);
                    s.__maxMipLevel = a ? M.length - 1 : 0, h(t, v) && u(34067, t, g.width, g.height), s.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture)
        }

        function y(e, t) {
            i.activeTexture(33984 + t), i.bindTexture(34067, n.get(e).__webglTexture)
        }

        function b(i, a, s) {
            s ? (e.texParameteri(i, 10242, o.convert(a.wrapS)), e.texParameteri(i, 10243, o.convert(a.wrapT)), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, o.convert(a.wrapR)), e.texParameteri(i, 10240, o.convert(a.magFilter)), e.texParameteri(i, 10241, o.convert(a.minFilter))) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, p(a.magFilter)), e.texParameteri(i, 10241, p(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(s = t.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === t.get("OES_texture_float_linear") || 1016 === a.type && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear")) || !(1 < a.anisotropy || n.get(a).__currentAnisotropy) || (e.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
        }

        function x(t, i) {
            void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), a.memory.textures++)
        }

        function w(t, n, a) {
            var s = 3553;
            n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), x(t, n), i.activeTexture(33984 + a), i.bindTexture(s, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), a = (a = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === c(n.image);
            var p = c(a = l(n.image, a, !1, r.maxTextureSize)) || r.isWebGL2,
                f = o.convert(n.format),
                m = o.convert(n.type),
                g = d(f, m);
            b(s, n, p);
            var v = n.mipmaps;
            if (n.isDepthTexture) {
                if (g = 6402, 1015 === n.type) {
                    if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                    g = 36012
                } else r.isWebGL2 && (g = 33189);
                1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, null)
            } else if (n.isDataTexture)
                if (0 < v.length && p) {
                    for (var y = 0, w = v.length; y < w; y++) s = v[y], i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                    n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
                } else i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (y = 0, w = v.length; y < w; y++) s = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data);
                t.__maxMipLevel = v.length - 1
            } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), t.__maxMipLevel = 0;
            else if (0 < v.length && p) {
                for (y = 0, w = v.length; y < w; y++) s = v[y], i.texImage2D(3553, y, g, f, m, s);
                n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
            } else i.texImage2D(3553, 0, g, f, m, a), t.__maxMipLevel = 0;
            h(n, p) && u(3553, n, a.width, a.height), t.__version = n.version, n.onUpdate && n.onUpdate(n)
        }

        function _(t, r, a, s) {
            var l = o.convert(r.texture.format),
                c = o.convert(r.texture.type),
                h = d(l, c);
            i.texImage2D(s, 0, h, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, s, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
        }

        function E(t, i, n) {
            e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer ? (n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : e.renderbufferStorage(36161, 33189, i.width, i.height), e.framebufferRenderbuffer(36160, 36096, 36161, t)) : i.depthBuffer && i.stencilBuffer ? (n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)) : (t = d(t = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, t, i.width, i.height)) : e.renderbufferStorage(36161, t, i.width, i.height)), e.bindRenderbuffer(36161, null)
        }

        function M(e) {
            return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
        }
        var T, S = {},
            A = "undefined" != typeof OffscreenCanvas,
            C = 0,
            L = !1,
            D = !1;
        this.allocateTextureUnit = function() {
            var e = C;
            return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), C += 1, e
        }, this.resetTextureUnits = function() {
            C = 0
        }, this.setTexture2D = g, this.setTexture2DArray = function(e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function(e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(t) {
            var s = n.get(t),
                l = n.get(t.texture);
            t.addEventListener("dispose", m), l.__webglTexture = e.createTexture(), a.memory.textures++;
            var p = !0 === t.isWebGLRenderTargetCube,
                f = !0 === t.isWebGLMultisampleRenderTarget,
                v = c(t) || r.isWebGL2;
            if (p)
                for (s.__webglFramebuffer = [], f = 0; 6 > f; f++) s.__webglFramebuffer[f] = e.createFramebuffer();
            else if (s.__webglFramebuffer = e.createFramebuffer(), f)
                if (r.isWebGL2) {
                    s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, s.__webglColorRenderbuffer), f = o.convert(t.texture.format);
                    var y = o.convert(t.texture.type);
                    f = d(f, y), y = M(t), e.renderbufferStorageMultisample(36161, y, f, t.width, t.height), e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), E(s.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (p) {
                for (i.bindTexture(34067, l.__webglTexture), b(34067, t.texture, v), f = 0; 6 > f; f++) _(s.__webglFramebuffer[f], t, 36064, 34069 + f);
                h(t.texture, v) && u(34067, t.texture, t.width, t.height), i.bindTexture(34067, null)
            } else i.bindTexture(3553, l.__webglTexture), b(3553, t.texture, v), _(s.__webglFramebuffer, t, 36064, 3553), h(t.texture, v) && u(3553, t.texture, t.width, t.height), i.bindTexture(3553, null);
            if (t.depthBuffer) {
                if (s = n.get(t), l = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
                    if (l) throw Error("target.depthTexture not supported in Cube render targets");
                    if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, s.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (n.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), s = n.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                    else {
                        if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                } else if (l)
                    for (s.__webglDepthbuffer = [], l = 0; 6 > l; l++) e.bindFramebuffer(36160, s.__webglFramebuffer[l]), s.__webglDepthbuffer[l] = e.createRenderbuffer(), E(s.__webglDepthbuffer[l], t);
                else e.bindFramebuffer(36160, s.__webglFramebuffer), s.__webglDepthbuffer = e.createRenderbuffer(), E(s.__webglDepthbuffer, t);
                e.bindFramebuffer(36160, null)
            }
        }, this.updateRenderTargetMipmap = function(e) {
            var t = e.texture,
                o = c(e) || r.isWebGL2;
            if (h(t, o)) {
                o = e.isWebGLRenderTargetCube ? 34067 : 3553;
                var a = n.get(t).__webglTexture;
                i.bindTexture(o, a), u(o, t, e.width, e.height), i.bindTexture(o, null)
            }
        }, this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (r.isWebGL2) {
                    var i = n.get(t);
                    e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer), i = t.width;
                    var o = t.height,
                        a = 16384;
                    t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024), e.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === L && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), L = !0), e = e.texture), g(e, t)
        }, this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === D && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), D = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t)
        }
    }

    function yt(e, t, i) {
        return {
            convert: function(e) {
                if (1e3 === e) return 10497;
                if (1001 === e) return 33071;
                if (1002 === e) return 33648;
                if (1003 === e) return 9728;
                if (1004 === e) return 9984;
                if (1005 === e) return 9986;
                if (1006 === e) return 9729;
                if (1007 === e) return 9985;
                if (1008 === e) return 9987;
                if (1009 === e) return 5121;
                if (1017 === e) return 32819;
                if (1018 === e) return 32820;
                if (1019 === e) return 33635;
                if (1010 === e) return 5120;
                if (1011 === e) return 5122;
                if (1012 === e) return 5123;
                if (1013 === e) return 5124;
                if (1014 === e) return 5125;
                if (1015 === e) return 5126;
                if (1016 === e) {
                    if (i.isWebGL2) return 5131;
                    var n = t.get("OES_texture_half_float");
                    if (null !== n) return n.HALF_FLOAT_OES
                }
                if (1021 === e) return 6406;
                if (1022 === e) return 6407;
                if (1023 === e) return 6408;
                if (1024 === e) return 6409;
                if (1025 === e) return 6410;
                if (1026 === e) return 6402;
                if (1027 === e) return 34041;
                if (1028 === e) return 6403;
                if (100 === e) return 32774;
                if (101 === e) return 32778;
                if (102 === e) return 32779;
                if (200 === e) return 0;
                if (201 === e) return 1;
                if (202 === e) return 768;
                if (203 === e) return 769;
                if (204 === e) return 770;
                if (205 === e) return 771;
                if (206 === e) return 772;
                if (207 === e) return 773;
                if (208 === e) return 774;
                if (209 === e) return 775;
                if (210 === e) return 776;
                if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e && null !== (n = t.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (n = t.get("WEBGL_compressed_texture_astc"))) return e;
                if (103 === e || 104 === e) {
                    if (i.isWebGL2) {
                        if (103 === e) return 32775;
                        if (104 === e) return 32776
                    }
                    if (null !== (n = t.get("EXT_blend_minmax"))) {
                        if (103 === e) return n.MIN_EXT;
                        if (104 === e) return n.MAX_EXT
                    }
                }
                if (1020 === e) {
                    if (i.isWebGL2) return 34042;
                    if (null !== (n = t.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function bt() {
        T.call(this), this.type = "Group"
    }

    function xt() {
        T.call(this), this.type = "Camera", this.matrixWorldInverse = new g, this.projectionMatrix = new g, this.projectionMatrixInverse = new g
    }

    function wt(e, t, i, n) {
        xt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function _t(e) {
        wt.call(this), this.cameras = e || []
    }

    function Et(e, t, i) {
        Fo.setFromMatrixPosition(t.matrixWorld), ko.setFromMatrixPosition(i.matrixWorld);
        var n = Fo.distanceTo(ko),
            r = t.projectionMatrix.elements,
            o = i.projectionMatrix.elements,
            a = r[14] / (r[10] - 1);
        i = r[14] / (r[10] + 1);
        var s = (r[9] + 1) / r[5],
            l = (r[9] - 1) / r[5],
            c = (r[8] - 1) / r[0],
            h = (o[8] + 1) / o[0];
        r = a * c, o = a * h, c = (h = n / (-c + h)) * -c, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(c), e.translateZ(h), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld), t = a + h, a = i + h, e.projectionMatrix.makePerspective(r - c, o + (n - c), s * i / a * t, l * i / a * t, t, a)
    }

    function Mt(e) {
        function t() {
            return null !== u && !0 === u.isPresenting
        }

        function o() {
            if (t()) {
                var i = u.getEyeParameters("left");
                l = 2 * i.renderWidth * y, c = i.renderHeight * y, A = e.getPixelRatio(), e.getSize(C), e.setDrawingBufferSize(l, c, 1), M.viewport.set(0, 0, l / 2, c), T.viewport.set(l / 2, 0, l / 2, c), D.start()
            } else h.enabled && e.setDrawingBufferSize(C.width, C.height, A), D.stop()
        }

        function a(e, t) {
            null !== t && 4 === t.length && e.set(t[0] * l, t[1] * c, t[2] * l, t[3] * c)
        }
        var l, c, h = this,
            u = null,
            d = null,
            p = null,
            f = [],
            m = new g,
            v = new g,
            y = 1,
            b = "local-floor";
        "undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
        var w = new g,
            _ = new n,
            E = new r,
            M = new wt;
        M.viewport = new s, M.layers.enable(1);
        var T = new wt;
        T.viewport = new s, T.layers.enable(2);
        var S = new _t([M, T]);
        S.layers.enable(1), S.layers.enable(2);
        var A, C = new i,
            L = [];
        this.enabled = !1, this.getController = function(e) {
            var t = f[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
        }, this.getDevice = function() {
            return u
        }, this.setDevice = function(e) {
            void 0 !== e && (u = e), D.setContext(e)
        }, this.setFramebufferScaleFactor = function(e) {
            y = e
        }, this.setReferenceSpaceType = function(e) {
            b = e
        }, this.setPoseTarget = function(e) {
            void 0 !== e && (p = e)
        }, this.getCamera = function(e) {
            var i = "local-floor" === b ? 1.6 : 0;
            if (!1 === t()) return e.position.set(0, i, 0), e.rotation.set(0, 0, 0), e;
            if (u.depthNear = e.near, u.depthFar = e.far, u.getFrameData(d), "local-floor" === b) {
                var n = u.stageParameters;
                n ? m.fromArray(n.sittingToStandingTransform) : m.makeTranslation(0, i, 0)
            }
            i = d.pose, (n = null !== p ? p : e).matrix.copy(m), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (_.fromArray(i.orientation), n.quaternion.multiply(_)), null !== i.position && (_.setFromRotationMatrix(m), E.fromArray(i.position), E.applyQuaternion(_), n.position.add(E)), n.updateMatrixWorld(), M.near = e.near, T.near = e.near, M.far = e.far, T.far = e.far, M.matrixWorldInverse.fromArray(d.leftViewMatrix), T.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "local-floor" === b && (M.matrixWorldInverse.multiply(v), T.matrixWorldInverse.multiply(v)), null !== (e = n.parent) && (w.getInverse(e.matrixWorld), M.matrixWorldInverse.multiply(w), T.matrixWorldInverse.multiply(w)), M.matrixWorld.getInverse(M.matrixWorldInverse), T.matrixWorld.getInverse(T.matrixWorldInverse), M.projectionMatrix.fromArray(d.leftProjectionMatrix), T.projectionMatrix.fromArray(d.rightProjectionMatrix), Et(S, M, T), (e = u.getLayers()).length && (e = e[0], a(M.viewport, e.leftBounds), a(T.viewport, e.rightBounds));
            e: for (e = 0; e < f.length; e++) {
                i = f[e];
                t: {
                    n = e;
                    for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, s = 0, l = r.length; o < l; o++) {
                        var c = r[o];
                        if (c && ("Daydream Controller" === c.id || "Gear VR Controller" === c.id || "Oculus Go Controller" === c.id || "OpenVR Gamepad" === c.id || c.id.startsWith("Oculus Touch") || c.id.startsWith("Spatial Controller"))) {
                            if (s === n) {
                                n = c;
                                break t
                            }
                            s++
                        }
                    }
                    n = void 0
                }
                if (void 0 !== n && void 0 !== n.pose) {
                    if (null === n.pose) break e;
                    !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(m), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === L[e] && (L[e] = !1), L[e] !== n.buttons[r].pressed && (L[e] = n.buttons[r].pressed, !0 === L[e] ? i.dispatchEvent({
                        type: "selectstart"
                    }) : (i.dispatchEvent({
                        type: "selectend"
                    }), i.dispatchEvent({
                        type: "select"
                    })))
                } else i.visible = !1
            }
            return S
        }, this.getStandingMatrix = function() {
            return m
        }, this.isPresenting = t;
        var D = new x;
        this.setAnimationLoop = function(e) {
            D.setAnimationLoop(e), t() && D.start()
        }, this.submitFrame = function() {
            t() && u.submitFrame()
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
        }
    }

    function Tt(e) {
        function t() {
            return null !== l && null !== c
        }

        function i(e) {
            for (var t = 0; t < d.length; t++) p[t] === e.inputSource && d[t].dispatchEvent({
                type: e.type
            })
        }

        function n() {
            e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), b.stop()
        }

        function r(e) {
            c = e, b.setContext(l), b.start()
        }

        function o(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        var a = e.context,
            l = null,
            c = null,
            h = "local-floor",
            u = null,
            d = [],
            p = [],
            f = new wt;
        f.layers.enable(1), f.viewport = new s;
        var m = new wt;
        m.layers.enable(2), m.viewport = new s;
        var v = new _t([f, m]);
        v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function(e) {
            var t = d[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, d[e] = t), t
        }, this.setFramebufferScaleFactor = function(e) {}, this.setReferenceSpaceType = function(e) {
            h = e
        }, this.setSession = function(e) {
            null !== (l = e) && (l.addEventListener("select", i), l.addEventListener("selectstart", i), l.addEventListener("selectend", i), l.addEventListener("end", n), l.updateRenderState({
                baseLayer: new XRWebGLLayer(l, a)
            }), l.requestReferenceSpace(h).then(r), p = l.inputSources, l.addEventListener("inputsourceschange", (function() {
                p = l.inputSources, console.log(p);
                for (var e = 0; e < d.length; e++) d[e].userData.inputSource = p[e]
            })))
        }, this.getCamera = function(e) {
            if (t()) {
                var i = e.parent,
                    n = v.cameras;
                o(v, i);
                for (var r = 0; r < n.length; r++) o(n[r], i);
                for (e.matrixWorld.copy(v.matrixWorld), r = 0, i = (e = e.children).length; r < i; r++) e[r].updateMatrixWorld(!0);
                return Et(v, f, m), v
            }
            return e
        }, this.isPresenting = t;
        var y = null,
            b = new x;
        b.setAnimationLoop((function(t, i) {
            if (null !== (u = i.getViewerPose(c))) {
                var n = u.views,
                    r = l.renderState.baseLayer;
                e.setFramebuffer(r.framebuffer);
                for (var o = 0; o < n.length; o++) {
                    var a = n[o],
                        s = r.getViewport(a),
                        h = v.cameras[o];
                    h.matrix.fromArray(a.transform.inverse.matrix).getInverse(h.matrix), h.projectionMatrix.fromArray(a.projectionMatrix), h.viewport.set(s.x, s.y, s.width, s.height), 0 === o && v.matrix.copy(h.matrix)
                }
            }
            for (o = 0; o < d.length; o++) n = d[o], (r = p[o]) && null !== (r = i.getPose(r.targetRaySpace, c)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
            y && y(t)
        })), this.setAnimationLoop = function(e) {
            y = e
        }, this.dispose = function() {}, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new g
        }, this.getDevice = function() {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
        }, this.setDevice = function() {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
        }, this.submitFrame = function() {}
    }

    function St(e) {
        var t;

        function n() {
            z = new ee(ze), (N = new $(ze, z, e)).isWebGL2 || (z.get("WEBGL_depth_texture"), z.get("OES_texture_float"), z.get("OES_texture_half_float"), z.get("OES_texture_half_float_linear"), z.get("OES_standard_derivatives"), z.get("OES_element_index_uint"), z.get("ANGLE_instanced_arrays")), z.get("OES_texture_float_linear"), se = new yt(ze, z, N), (B = new gt(ze, z, se, N)).scissor(we.copy(Ae).multiplyScalar(Te)), B.viewport(xe.copy(Se).multiplyScalar(Te)), F = new ne(ze), k = new rt, U = new vt(ze, z, B, k, N, se, F), H = new w(ze), G = new te(ze, H, F), j = new ae(G, F), Y = new oe(ze), V = new nt(le, z, N, U), W = new lt, q = new dt, X = new J(le, B, j, L), Z = new Q(ze, z, F, N), re = new ie(ze, z, F, N), F.programs = V.programs, le.context = ze, le.capabilities = N, le.extensions = z, le.properties = k, le.renderLists = W, le.state = B, le.info = F
        }

        function o(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ce = !0
        }

        function a() {
            console.log("THREE.WebGLRenderer: Context Restored."), ce = !1, n()
        }

        function l(e) {
            (e = e.target).removeEventListener("dispose", l), c(e), k.remove(e)
        }

        function c(e) {
            var t = k.get(e).program;
            e.program = void 0, void 0 !== t && V.releaseProgram(t)
        }

        function h(e, t, i, n) {
            for (var r = 0, o = e.length; r < o; r++) {
                var a = e[r],
                    s = a.object,
                    l = a.geometry,
                    c = void 0 === n ? a.material : n;
                if (a = a.group, i.isArrayCamera) {
                    be = i;
                    for (var h = i.cameras, u = 0, p = h.length; u < p; u++) {
                        var f = h[u];
                        s.layers.test(f.layers) && (B.viewport(xe.copy(f.viewport)), I.setupLights(f), d(s, t, f, l, c, a))
                    }
                } else be = null, d(s, t, i, l, c, a)
            }
        }

        function d(e, i, n, r, o, a) {
            if (e.onBeforeRender(le, i, n, r, o, a), I = q.get(i, be || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                B.setMaterial(o);
                var s = f(n, i.fog, o, e);
                ge = t = null, ve = !1,
                    function(e, t) {
                        e.render((function(e) {
                            le.renderBufferImmediate(e, t)
                        }))
                    }(e, s)
            } else le.renderBufferDirect(n, i.fog, r, o, e, a);
            e.onAfterRender(le, i, n, r, o, a), I = q.get(i, be || n)
        }

        function p(e, t, i) {
            var n = k.get(e),
                r = I.state.lights,
                o = n.lightsHash,
                a = r.state.hash;
            i = V.getParameters(e, r.state, I.state.shadowsArray, t, De.numPlanes, De.numIntersection, i);
            var s = V.getProgramCode(e, i),
                h = n.program,
                u = !0;
            if (void 0 === h) e.addEventListener("dispose", l);
            else if (h.code !== s) c(e);
            else {
                if (o.stateID !== a.stateID || o.directionalLength !== a.directionalLength || o.pointLength !== a.pointLength || o.spotLength !== a.spotLength || o.rectAreaLength !== a.rectAreaLength || o.hemiLength !== a.hemiLength || o.shadowsLength !== a.shadowsLength) o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength;
                else if (void 0 !== i.shaderID) return;
                u = !1
            }
            if (u && (i.shaderID ? (s = xo[i.shaderID], n.shader = {
                    name: e.type,
                    uniforms: v(s.uniforms),
                    vertexShader: s.vertexShader,
                    fragmentShader: s.fragmentShader
                }) : n.shader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                }, e.onBeforeCompile(n.shader, le), s = V.getProgramCode(e, i), h = V.acquireProgram(e, n.shader, i, s), n.program = h, e.program = h), i = h.getAttributes(), e.morphTargets)
                for (s = e.numSupportedMorphTargets = 0; s < le.maxMorphTargets; s++) 0 <= i["morphTarget" + s] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (s = e.numSupportedMorphNormals = 0; s < le.maxMorphNormals; s++) 0 <= i["morphNormal" + s] && e.numSupportedMorphNormals++;
            i = n.shader.uniforms, (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = De.numPlanes, n.numIntersection = De.numIntersection, i.clippingPlanes = De.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength, e.lights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), e = n.program.getUniforms(), e = We.seqWithValue(e.seq, i), n.uniformsList = e
        }

        function f(e, t, i, n) {
            U.resetTextureUnits();
            var r = k.get(i),
                o = r.lightsHash,
                a = I.state.lights.state.hash;
            Pe && (Re || e !== ye) && De.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, e === ye && i.id === me), !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === a.stateID && o.directionalLength === a.directionalLength && o.pointLength === a.pointLength && o.spotLength === a.spotLength && o.rectAreaLength === a.rectAreaLength && o.hemiLength === a.hemiLength && o.shadowsLength === a.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === De.numPlanes && r.numIntersection === De.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (p(i, t, n), i.needsUpdate = !1);
            var s = !1,
                l = !1,
                c = !1;
            a = (o = r.program).getUniforms();
            var h = r.shader.uniforms;
            if (B.useProgram(o.program) && (c = l = s = !0), i.id !== me && (me = i.id, l = !0), (s || ye !== e) && (a.setValue(ze, "projectionMatrix", e.projectionMatrix), N.logarithmicDepthBuffer && a.setValue(ze, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), ye !== e && (ye = e, c = l = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && void 0 !== (s = a.map.cameraPosition) && s.setValue(ze, Ie.setFromMatrixPosition(e.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && a.setValue(ze, "viewMatrix", e.matrixWorldInverse)), i.skinning && (a.setOptional(ze, n, "bindMatrix"), a.setOptional(ze, n, "bindMatrixInverse"), e = n.skeleton))
                if (s = e.bones, N.floatVertexTextures) {
                    if (void 0 === e.boneTexture) {
                        s = Math.sqrt(4 * s.length), s = uo.ceilPowerOfTwo(s), s = Math.max(s, 4);
                        var d = new Float32Array(s * s * 4);
                        d.set(e.boneMatrices);
                        var f = new u(d, s, s, 1023, 1015);
                        f.needsUpdate = !0, e.boneMatrices = d, e.boneTexture = f, e.boneTextureSize = s
                    }
                    a.setValue(ze, "boneTexture", e.boneTexture, U), a.setValue(ze, "boneTextureSize", e.boneTextureSize)
                } else a.setOptional(ze, e, "boneMatrices");
            return l && (a.setValue(ze, "toneMappingExposure", le.toneMappingExposure), a.setValue(ze, "toneMappingWhitePoint", le.toneMappingWhitePoint), i.lights && (l = c, h.ambientLightColor.needsUpdate = l, h.lightProbe.needsUpdate = l, h.directionalLights.needsUpdate = l, h.pointLights.needsUpdate = l, h.spotLights.needsUpdate = l, h.rectAreaLights.needsUpdate = l, h.hemisphereLights.needsUpdate = l), t && i.fog && (h.fogColor.value.copy(t.color), t.isFog ? (h.fogNear.value = t.near, h.fogFar.value = t.far) : t.isFogExp2 && (h.fogDensity.value = t.density)), i.isMeshBasicMaterial ? y(h, i) : i.isMeshLambertMaterial ? (y(h, i), i.emissiveMap && (h.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (y(h, i), i.isMeshToonMaterial ? (b(h, i), i.gradientMap && (h.gradientMap.value = i.gradientMap)) : b(h, i)) : i.isMeshStandardMaterial ? (y(h, i), i.isMeshPhysicalMaterial ? (_(h, i), h.reflectivity.value = i.reflectivity, h.clearCoat.value = i.clearCoat, h.clearCoatRoughness.value = i.clearCoatRoughness) : _(h, i)) : i.isMeshMatcapMaterial ? (y(h, i), i.matcap && (h.matcap.value = i.matcap), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias), h.referencePosition.value.copy(i.referencePosition), h.nearDistance.value = i.nearDistance, h.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (y(h, i), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, i.isLineDashedMaterial && (h.dashSize.value = i.dashSize, h.totalSize.value = i.dashSize + i.gapSize, h.scale.value = i.scale)) : i.isPointsMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.size.value = i.size * Te, h.scale.value = .5 * Me, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.rotation.value = i.rotation, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (h.color.value.copy(i.color), h.opacity.value = i.opacity), void 0 !== h.ltc_1 && (h.ltc_1.value = bo.LTC_1), void 0 !== h.ltc_2 && (h.ltc_2.value = bo.LTC_2), We.upload(ze, r.uniformsList, h, U)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (We.upload(ze, r.uniformsList, h, U), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && a.setValue(ze, "center", n.center), a.setValue(ze, "modelViewMatrix", n.modelViewMatrix), a.setValue(ze, "normalMatrix", n.normalMatrix), a.setValue(ze, "modelMatrix", n.matrixWorld), o
        }

        function y(e, t) {
            if (e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = k.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map) var i = t.map;
            else t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap);
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
        }

        function b(e, t) {
            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function _(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        console.log("THREE.WebGLRenderer", "105");
        var E = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            M = void 0 !== e.context ? e.context : null,
            T = void 0 !== e.alpha && e.alpha,
            S = void 0 === e.depth || e.depth,
            A = void 0 === e.stencil || e.stencil,
            C = void 0 !== e.antialias && e.antialias,
            L = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            D = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            P = void 0 !== e.powerPreference ? e.powerPreference : "default",
            R = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            O = null,
            I = null;
        this.domElement = E, this.context = null, this.debug = {
            checkShaderErrors: !0
        }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var z, N, B, F, k, U, H, G, j, V, W, q, X, Y, Z, re, se, le = this,
            ce = !1,
            he = null,
            ue = 0,
            de = 0,
            pe = null,
            fe = null,
            me = -1,
            ge = t = null,
            ve = !1,
            ye = null,
            be = null,
            xe = new s,
            we = new s,
            _e = null,
            Ee = E.width,
            Me = E.height,
            Te = 1,
            Se = new s(0, 0, Ee, Me),
            Ae = new s(0, 0, Ee, Me),
            Ce = !1,
            Le = new m,
            De = new K,
            Pe = !1,
            Re = !1,
            Oe = new g,
            Ie = new r;
        try {
            T = {
                alpha: T,
                depth: S,
                stencil: A,
                antialias: C,
                premultipliedAlpha: L,
                preserveDrawingBuffer: D,
                powerPreference: P,
                failIfMajorPerformanceCaveat: R,
                xrCompatible: !0
            }, E.addEventListener("webglcontextlost", o, !1), E.addEventListener("webglcontextrestored", a, !1);
            var ze = M || E.getContext("webgl", T) || E.getContext("experimental-webgl", T);
            if (null === ze) {
                if (null !== E.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === ze.getShaderPrecisionFormat && (ze.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }
        n();
        var Ne = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Tt(le) : new Mt(le);
        this.vr = Ne;
        var Be = new mt(le, j, N.maxTextureSize);
        this.shadowMap = Be, this.getContext = function() {
            return ze
        }, this.getContextAttributes = function() {
            return ze.getContextAttributes()
        }, this.forceContextLoss = function() {
            var e = z.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function() {
            var e = z.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function() {
            return Te
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (Te = e, this.setSize(Ee, Me, !1))
        }, this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new i), e.set(Ee, Me)
        }, this.setSize = function(e, t, i) {
            Ne.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Ee = e, Me = t, E.width = e * Te, E.height = t * Te, !1 !== i && (E.style.width = e + "px", E.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new i), e.set(Ee * Te, Me * Te)
        }, this.setDrawingBufferSize = function(e, t, i) {
            Ee = e, Me = t, Te = i, E.width = e * i, E.height = t * i, this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new s), e.copy(xe)
        }, this.getViewport = function(e) {
            return e.copy(Se)
        }, this.setViewport = function(e, t, i, n) {
            e.isVector4 ? Se.set(e.x, e.y, e.z, e.w) : Se.set(e, t, i, n), B.viewport(xe.copy(Se).multiplyScalar(Te))
        }, this.getScissor = function(e) {
            return e.copy(Ae)
        }, this.setScissor = function(e, t, i, n) {
            e.isVector4 ? Ae.set(e.x, e.y, e.z, e.w) : Ae.set(e, t, i, n), B.scissor(we.copy(Ae).multiplyScalar(Te))
        }, this.getScissorTest = function() {
            return Ce
        }, this.setScissorTest = function(e) {
            B.setScissorTest(Ce = e)
        }, this.getClearColor = function() {
            return X.getClearColor()
        }, this.setClearColor = function() {
            X.setClearColor.apply(X, arguments)
        }, this.getClearAlpha = function() {
            return X.getClearAlpha()
        }, this.setClearAlpha = function() {
            X.setClearAlpha.apply(X, arguments)
        }, this.clear = function(e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), ze.clear(n)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            E.removeEventListener("webglcontextlost", o, !1), E.removeEventListener("webglcontextrestored", a, !1), W.dispose(), q.dispose(), k.dispose(), j.dispose(), Ne.dispose(), ke.stop()
        }, this.renderBufferImmediate = function(e, t) {
            B.initAttributes();
            var i = k.get(e);
            e.hasPositions && !i.position && (i.position = ze.createBuffer()), e.hasNormals && !i.normal && (i.normal = ze.createBuffer()), e.hasUvs && !i.uv && (i.uv = ze.createBuffer()), e.hasColors && !i.color && (i.color = ze.createBuffer()), t = t.getAttributes(), e.hasPositions && (ze.bindBuffer(34962, i.position), ze.bufferData(34962, e.positionArray, 35048), B.enableAttribute(t.position), ze.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (ze.bindBuffer(34962, i.normal), ze.bufferData(34962, e.normalArray, 35048), B.enableAttribute(t.normal), ze.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (ze.bindBuffer(34962, i.uv), ze.bufferData(34962, e.uvArray, 35048), B.enableAttribute(t.uv), ze.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (ze.bindBuffer(34962, i.color), ze.bufferData(34962, e.colorArray, 35048), B.enableAttribute(t.color), ze.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), B.disableUnusedAttributes(), ze.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, i, n, r, o, a) {
            var s = o.isMesh && 0 > o.matrixWorld.determinant();
            B.setMaterial(r, s);
            var l = f(e, i, r, o),
                c = !1;
            t === n.id && ge === l.id && ve === (!0 === r.wireframe) || (t = n.id, ge = l.id, ve = !0 === r.wireframe, c = !0), o.morphTargetInfluences && (Y.update(o, n, r, l), c = !0), s = n.index;
            var h = n.attributes.position;
            if (i = 1, !0 === r.wireframe && (s = G.getWireframeAttribute(n), i = 2), e = Z, null !== s) {
                var u = H.get(s);
                (e = re).setIndex(u)
            }
            if (c) {
                if (n && n.isInstancedBufferGeometry && !N.isWebGL2 && null === z.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    B.initAttributes(), c = n.attributes, l = l.getAttributes();
                    var d = r.defaultAttributeValues;
                    for (E in l) {
                        var p = l[E];
                        if (0 <= p) {
                            var m = c[E];
                            if (void 0 !== m) {
                                var g = m.normalized,
                                    v = m.itemSize,
                                    y = H.get(m);
                                if (void 0 !== y) {
                                    var b = y.buffer,
                                        x = y.type;
                                    if (y = y.bytesPerElement, m.isInterleavedBufferAttribute) {
                                        var w = m.data,
                                            _ = w.stride;
                                        m = m.offset, w && w.isInstancedInterleavedBuffer ? (B.enableAttributeAndDivisor(p, w.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : B.enableAttribute(p), ze.bindBuffer(34962, b), ze.vertexAttribPointer(p, v, x, g, _ * y, m * y)
                                    } else m.isInstancedBufferAttribute ? (B.enableAttributeAndDivisor(p, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : B.enableAttribute(p), ze.bindBuffer(34962, b), ze.vertexAttribPointer(p, v, x, g, 0, 0)
                                }
                            } else if (void 0 !== d && void 0 !== (g = d[E])) switch (g.length) {
                                case 2:
                                    ze.vertexAttrib2fv(p, g);
                                    break;
                                case 3:
                                    ze.vertexAttrib3fv(p, g);
                                    break;
                                case 4:
                                    ze.vertexAttrib4fv(p, g);
                                    break;
                                default:
                                    ze.vertexAttrib1fv(p, g)
                            }
                        }
                    }
                    B.disableUnusedAttributes()
                }
                null !== s && ze.bindBuffer(34963, u.buffer)
            }
            u = 1 / 0, null !== s ? u = s.count : void 0 !== h && (u = h.count), s = n.drawRange.start * i, h = null !== a ? a.start * i : 0;
            var E = Math.max(s, h);
            if (0 !== (a = Math.max(0, Math.min(u, s + n.drawRange.count * i, h + (null !== a ? a.count * i : 1 / 0)) - 1 - E + 1))) {
                if (o.isMesh)
                    if (!0 === r.wireframe) B.setLineWidth(r.wireframeLinewidth * (null === pe ? Te : 1)), e.setMode(1);
                    else switch (o.drawMode) {
                        case 0:
                            e.setMode(4);
                            break;
                        case 1:
                            e.setMode(5);
                            break;
                        case 2:
                            e.setMode(6)
                    } else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), B.setLineWidth(r * (null === pe ? Te : 1)), o.isLineSegments ? e.setMode(1) : o.isLineLoop ? e.setMode(2) : e.setMode(3)) : o.isPoints ? e.setMode(0) : o.isSprite && e.setMode(4);
                n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && e.renderInstances(n, E, a) : e.render(E, a)
            }
        }, this.compile = function(e, t) {
            (I = q.get(e, t)).init(), e.traverse((function(e) {
                e.isLight && (I.pushLight(e), e.castShadow && I.pushShadow(e))
            })), I.setupLights(t), e.traverse((function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var i = 0; i < t.material.length; i++) p(t.material[i], e.fog, t);
                    else p(t.material, e.fog, t)
            }))
        };
        var Fe = null,
            ke = new x;
        ke.setAnimationLoop((function(e) {
            Ne.isPresenting() || Fe && Fe(e)
        })), "undefined" != typeof window && ke.setContext(window), this.setAnimationLoop = function(e) {
            Fe = e, Ne.setAnimationLoop(e), ke.start()
        }, this.render = function(e, i, n, r) {
            if (void 0 !== n) {
                console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                var o = n
            }
            if (void 0 !== r) {
                console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                var a = r
            }
            i && i.isCamera ? ce || (ge = t = null, ve = !1, me = -1, ye = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), Ne.enabled && (i = Ne.getCamera(i)), (I = q.get(e, i)).init(), e.onBeforeRender(le, e, i, o || pe), Oe.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), Le.setFromMatrix(Oe), Re = this.localClippingEnabled, Pe = De.init(this.clippingPlanes, Re, i), (O = W.get(e, i)).init(), function e(t, i, n, r) {
                if (!1 !== t.visible) {
                    if (t.layers.test(i.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLight) I.pushLight(t), t.castShadow && I.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || Le.intersectsSprite(t)) {
                            r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe);
                            var o = j.update(t),
                                a = t.material;
                            a.visible && O.push(t, o, a, n, Ie.z, null)
                        }
                    } else if (t.isImmediateRenderObject) r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe), O.push(t, null, t.material, n, Ie.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || Le.intersectsObject(t)))
                        if (r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe), o = j.update(t), a = t.material, Array.isArray(a))
                            for (var s = o.groups, l = 0, c = s.length; l < c; l++) {
                                var h = s[l],
                                    u = a[h.materialIndex];
                                u && u.visible && O.push(t, o, u, n, Ie.z, h)
                            } else a.visible && O.push(t, o, a, n, Ie.z, null);
                    for (l = 0, c = (t = t.children).length; l < c; l++) e(t[l], i, n, r)
                }
            }(e, i, 0, le.sortObjects), !0 === le.sortObjects && O.sort(), Pe && De.beginShadows(), Be.render(I.state.shadowsArray, e, i), I.setupLights(i), Pe && De.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), X.render(O, e, i, a), n = O.opaque, r = O.transparent, e.overrideMaterial ? (o = e.overrideMaterial, n.length && h(n, e, i, o), r.length && h(r, e, i, o)) : (n.length && h(n, e, i), r.length && h(r, e, i)), e.onAfterRender(le, e, i), null !== pe && (U.updateRenderTargetMipmap(pe), U.updateMultisampleRenderTarget(pe)), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1), Ne.enabled && Ne.submitFrame(), I = O = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function(e) {
            he !== e && ze.bindFramebuffer(36160, e), he = e
        }, this.getActiveCubeFace = function() {
            return ue
        }, this.getActiveMipMapLevel = function() {
            return de
        }, this.getRenderTarget = function() {
            return pe
        }, this.setRenderTarget = function(e, t, i) {
            pe = e, ue = t, de = i, e && void 0 === k.get(e).__webglFramebuffer && U.setupRenderTarget(e);
            var n = he,
                r = !1;
            e ? (n = k.get(e).__webglFramebuffer, e.isWebGLRenderTargetCube ? (n = n[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? k.get(e).__webglMultisampledFramebuffer : n, xe.copy(e.viewport), we.copy(e.scissor), _e = e.scissorTest) : (xe.copy(Se).multiplyScalar(Te), we.copy(Ae).multiplyScalar(Te), _e = Ce), fe !== n && (ze.bindFramebuffer(36160, n), fe = n), B.viewport(xe), B.scissor(we), B.setScissorTest(_e), r && (e = k.get(e.texture), ze.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, i || 0))
        }, this.readRenderTargetPixels = function(e, t, i, n, r, o, a) {
            if (e && e.isWebGLRenderTarget) {
                var s = k.get(e).__webglFramebuffer;
                if (e.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                    a = !1, s !== fe && (ze.bindFramebuffer(36160, s), a = !0);
                    try {
                        var l = e.texture,
                            c = l.format,
                            h = l.type;
                        1023 !== c && se.convert(c) !== ze.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || se.convert(h) === ze.getParameter(35738) || 1015 === h && (N.isWebGL2 || z.get("OES_texture_float") || z.get("WEBGL_color_buffer_float")) || 1016 === h && (N.isWebGL2 ? z.get("EXT_color_buffer_float") : z.get("EXT_color_buffer_half_float")) ? 36053 === ze.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && ze.readPixels(t, i, n, r, se.convert(c), se.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        a && ze.bindFramebuffer(36160, fe)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(e, t, i) {
            var n = t.image.width,
                r = t.image.height,
                o = se.convert(t.format);
            U.setTexture2D(t, 0), ze.copyTexImage2D(3553, i || 0, o, e.x, e.y, n, r, 0)
        }, this.copyTextureToTexture = function(e, t, i, n) {
            var r = t.image.width,
                o = t.image.height,
                a = se.convert(i.format),
                s = se.convert(i.type);
            U.setTexture2D(i, 0), t.isDataTexture ? ze.texSubImage2D(3553, n || 0, e.x, e.y, r, o, a, s, t.image.data) : ze.texSubImage2D(3553, n || 0, e.x, e.y, a, s, t.image)
        }
    }

    function At(e, t) {
        this.name = "", this.color = new b(e), this.density = void 0 !== t ? t : 25e-5
    }

    function Ct(e, t, i) {
        this.name = "", this.color = new b(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Lt() {
        T.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
    }

    function Dt(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Pt(e, t, i, n) {
        this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
    }

    function Rt(e) {
        V.call(this), this.type = "SpriteMaterial", this.color = new b(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
    }

    function Ot(e) {
        if (T.call(this), this.type = "Sprite", void 0 === Bo) {
            Bo = new k;
            var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            t = new Dt(t, 5), Bo.setIndex([0, 1, 2, 0, 2, 3]), Bo.addAttribute("position", new Pt(t, 3, 0, !1)), Bo.addAttribute("uv", new Pt(t, 2, 3, !1))
        }
        this.geometry = Bo, this.material = void 0 !== e ? e : new Rt, this.center = new i(.5, .5)
    }

    function It() {
        T.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function zt(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new g, this.bindMatrixInverse = new g
    }

    function Nt(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new g)
    }

    function Bt() {
        T.call(this), this.type = "Bone"
    }

    function Ft(e) {
        V.call(this), this.type = "LineBasicMaterial", this.color = new b(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(e)
    }

    function kt(e, t, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), T.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Ft({
            color: 16777215 * Math.random()
        })
    }

    function Ut(e, t) {
        kt.call(this, e, t), this.type = "LineSegments"
    }

    function Ht(e, t) {
        kt.call(this, e, t), this.type = "LineLoop"
    }

    function Gt(e) {
        V.call(this), this.type = "PointsMaterial", this.color = new b(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(e)
    }

    function jt(e, t) {
        T.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new k, this.material = void 0 !== t ? t : new Gt({
            color: 16777215 * Math.random()
        })
    }

    function Vt(e, t, i, n, r, o, s, l, c) {
        a.call(this, e, t, i, n, r, o, s, l, c), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function Wt(e, t, i, n, r, o, s, l, c, h, u, d) {
        a.call(this, null, o, s, l, c, h, n, r, u, d), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
    }

    function qt(e, t, i, n, r, o, s, l, c) {
        a.call(this, e, t, i, n, r, o, s, l, c), this.needsUpdate = !0
    }

    function Xt(e, t, i, n, r, o, s, l, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), a.call(this, null, n, r, o, s, l, h, i, c), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
    }

    function Yt(e) {
        k.call(this), this.type = "WireframeGeometry";
        var t, i, n, o = [],
            a = [0, 0],
            s = {},
            l = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var c = e.faces,
                h = 0;
            for (i = c.length; h < i; h++) {
                var u = c[h];
                for (t = 0; 3 > t; t++) {
                    var d = u[l[t]],
                        p = u[l[(t + 1) % 3]];
                    a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = {
                        index1: a[0],
                        index2: a[1]
                    })
                }
            }
            for (d in s) h = s[d], l = e.vertices[h.index1], o.push(l.x, l.y, l.z), l = e.vertices[h.index2], o.push(l.x, l.y, l.z)
        } else if (e && e.isBufferGeometry)
            if (l = new r, null !== e.index) {
                c = e.attributes.position, u = e.index;
                var f = e.groups;
                for (0 === f.length && (f = [{
                        start: 0,
                        count: u.count,
                        materialIndex: 0
                    }]), e = 0, n = f.length; e < n; ++e)
                    for (t = (h = f[e]).start, i = h.count, h = t, i = t + i; h < i; h += 3)
                        for (t = 0; 3 > t; t++) d = u.getX(h + t), p = u.getX(h + (t + 1) % 3), a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = {
                            index1: a[0],
                            index2: a[1]
                        });
                for (d in s) h = s[d], l.fromBufferAttribute(c, h.index1), o.push(l.x, l.y, l.z), l.fromBufferAttribute(c, h.index2), o.push(l.x, l.y, l.z)
            } else
                for (h = 0, i = (c = e.attributes.position).count / 3; h < i; h++)
                    for (t = 0; 3 > t; t++) s = 3 * h + t, l.fromBufferAttribute(c, s), o.push(l.x, l.y, l.z), s = 3 * h + (t + 1) % 3, l.fromBufferAttribute(c, s), o.push(l.x, l.y, l.z);
        this.addAttribute("position", new z(o, 3))
    }

    function Zt(e, t, i) {
        S.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        }, this.fromBufferGeometry(new Jt(e, t, i)), this.mergeVertices()
    }

    function Jt(e, t, i) {
        k.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var n, o, a = [],
            s = [],
            l = [],
            c = [],
            h = new r,
            u = new r,
            d = new r,
            p = new r,
            f = new r;
        3 > e.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = t + 1;
        for (n = 0; n <= i; n++) {
            var g = n / i;
            for (o = 0; o <= t; o++) {
                var v = o / t;
                e(v, g, u), s.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, g, d), p.subVectors(u, d)) : (e(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (e(v, g - 1e-5, d), f.subVectors(u, d)) : (e(v, g + 1e-5, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), l.push(h.x, h.y, h.z), c.push(v, g)
            }
        }
        for (n = 0; n < i; n++)
            for (o = 0; o < t; o++) e = n * m + o + 1, h = (n + 1) * m + o + 1, u = (n + 1) * m + o, a.push(n * m + o, e, u), a.push(e, h, u);
        this.setIndex(a), this.addAttribute("position", new z(s, 3)), this.addAttribute("normal", new z(l, 3)), this.addAttribute("uv", new z(c, 2))
    }

    function Qt(e, t, i, n) {
        S.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new $t(e, t, i, n)), this.mergeVertices()
    }

    function $t(e, t, n, o) {
        function a(e) {
            c.push(e.x, e.y, e.z)
        }

        function s(t, i) {
            t *= 3, i.x = e[t + 0], i.y = e[t + 1], i.z = e[t + 2]
        }

        function l(e, t, i, n) {
            0 > n && 1 === e.x && (h[t] = e.x - 1), 0 === i.x && 0 === i.z && (h[t] = n / 2 / Math.PI + .5)
        }
        k.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: o
        }, n = n || 1;
        var c = [],
            h = [];
        ! function(e) {
            for (var i = new r, n = new r, o = new r, l = 0; l < t.length; l += 3) {
                s(t[l + 0], i), s(t[l + 1], n), s(t[l + 2], o);
                var c, h, u = i,
                    d = n,
                    p = o,
                    f = Math.pow(2, e),
                    m = [];
                for (h = 0; h <= f; h++) {
                    m[h] = [];
                    var g = u.clone().lerp(p, h / f),
                        v = d.clone().lerp(p, h / f),
                        y = f - h;
                    for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y)
                }
                for (h = 0; h < f; h++)
                    for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (a(m[h][u + 1]), a(m[h + 1][u]), a(m[h][u])) : (a(m[h][u + 1]), a(m[h + 1][u + 1]), a(m[h + 1][u]))
            }
        }(o = o || 0),
        function(e) {
            for (var t = new r, i = 0; i < c.length; i += 3) t.x = c[i + 0], t.y = c[i + 1], t.z = c[i + 2], t.normalize().multiplyScalar(e), c[i + 0] = t.x, c[i + 1] = t.y, c[i + 2] = t.z
        }(n),
        function() {
            for (var e = new r, t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2], h.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
            e = new r, t = new r;
            for (var n = new r, o = new r, a = new i, s = new i, u = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
                e.set(c[d + 0], c[d + 1], c[d + 2]), t.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), a.set(h[p + 0], h[p + 1]), s.set(h[p + 2], h[p + 3]), u.set(h[p + 4], h[p + 5]), o.copy(e).add(t).add(n).divideScalar(3);
                var f = Math.atan2(o.z, -o.x);
                l(a, p + 0, e, f), l(s, p + 2, t, f), l(u, p + 4, n, f)
            }
            for (e = 0; e < h.length; e += 6) t = h[e + 0], n = h[e + 2], o = h[e + 4], a = Math.min(t, n, o), .9 < Math.max(t, n, o) && .1 > a && (.2 > t && (h[e + 0] += 1), .2 > n && (h[e + 2] += 1), .2 > o && (h[e + 4] += 1))
        }(), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(c.slice(), 3)), this.addAttribute("uv", new z(h, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function Kt(e, t) {
        S.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ei(e, t)), this.mergeVertices()
    }

    function ei(e, t) {
        $t.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ti(e, t) {
        S.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ii(e, t)), this.mergeVertices()
    }

    function ii(e, t) {
        $t.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ni(e, t) {
        S.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ri(e, t)), this.mergeVertices()
    }

    function ri(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        $t.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function oi(e, t) {
        S.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ai(e, t)), this.mergeVertices()
    }

    function ai(e, t) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i;
        $t.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function si(e, t, i, n, r, o) {
        S.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), e = new li(e, t, i, n, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices()
    }

    function li(e, t, n, o, a) {
        function s(i) {
            f = e.getPointAt(i / t, f);
            var r = l.normals[i];
            for (i = l.binormals[i], h = 0; h <= o; h++) {
                var a = h / o * Math.PI * 2,
                    s = Math.sin(a);
                a = -Math.cos(a), d.x = a * r.x + s * i.x, d.y = a * r.y + s * i.y, d.z = a * r.z + s * i.z, d.normalize(), g.push(d.x, d.y, d.z), u.x = f.x + n * d.x, u.y = f.y + n * d.y, u.z = f.z + n * d.z, m.push(u.x, u.y, u.z)
            }
        }
        k.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: o,
            closed: a
        }, t = t || 64, n = n || 1, o = o || 8, a = a || !1;
        var l = e.computeFrenetFrames(t, a);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var c, h, u = new r,
            d = new r,
            p = new i,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c < t; c++) s(c);
        for (s(!1 === a ? t : 0), c = 0; c <= t; c++)
            for (h = 0; h <= o; h++) p.x = c / t, p.y = h / o, v.push(p.x, p.y);
        ! function() {
            for (h = 1; h <= t; h++)
                for (c = 1; c <= o; c++) {
                    var e = (o + 1) * h + (c - 1),
                        i = (o + 1) * h + c,
                        n = (o + 1) * (h - 1) + c;
                    y.push((o + 1) * (h - 1) + (c - 1), e, n), y.push(e, i, n)
                }
        }(), this.setIndex(y), this.addAttribute("position", new z(m, 3)), this.addAttribute("normal", new z(g, 3)), this.addAttribute("uv", new z(v, 2))
    }

    function ci(e, t, i, n, r, o, a) {
        S.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new hi(e, t, i, n, r, o)), this.mergeVertices()
    }

    function hi(e, t, i, n, o, a) {
        function s(e, t, i, n, r) {
            var o = Math.sin(e);
            t = i / t * e, i = Math.cos(t), r.x = n * (2 + i) * .5 * Math.cos(e), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(t) * .5
        }
        k.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: o,
            q: a
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, a = a || 3;
        var l, c = [],
            h = [],
            u = [],
            d = [],
            p = new r,
            f = new r,
            m = new r,
            g = new r,
            v = new r,
            y = new r,
            b = new r;
        for (l = 0; l <= i; ++l) {
            var x = l / i * o * Math.PI * 2;
            for (s(x, o, a, e, m), s(x + .01, o, a, e, g), y.subVectors(g, m), b.addVectors(g, m), v.crossVectors(y, b), b.crossVectors(v, y), v.normalize(), b.normalize(), x = 0; x <= n; ++x) {
                var w = x / n * Math.PI * 2,
                    _ = -t * Math.cos(w);
                w = t * Math.sin(w), p.x = m.x + (_ * b.x + w * v.x), p.y = m.y + (_ * b.y + w * v.y), p.z = m.z + (_ * b.z + w * v.z), h.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(l / i), d.push(x / n)
            }
        }
        for (x = 1; x <= i; x++)
            for (l = 1; l <= n; l++) e = (n + 1) * x + (l - 1), t = (n + 1) * x + l, o = (n + 1) * (x - 1) + l, c.push((n + 1) * (x - 1) + (l - 1), e, o), c.push(e, t, o);
        this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
    }

    function ui(e, t, i, n, r) {
        S.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new di(e, t, i, n, r)), this.mergeVertices()
    }

    function di(e, t, i, n, o) {
        k.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: o
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
        var a, s, l = [],
            c = [],
            h = [],
            u = [],
            d = new r,
            p = new r,
            f = new r;
        for (a = 0; a <= i; a++)
            for (s = 0; s <= n; s++) {
                var m = s / n * o,
                    g = a / i * Math.PI * 2;
                p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), h.push(f.x, f.y, f.z), u.push(s / n), u.push(a / i)
            }
        for (a = 1; a <= i; a++)
            for (s = 1; s <= n; s++) e = (n + 1) * (a - 1) + s - 1, t = (n + 1) * (a - 1) + s, o = (n + 1) * a + s, l.push((n + 1) * a + s - 1, e, o), l.push(e, t, o);
        this.setIndex(l), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(h, 3)), this.addAttribute("uv", new z(u, 2))
    }

    function pi(e, t, i, n, r) {
        for (var o, a = 0, s = t, l = i - n; s < i; s += n) a += (e[l] - e[s]) * (e[s + 1] + e[l + 1]), l = s;
        if (r === 0 < a)
            for (r = t; r < i; r += n) o = Ti(r, e[r], e[r + 1], o);
        else
            for (r = i - n; r >= t; r -= n) o = Ti(r, e[r], e[r + 1], o);
        return o && wi(o, o.next) && (Si(o), o = o.next), o
    }

    function fi(e, t) {
        if (!e) return e;
        t || (t = e);
        do {
            var i = !1;
            if (e.steiner || !wi(e, e.next) && 0 !== xi(e.prev, e, e.next)) e = e.next;
            else {
                if (Si(e), (e = t = e.prev) === e.next) break;
                i = !0
            }
        } while (i || e !== t);
        return t
    }

    function mi(e, t) {
        return e.x - t.x
    }

    function gi(e, t) {
        var i = t,
            n = e.x,
            r = e.y,
            o = -1 / 0;
        do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                var a = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (a <= n && a > o) {
                    if (o = a, a === n) {
                        if (r === i.y) return i;
                        if (r === i.next.y) return i.next
                    }
                    var s = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== t);
        if (!s) return null;
        if (n === o) return s.prev;
        t = s, a = s.x;
        var l = s.y,
            c = 1 / 0;
        for (i = s.next; i !== t;) {
            if (n >= i.x && i.x >= a && n !== i.x && bi(r < l ? n : o, r, a, l, r < l ? o : n, r, i.x, i.y)) {
                var h = Math.abs(r - i.y) / (n - i.x);
                (h < c || h === c && i.x > s.x) && Ei(i, e) && (s = i, c = h)
            }
            i = i.next
        }
        return s
    }

    function vi(e, t, i, n, r) {
        return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function yi(e) {
        var t = e,
            i = e;
        do {
            t.x < i.x && (i = t), t = t.next
        } while (t !== e);
        return i
    }

    function bi(e, t, i, n, r, o, a, s) {
        return 0 <= (r - a) * (t - s) - (e - a) * (o - s) && 0 <= (e - a) * (n - s) - (i - a) * (t - s) && 0 <= (i - a) * (o - s) - (r - a) * (n - s)
    }

    function xi(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }

    function wi(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function _i(e, t, i, n) {
        return !!(wi(e, t) && wi(i, n) || wi(e, n) && wi(i, t)) || 0 < xi(e, t, i) != 0 < xi(e, t, n) && 0 < xi(i, n, e) != 0 < xi(i, n, t)
    }

    function Ei(e, t) {
        return 0 > xi(e.prev, e, e.next) ? 0 <= xi(e, t, e.next) && 0 <= xi(e, e.prev, t) : 0 > xi(e, t, e.prev) || 0 > xi(e, e.next, t)
    }

    function Mi(e, t) {
        var i = new Ai(e.i, e.x, e.y),
            n = new Ai(t.i, t.x, t.y),
            r = e.next,
            o = t.prev;
        return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
    }

    function Ti(e, t, i, n) {
        return e = new Ai(e, t, i), n ? (e.next = n.next, e.prev = n, n.next.prev = e, n.next = e) : (e.prev = e, e.next = e), e
    }

    function Si(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Ai(e, t, i) {
        this.i = e, this.x = t, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
    }

    function Ci(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function Li(e, t) {
        for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
    }

    function Di(e, t) {
        S.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new Pi(e, t)), this.mergeVertices()
    }

    function Pi(e, t) {
        function n(e) {
            function n(e, t, i) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
            }

            function l(e, t, n) {
                var r = e.x - t.x,
                    o = e.y - t.y,
                    a = n.x - e.x,
                    s = n.y - e.y,
                    l = r * r + o * o;
                if (Math.abs(r * s - o * a) > Number.EPSILON) {
                    var c = Math.sqrt(l),
                        h = Math.sqrt(a * a + s * s);
                    if (l = t.x - o / c, t = t.y + r / c, 2 >= (o = (a = l + r * (s = ((n.x - s / h - l) * s - (n.y + a / h - t) * a) / (r * s - o * a)) - e.x) * a + (r = t + o * s - e.y) * r)) return new i(a, r);
                    o = Math.sqrt(o / 2)
                } else e = !1, r > Number.EPSILON ? a > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? a < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(s) && (e = !0), e ? (a = -o, o = Math.sqrt(l)) : (a = r, r = o, o = Math.sqrt(l / 2));
                return new i(a / o, r / o)
            }

            function c(e, t) {
                for (H = e.length; 0 <= --H;) {
                    var i = H,
                        n = H - 1;
                    0 > n && (n = e.length - 1);
                    var r, s = g + 2 * _;
                    for (r = 0; r < s; r++) {
                        var l = k * r,
                            c = k * (r + 1),
                            h = t + n + l,
                            u = t + n + c;
                        c = t + i + c, d(t + i + l), d(h), d(c), d(h), d(u), d(c), l = a.length / 3, p((l = M.generateSideWallUV(o, a, l - 6, l - 3, l - 2, l - 1))[0]), p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3])
                    }
                }
            }

            function h(e, t, i) {
                f.push(e), f.push(t), f.push(i)
            }

            function u(e, t, i) {
                d(e), d(t), d(i), e = a.length / 3, p((e = M.generateTopUV(o, a, e - 3, e - 2, e - 1))[0]), p(e[1]), p(e[2])
            }

            function d(e) {
                a.push(f[3 * e]), a.push(f[3 * e + 1]), a.push(f[3 * e + 2])
            }

            function p(e) {
                s.push(e.x), s.push(e.y)
            }
            var f = [],
                m = void 0 !== t.curveSegments ? t.curveSegments : 12,
                g = void 0 !== t.steps ? t.steps : 1,
                v = void 0 !== t.depth ? t.depth : 100,
                y = void 0 === t.bevelEnabled || t.bevelEnabled,
                b = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                x = void 0 !== t.bevelSize ? t.bevelSize : b - 2,
                w = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                _ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                E = t.extrudePath,
                M = void 0 !== t.UVGenerator ? t.UVGenerator : Ho;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = t.amount);
            var T, S = !1;
            if (E) {
                var A = E.getSpacedPoints(g);
                S = !0, y = !1;
                var C = E.computeFrenetFrames(g, !1),
                    L = new r,
                    D = new r,
                    P = new r
            }
            y || (w = x = b = _ = 0), m = e.extractPoints(m), e = m.shape;
            var R = m.holes;
            if (!Uo.isClockWise(e)) {
                e = e.reverse();
                var O = 0;
                for (T = R.length; O < T; O++) {
                    var I = R[O];
                    Uo.isClockWise(I) && (R[O] = I.reverse())
                }
            }
            var z = Uo.triangulateShape(e, R),
                N = e;
            for (O = 0, T = R.length; O < T; O++) I = R[O], e = e.concat(I);
            var B, F, k = e.length,
                U = z.length;
            m = [];
            var H = 0,
                G = N.length,
                j = G - 1;
            for (B = H + 1; H < G; H++, j++, B++) j === G && (j = 0), B === G && (B = 0), m[H] = l(N[H], N[j], N[B]);
            E = [];
            var V = m.concat();
            for (O = 0, T = R.length; O < T; O++) {
                I = R[O];
                var W = [];
                for (H = 0, j = (G = I.length) - 1, B = H + 1; H < G; H++, j++, B++) j === G && (j = 0), B === G && (B = 0), W[H] = l(I[H], I[j], I[B]);
                E.push(W), V = V.concat(W)
            }
            for (j = 0; j < _; j++) {
                G = j / _;
                var q = b * Math.cos(G * Math.PI / 2);
                for (B = x * Math.sin(G * Math.PI / 2) + w, H = 0, G = N.length; H < G; H++) {
                    var X = n(N[H], m[H], B);
                    h(X.x, X.y, -q)
                }
                for (O = 0, T = R.length; O < T; O++)
                    for (I = R[O], W = E[O], H = 0, G = I.length; H < G; H++) h((X = n(I[H], W[H], B)).x, X.y, -q)
            }
            for (B = x + w, H = 0; H < k; H++) X = y ? n(e[H], V[H], B) : e[H], S ? (D.copy(C.normals[0]).multiplyScalar(X.x), L.copy(C.binormals[0]).multiplyScalar(X.y), P.copy(A[0]).add(D).add(L), h(P.x, P.y, P.z)) : h(X.x, X.y, 0);
            for (G = 1; G <= g; G++)
                for (H = 0; H < k; H++) X = y ? n(e[H], V[H], B) : e[H], S ? (D.copy(C.normals[G]).multiplyScalar(X.x), L.copy(C.binormals[G]).multiplyScalar(X.y), P.copy(A[G]).add(D).add(L), h(P.x, P.y, P.z)) : h(X.x, X.y, v / g * G);
            for (j = _ - 1; 0 <= j; j--) {
                for (G = j / _, q = b * Math.cos(G * Math.PI / 2), B = x * Math.sin(G * Math.PI / 2) + w, H = 0, G = N.length; H < G; H++) h((X = n(N[H], m[H], B)).x, X.y, v + q);
                for (O = 0, T = R.length; O < T; O++)
                    for (I = R[O], W = E[O], H = 0, G = I.length; H < G; H++) X = n(I[H], W[H], B), S ? h(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : h(X.x, X.y, v + q)
            }! function() {
                var e = a.length / 3;
                if (y) {
                    var t = 0 * k;
                    for (H = 0; H < U; H++) u((F = z[H])[2] + t, F[1] + t, F[0] + t);
                    for (t = k * (g + 2 * _), H = 0; H < U; H++) u((F = z[H])[0] + t, F[1] + t, F[2] + t)
                } else {
                    for (H = 0; H < U; H++) u((F = z[H])[2], F[1], F[0]);
                    for (H = 0; H < U; H++) u((F = z[H])[0] + k * g, F[1] + k * g, F[2] + k * g)
                }
                o.addGroup(e, a.length / 3 - e, 0)
            }(),
            function() {
                var e = a.length / 3,
                    t = 0;
                for (c(N, t), t += N.length, O = 0, T = R.length; O < T; O++) c(I = R[O], t), t += I.length;
                o.addGroup(e, a.length / 3 - e, 1)
            }()
        }
        k.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        for (var o = this, a = [], s = [], l = 0, c = e.length; l < c; l++) n(e[l]);
        this.addAttribute("position", new z(a, 3)), this.addAttribute("uv", new z(s, 2)), this.computeVertexNormals()
    }

    function Ri(e, t, i) {
        if (i.shapes = [], Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) i.shapes.push(e[n].uuid);
        else i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
    }

    function Oi(e, t) {
        S.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new Ii(e, t)), this.mergeVertices()
    }

    function Ii(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new S;
        e = i.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Pi.call(this, e, t), this.type = "TextBufferGeometry"
    }

    function zi(e, t, i, n, r, o, a) {
        S.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new Ni(e, t, i, n, r, o, a)), this.mergeVertices()
    }

    function Ni(e, t, i, n, o, a, s) {
        k.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: o,
            thetaStart: a,
            thetaLength: s
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
        var l, c, h = Math.min(a + s, Math.PI),
            u = 0,
            d = [],
            p = new r,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c <= i; c++) {
            var b = [],
                x = c / i,
                w = 0;
            for (0 == c && 0 == a ? w = .5 / t : c == i && h == Math.PI && (w = -.5 / t), l = 0; l <= t; l++) {
                var _ = l / t;
                p.x = -e * Math.cos(n + _ * o) * Math.sin(a + x * s), p.y = e * Math.cos(a + x * s), p.z = e * Math.sin(n + _ * o) * Math.sin(a + x * s), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(_ + w, 1 - x), b.push(u++)
            }
            d.push(b)
        }
        for (c = 0; c < i; c++)
            for (l = 0; l < t; l++) e = d[c][l + 1], n = d[c][l], o = d[c + 1][l], s = d[c + 1][l + 1], (0 !== c || 0 < a) && m.push(e, n, s), (c !== i - 1 || h < Math.PI) && m.push(n, o, s);
        this.setIndex(m), this.addAttribute("position", new z(g, 3)), this.addAttribute("normal", new z(v, 3)), this.addAttribute("uv", new z(y, 2))
    }

    function Bi(e, t, i, n, r, o) {
        S.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new Fi(e, t, i, n, r, o)), this.mergeVertices()
    }

    function Fi(e, t, n, o, a, s) {
        k.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: o,
            thetaStart: a,
            thetaLength: s
        }, e = e || .5, t = t || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var l, c, h = [],
            u = [],
            d = [],
            p = [],
            f = e,
            m = (t - e) / (o = void 0 !== o ? Math.max(1, o) : 1),
            g = new r,
            v = new i;
        for (l = 0; l <= o; l++) {
            for (c = 0; c <= n; c++) e = a + c / n * s, g.x = f * Math.cos(e), g.y = f * Math.sin(e), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, p.push(v.x, v.y);
            f += m
        }
        for (l = 0; l < o; l++)
            for (t = l * (n + 1), c = 0; c < n; c++) a = (e = c + t) + n + 1, s = e + n + 2, f = e + 1, h.push(e, a, f), h.push(a, s, f);
        this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
    }

    function ki(e, t, i, n) {
        S.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new Ui(e, t, i, n)), this.mergeVertices()
    }

    function Ui(e, t, n, o) {
        k.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: o
        }, t = Math.floor(t) || 12, n = n || 0, o = o || 2 * Math.PI, o = uo.clamp(o, 0, 2 * Math.PI);
        var a, s = [],
            l = [],
            c = [],
            h = 1 / t,
            u = new r,
            d = new i;
        for (a = 0; a <= t; a++) {
            var p = n + a * h * o,
                f = Math.sin(p),
                m = Math.cos(p);
            for (p = 0; p <= e.length - 1; p++) u.x = e[p].x * f, u.y = e[p].y, u.z = e[p].x * m, l.push(u.x, u.y, u.z), d.x = a / t, d.y = p / (e.length - 1), c.push(d.x, d.y)
        }
        for (a = 0; a < t; a++)
            for (p = 0; p < e.length - 1; p++) h = (n = p + a * e.length) + e.length, u = n + e.length + 1, d = n + 1, s.push(n, h, d), s.push(h, u, d);
        if (this.setIndex(s), this.addAttribute("position", new z(l, 3)), this.addAttribute("uv", new z(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI)
            for (o = this.attributes.normal.array, s = new r, l = new r, c = new r, n = t * e.length * 3, p = a = 0; a < e.length; a++, p += 3) s.x = o[p + 0], s.y = o[p + 1], s.z = o[p + 2], l.x = o[n + p + 0], l.y = o[n + p + 1], l.z = o[n + p + 2], c.addVectors(s, l).normalize(), o[p + 0] = o[n + p + 0] = c.x, o[p + 1] = o[n + p + 1] = c.y, o[p + 2] = o[n + p + 2] = c.z
    }

    function Hi(e, t) {
        S.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new Gi(e, t)), this.mergeVertices()
    }

    function Gi(e, t) {
        function i(e) {
            var i, s = r.length / 3,
                c = (e = e.extractPoints(t)).shape,
                h = e.holes;
            for (!1 === Uo.isClockWise(c) && (c = c.reverse()), e = 0, i = h.length; e < i; e++) {
                var u = h[e];
                !0 === Uo.isClockWise(u) && (h[e] = u.reverse())
            }
            var d = Uo.triangulateShape(c, h);
            for (e = 0, i = h.length; e < i; e++) u = h[e], c = c.concat(u);
            for (e = 0, i = c.length; e < i; e++) u = c[e], r.push(u.x, u.y, 0), o.push(0, 0, 1), a.push(u.x, u.y);
            for (e = 0, i = d.length; e < i; e++) c = d[e], n.push(c[0] + s, c[1] + s, c[2] + s), l += 3
        }
        k.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var n = [],
            r = [],
            o = [],
            a = [],
            s = 0,
            l = 0;
        if (!1 === Array.isArray(e)) i(e);
        else
            for (var c = 0; c < e.length; c++) i(e[c]), this.addGroup(s, l, c), s += l, l = 0;
        this.setIndex(n), this.addAttribute("position", new z(r, 3)), this.addAttribute("normal", new z(o, 3)), this.addAttribute("uv", new z(a, 2))
    }

    function ji(e, t) {
        if (t.shapes = [], Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++) t.shapes.push(e[i].uuid);
        else t.shapes.push(e.uuid);
        return t
    }

    function Vi(e, t) {
        k.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        };
        var i = [];
        t = Math.cos(uo.DEG2RAD * (void 0 !== t ? t : 1));
        var n = [0, 0],
            r = {},
            o = ["a", "b", "c"];
        if (e.isBufferGeometry) {
            var a = new S;
            a.fromBufferGeometry(e)
        } else a = e.clone();
        a.mergeVertices(), a.computeFaceNormals(), e = a.vertices;
        for (var s = 0, l = (a = a.faces).length; s < l; s++)
            for (var c = a[s], h = 0; 3 > h; h++) {
                var u = c[o[h]],
                    d = c[o[(h + 1) % 3]];
                n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
                    index1: n[0],
                    index2: n[1],
                    face1: s,
                    face2: void 0
                } : r[u].face2 = s
            }
        for (u in r)(void 0 === (n = r[u]).face2 || a[n.face1].normal.dot(a[n.face2].normal) <= t) && (o = e[n.index1], i.push(o.x, o.y, o.z), o = e[n.index2], i.push(o.x, o.y, o.z));
        this.addAttribute("position", new z(i, 3))
    }

    function Wi(e, t, i, n, r, o, a, s) {
        S.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new qi(e, t, i, n, r, o, a, s)), this.mergeVertices()
    }

    function qi(e, t, n, o, a, s, l, c) {
        function h(n) {
            var a, s = new i,
                h = new r,
                v = 0,
                x = !0 === n ? e : t,
                w = !0 === n ? 1 : -1,
                _ = g;
            for (a = 1; a <= o; a++) p.push(0, y * w, 0), f.push(0, w, 0), m.push(.5, .5), g++;
            var E = g;
            for (a = 0; a <= o; a++) {
                var M = a / o * c + l,
                    T = Math.cos(M);
                M = Math.sin(M), h.x = x * M, h.y = y * w, h.z = x * T, p.push(h.x, h.y, h.z), f.push(0, w, 0), s.x = .5 * T + .5, s.y = .5 * M * w + .5, m.push(s.x, s.y), g++
            }
            for (a = 0; a < o; a++) s = _ + a, h = E + a, !0 === n ? d.push(h, h + 1, s) : d.push(h + 1, h, s), v += 3;
            u.addGroup(b, v, !0 === n ? 1 : 2), b += v
        }
        k.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: o,
            heightSegments: a,
            openEnded: s,
            thetaStart: l,
            thetaLength: c
        };
        var u = this;
        e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, o = Math.floor(o) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
        var d = [],
            p = [],
            f = [],
            m = [],
            g = 0,
            v = [],
            y = n / 2,
            b = 0;
        ! function() {
            var i, s, h = new r,
                x = new r,
                w = 0,
                _ = (t - e) / n;
            for (s = 0; s <= a; s++) {
                var E = [],
                    M = s / a,
                    T = M * (t - e) + e;
                for (i = 0; i <= o; i++) {
                    var S = i / o,
                        A = S * c + l,
                        C = Math.sin(A);
                    A = Math.cos(A), x.x = T * C, x.y = -M * n + y, x.z = T * A, p.push(x.x, x.y, x.z), h.set(C, _, A).normalize(), f.push(h.x, h.y, h.z), m.push(S, 1 - M), E.push(g++)
                }
                v.push(E)
            }
            for (i = 0; i < o; i++)
                for (s = 0; s < a; s++) h = v[s + 1][i], x = v[s + 1][i + 1], _ = v[s][i + 1], d.push(v[s][i], h, _), d.push(h, x, _), w += 6;
            u.addGroup(b, w, 0), b += w
        }(), !1 === s && (0 < e && h(!0), 0 < t && h(!1)), this.setIndex(d), this.addAttribute("position", new z(p, 3)), this.addAttribute("normal", new z(f, 3)), this.addAttribute("uv", new z(m, 2))
    }

    function Xi(e, t, i, n, r, o, a) {
        Wi.call(this, 0, e, t, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Yi(e, t, i, n, r, o, a) {
        qi.call(this, 0, e, t, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Zi(e, t, i, n) {
        S.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new Ji(e, t, i, n)), this.mergeVertices()
    }

    function Ji(e, t, n, o) {
        k.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: o
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI;
        var a, s = [],
            l = [],
            c = [],
            h = [],
            u = new r,
            d = new i;
        l.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5);
        var p = 0;
        for (a = 3; p <= t; p++, a += 3) {
            var f = n + p / t * o;
            u.x = e * Math.cos(f), u.y = e * Math.sin(f), l.push(u.x, u.y, u.z), c.push(0, 0, 1), d.x = (l[a] / e + 1) / 2, d.y = (l[a + 1] / e + 1) / 2, h.push(d.x, d.y)
        }
        for (a = 1; a <= t; a++) s.push(a, a + 1, 0);
        this.setIndex(s), this.addAttribute("position", new z(l, 3)), this.addAttribute("normal", new z(c, 3)), this.addAttribute("uv", new z(h, 2))
    }

    function Qi(e) {
        V.call(this), this.type = "ShadowMaterial", this.color = new b(0), this.transparent = !0, this.setValues(e)
    }

    function $i(e) {
        W.call(this, e), this.type = "RawShaderMaterial"
    }

    function Ki(e) {
        V.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new b(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function en(e) {
        Ki.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(e)
    }

    function tn(e) {
        V.call(this), this.type = "MeshPhongMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function nn(e) {
        tn.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function rn(e) {
        V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(e)
    }

    function on(e) {
        V.call(this), this.type = "MeshLambertMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function an(e) {
        V.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new b(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function sn(e) {
        Ft.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    function ln(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
    }

    function cn(e, t, i, n) {
        ln.call(this, e, t, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function hn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function un(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function dn(e, t, i, n) {
        if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Vo.convertArray(t, this.TimeBufferType), this.values = Vo.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }

    function pn(e, t, i) {
        dn.call(this, e, t, i)
    }

    function fn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function mn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function gn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function vn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function yn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function bn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function xn(e, t, i) {
        this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = uo.generateUUID(), 0 > this.duration && this.resetDuration()
    }

    function wn(e) {
        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return mn;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return bn;
                case "color":
                    return fn;
                case "quaternion":
                    return vn;
                case "bool":
                case "boolean":
                    return pn;
                case "string":
                    return yn
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var i = [],
                n = [];
            Vo.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }

    function _n(e, t, i) {
        var n = this,
            r = !1,
            o = 0,
            a = 0,
            s = void 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
            a++, !1 === r && void 0 !== n.onStart && n.onStart(e, o, a), r = !0
        }, this.itemEnd = function(e) {
            o++, void 0 !== n.onProgress && n.onProgress(e, o, a), o === a && (r = !1, void 0 !== n.onLoad) && n.onLoad()
        }, this.itemError = function(e) {
            void 0 !== n.onError && n.onError(e)
        }, this.resolveURL = function(e) {
            return s ? s(e) : e
        }, this.setURLModifier = function(e) {
            return s = e, this
        }
    }

    function En(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function Mn(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function Tn(e) {
        this.manager = void 0 !== e ? e : qo, this._parser = null
    }

    function Sn(e) {
        this.manager = void 0 !== e ? e : qo, this._parser = null
    }

    function An(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function Cn(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function Ln(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function Dn() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function Pn(e, t, i, n, r, o, a, s) {
        Dn.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function Rn(e, t, i, n, r, o) {
        Pn.call(this, e, t, i, i, n, r, o), this.type = "ArcCurve"
    }

    function On() {
        var e = 0,
            t = 0,
            i = 0,
            n = 0;
        return {
            initCatmullRom: function(r, o, a, s, l) {
                e = o, t = r = l * (a - r), i = -3 * o + 3 * a - 2 * r - (s = l * (s - o)), n = 2 * o - 2 * a + r + s
            },
            initNonuniformCatmullRom: function(r, o, a, s, l, c, h) {
                e = o, t = r = ((o - r) / l - (a - r) / (l + c) + (a - o) / c) * c, i = -3 * o + 3 * a - 2 * r - (s = ((a - o) / c - (s - o) / (c + h) + (s - a) / h) * c), n = 2 * o - 2 * a + r + s
            },
            calc: function(r) {
                var o = r * r;
                return e + t * r + i * o + n * o * r
            }
        }
    }

    function In(e, t, i, n) {
        Dn.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function zn(e, t, i, n, r) {
        var o = e * e;
        return (2 * i - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - i))) * e * o + (-3 * i + 3 * n - 2 * t - r) * o + t * e + i
    }

    function Nn(e, t, i, n) {
        var r = 1 - e;
        return r * r * t + 2 * (1 - e) * e * i + e * e * n
    }

    function Bn(e, t, i, n, r) {
        var o = 1 - e,
            a = 1 - e;
        return o * o * o * t + 3 * a * a * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
    }

    function Fn(e, t, n, r) {
        Dn.call(this), this.type = "CubicBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i, this.v3 = r || new i
    }

    function kn(e, t, i, n) {
        Dn.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r, this.v3 = n || new r
    }

    function Un(e, t) {
        Dn.call(this), this.type = "LineCurve", this.v1 = e || new i, this.v2 = t || new i
    }

    function Hn(e, t) {
        Dn.call(this), this.type = "LineCurve3", this.v1 = e || new r, this.v2 = t || new r
    }

    function Gn(e, t, n) {
        Dn.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i
    }

    function jn(e, t, i) {
        Dn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r
    }

    function Vn(e) {
        Dn.call(this), this.type = "SplineCurve", this.points = e || []
    }

    function Wn() {
        Dn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function qn(e) {
        Wn.call(this), this.type = "Path", this.currentPoint = new i, e && this.setFromPoints(e)
    }

    function Xn(e) {
        qn.call(this, e), this.uuid = uo.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Yn(e, t) {
        T.call(this), this.type = "Light", this.color = new b(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Zn(e, t, i) {
        Yn.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(T.DefaultUp), this.updateMatrix(), this.groundColor = new b(t)
    }

    function Jn(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new g
    }

    function Qn() {
        Jn.call(this, new wt(50, 1, .5, 500))
    }

    function $n(e, t, i, n, r, o) {
        Yn.call(this, e, t), this.type = "SpotLight", this.position.copy(T.DefaultUp), this.updateMatrix(), this.target = new T, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Qn
    }

    function Kn(e, t, i, n) {
        Yn.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Jn(new wt(90, 1, .5, 500))
    }

    function er(e, t, i, n, r, o) {
        xt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function tr() {
        Jn.call(this, new er(-5, 5, 5, -5, .5, 500))
    }

    function ir(e, t) {
        Yn.call(this, e, t), this.type = "DirectionalLight", this.position.copy(T.DefaultUp), this.updateMatrix(), this.target = new T, this.shadow = new tr
    }

    function nr(e, t) {
        Yn.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function rr(e, t, i, n) {
        Yn.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function or(e) {
        this.manager = void 0 !== e ? e : qo, this.textures = {}
    }

    function ar() {
        k.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function sr(e, t, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, e, t, i), this.meshPerAttribute = n || 1
    }

    function lr(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function cr(e) {
        this.manager = void 0 !== e ? e : qo, this.resourcePath = ""
    }

    function hr(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : qo, this.options = void 0
    }

    function ur() {
        this.type = "ShapePath", this.color = new b, this.subPaths = [], this.currentPath = null
    }

    function dr(e) {
        this.type = "Font", this.data = e
    }

    function pr(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function fr() {}

    function mr(e) {
        this.manager = void 0 !== e ? e : qo
    }

    function gr() {
        this.coefficients = [];
        for (var e = 0; 9 > e; e++) this.coefficients.push(new r)
    }

    function vr(e, t) {
        Yn.call(this, void 0, t), this.sh = void 0 !== e ? e : new gr
    }

    function yr(e, t, i) {
        vr.call(this, void 0, i), e = (new b).set(e), i = (new b).set(t), t = new r(e.r, e.g, e.b), e = new r(i.r, i.g, i.b);
        var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75);
        this.sh.coefficients[0].copy(t).add(e).multiplyScalar(i), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(n)
    }

    function br(e, t) {
        vr.call(this, void 0, t), e = (new b).set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }

    function xr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new wt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new wt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function wr(e, t, i, n) {
        T.call(this), this.type = "CubeCamera";
        var o = new wt(90, 1, e, t);
        o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o);
        var a = new wt(90, 1, e, t);
        a.up.set(0, -1, 0), a.lookAt(new r(-1, 0, 0)), this.add(a);
        var s = new wt(90, 1, e, t);
        s.up.set(0, 0, 1), s.lookAt(new r(0, 1, 0)), this.add(s);
        var l = new wt(90, 1, e, t);
        l.up.set(0, 0, -1), l.lookAt(new r(0, -1, 0)), this.add(l);
        var c = new wt(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new r(0, 0, 1)), this.add(c);
        var u = new wt(90, 1, e, t);
        u.up.set(0, -1, 0), u.lookAt(new r(0, 0, -1)), this.add(u), n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }, this.renderTarget = new h(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = e.getRenderTarget(),
                n = this.renderTarget,
                r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, o), e.setRenderTarget(n, 1), e.render(t, a), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, l), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = r, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(i)
        }, this.clear = function(e, t, i, n) {
            for (var r = e.getRenderTarget(), o = this.renderTarget, a = 0; 6 > a; a++) e.setRenderTarget(o, a), e.clear(t, i, n);
            e.setRenderTarget(r)
        }
    }

    function _r(e) {
        this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }

    function Er() {
        T.call(this), this.type = "AudioListener", this.context = sa.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
    }

    function Mr(e) {
        T.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function Tr(e) {
        Mr.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function Sr(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Ar(e, t, i) {
        switch (this.binding = e, this.valueSize = i, e = Float64Array, t) {
            case "quaternion":
                t = this._slerp;
                break;
            case "string":
            case "bool":
                e = Array, t = this._select;
                break;
            default:
                t = this._lerp
        }
        this.buffer = new e(4 * i), this._mixBufferRegion = t, this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function Cr(e, t, i) {
        i = i || Lr.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i)
    }

    function Lr(e, t, i) {
        this.path = t, this.parsedPath = i || Lr.parseTrackName(t), this.node = Lr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function Dr() {
        this.uuid = uo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Pr(e, t, i) {
        this._mixer = e, this._clip = t, this._localRoot = i || null, t = (e = t.tracks).length, i = Array(t);
        for (var n = {
                endingStart: 2400,
                endingEnd: 2400
            }, r = 0; r !== t; ++r) {
            var o = e[r].createInterpolant(null);
            i[r] = o, o.settings = n
        }
        this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function Rr(e) {
        this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
    }

    function Or(e, t) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
    }

    function Ir(e, t, i) {
        Dt.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function zr(e, t, i, n) {
        this.ray = new q(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Nr(e, t) {
        return e.distance - t.distance
    }

    function Br(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) {
            n = 0;
            for (var r = (e = e.children).length; n < r; n++) Br(e[n], t, i, !0)
        }
    }

    function Fr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function kr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Ur(e, t) {
        this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
    }

    function Hr(e, t) {
        this.start = void 0 !== e ? e : new r, this.end = void 0 !== t ? t : new r
    }

    function Gr(e) {
        T.call(this), this.material = e, this.render = function() {}
    }

    function jr(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count), i = new k, t = new z(6 * t, 3), i.addAttribute("position", t), Ut.call(this, i, new Ft({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Vr(e, t) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, e = new k, t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; 32 > i; i++, n++) {
            var r = i / 32 * Math.PI * 2,
                o = n / 32 * Math.PI * 2;
            t.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        e.addAttribute("position", new z(t, 3)), t = new Ft({
            fog: !1
        }), this.cone = new Ut(e, t), this.add(this.cone), this.update()
    }

    function Wr(e) {
        for (var t = function e(t) {
                var i = [];
                t && t.isBone && i.push(t);
                for (var n = 0; n < t.children.length; n++) i.push.apply(i, e(t.children[n]));
                return i
            }(e), i = new k, n = [], r = [], o = new b(0, 0, 1), a = new b(0, 1, 0), s = 0; s < t.length; s++) {
            var l = t[s];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
        }
        i.addAttribute("position", new z(n, 3)), i.addAttribute("color", new z(r, 3)), n = new Ft({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Ut.call(this, i, n), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function qr(e, t, i) {
        this.light = e, this.light.updateMatrixWorld(), this.color = i, e = new Ni(t, 4, 2), t = new Y({
            wireframe: !0,
            fog: !1
        }), Z.call(this, e, t), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Xr(e, t) {
        this.type = "RectAreaLightHelper", this.light = e, this.color = t, (e = new k).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), e.computeBoundingSphere(), t = new Ft({
            fog: !1
        }), kt.call(this, e, t), (e = new k).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), e.computeBoundingSphere(), this.add(new Z(e, new Y({
            side: 1,
            fog: !1
        }))), this.update()
    }

    function Yr(e, t, i) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (e = new ii(t)).rotateY(.5 * Math.PI), this.material = new Y({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2), t = e.getAttribute("position"), t = new Float32Array(3 * t.count), e.addAttribute("color", new A(t, 3)), this.add(new Z(e, this.material)), this.update()
    }

    function Zr(e, t) {
        this.lightProbe = e, this.size = t, e = new W({
            defines: {
                GAMMA_OUTPUT: ""
            },
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
        }), t = new Ni(1, 32, 16), Z.call(this, t, e), this.onBeforeRender()
    }

    function Jr(e, t, i, n) {
        e = e || 10, t = t || 10, i = new b(void 0 !== i ? i : 4473924), n = new b(void 0 !== n ? n : 8947848);
        var r = t / 2,
            o = e / t,
            a = e / 2;
        e = [];
        for (var s = [], l = 0, c = 0, h = -a; l <= t; l++, h += o) {
            e.push(-a, 0, h, a, 0, h), e.push(h, 0, -a, h, 0, a);
            var u = l === r ? i : n;
            u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3
        }(t = new k).addAttribute("position", new z(e, 3)), t.addAttribute("color", new z(s, 3)), i = new Ft({
            vertexColors: 2
        }), Ut.call(this, t, i)
    }

    function Qr(e, t, i, n, r, o) {
        e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new b(void 0 !== r ? r : 4473924), o = new b(void 0 !== o ? o : 8947848);
        var a, s = [],
            l = [];
        for (a = 0; a <= t; a++) {
            var c = a / t * 2 * Math.PI,
                h = Math.sin(c) * e;
            c = Math.cos(c) * e, s.push(0, 0, 0), s.push(h, 0, c);
            var u = 1 & a ? r : o;
            l.push(u.r, u.g, u.b), l.push(u.r, u.g, u.b)
        }
        for (a = 0; a <= i; a++) {
            u = 1 & a ? r : o;
            var d = e - e / i * a;
            for (t = 0; t < n; t++) c = t / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, s.push(h, 0, c), l.push(u.r, u.g, u.b), c = (t + 1) / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, s.push(h, 0, c), l.push(u.r, u.g, u.b)
        }(e = new k).addAttribute("position", new z(s, 3)), e.addAttribute("color", new z(l, 3)), s = new Ft({
            vertexColors: 2
        }), Ut.call(this, e, s)
    }

    function $r(e, t, i, n) {
        this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, e = new k, t = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), e.addAttribute("position", new A(t, 3)), t = new Ft({
            color: 65280
        }), i = new Ft({
            color: 16776960
        }), kt.call(this, e, [i, t]), this.update()
    }

    function Kr(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new k, t = new z(6 * t, 3), i.addAttribute("position", t), Ut.call(this, i, new Ft({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function eo(e, t, i) {
        T.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1), (e = new k).addAttribute("position", new z([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), t = new Ft({
            fog: !1
        }), this.lightPlane = new kt(e, t), this.add(this.lightPlane), (e = new k).addAttribute("position", new z([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new kt(e, t), this.add(this.targetLine), this.update()
    }

    function to(e) {
        function t(e, t, n) {
            i(e, n), i(t, n)
        }

        function i(e, t) {
            o.push(0, 0, 0), a.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(o.length / 3 - 1)
        }
        var n = new k,
            r = new Ft({
                color: 16777215,
                vertexColors: 1
            }),
            o = [],
            a = [],
            s = {},
            l = new b(16755200),
            c = new b(16711680),
            h = new b(43775),
            u = new b(16777215),
            d = new b(3355443);
        t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", h), t("u2", "u3", h), t("u3", "u1", h), t("c", "t", u), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), n.addAttribute("position", new z(o, 3)), n.addAttribute("color", new z(a, 3)), Ut.call(this, n, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
    }

    function io(e, t) {
        this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24),
            n = new k;
        n.setIndex(new A(e, 1)), n.addAttribute("position", new A(i, 3)), Ut.call(this, n, new Ft({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function no(e, t) {
        this.type = "Box3Helper", this.box = e, e = void 0 !== t ? t : 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new k;
        i.setIndex(new A(t, 1)), i.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ut.call(this, i, new Ft({
            color: e
        })), this.geometry.computeBoundingSphere()
    }

    function ro(e, t, i) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== i ? i : 16776960, (t = new k).addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), t.computeBoundingSphere(), kt.call(this, t, new Ft({
            color: e
        })), (t = new k).addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), this.add(new Z(t, new Y({
            color: e,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function oo(e, t, i, n, o, a) {
        T.call(this), void 0 === e && (e = new r(0, 0, 1)), void 0 === t && (t = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === a && (a = .2 * o), void 0 === oa && ((oa = new k).addAttribute("position", new z([0, 0, 0, 0, 1, 0], 3)), (aa = new qi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new kt(oa, new Ft({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(aa, new Y({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, o, a)
    }

    function ao(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
        (e = new k).addAttribute("position", new z(t, 3)), e.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new Ft({
            vertexColors: 2
        }), Ut.call(this, e, t)
    }

    function so(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), In.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function lo(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), In.call(this, e), this.type = "catmullrom"
    }

    function co(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), In.call(this, e), this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function(e) {
        return 0 > e ? -1 : 0 < e ? 1 : +e
    }), 0 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n)
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }), Object.assign(t.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            void 0 !== this._listeners && void 0 !== (e = this._listeners[e]) && -1 !== (t = e.indexOf(t)) && e.splice(t, 1)
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = 0, n = (t = t.slice(0)).length; i < n; i++) t[i].call(this, e)
                }
            }
        }
    });
    var ho, uo = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var e = [], t = 0; 256 > t; t++) e[t] = (16 > t ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function(e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * uo.DEG2RAD
        },
        radToDeg: function(e) {
            return e * uo.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return !(e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function(e) {
            return this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function(e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x,
                i = this.y;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6], this.y = e[1] * t + e[4] * i + e[7], this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return 0 > e && (e += 2 * Math.PI), e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x;
            return t * t + (e = this.y - e.y) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function(e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = this.x - e.x,
                r = this.y - e.y;
            return this.x = n * i - r * t + e.x, this.y = n * t + r * i + e.y, this
        }
    }), Object.assign(n, {
        slerp: function(e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function(e, t, i, n, r, o, a) {
            var s = i[n + 0],
                l = i[n + 1],
                c = i[n + 2];
            i = i[n + 3], n = r[o + 0];
            var h = r[o + 1],
                u = r[o + 2];
            if (i !== (r = r[o + 3]) || s !== n || l !== h || c !== u) {
                o = 1 - a;
                var d = s * n + l * h + c * u + i * r,
                    p = 0 <= d ? 1 : -1,
                    f = 1 - d * d;
                f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, a = Math.sin(a * d) / f), s = s * o + n * (p *= a), l = l * o + h * p, c = c * o + u * p, i = i * o + r * p, o === 1 - a && (s *= a = 1 / Math.sqrt(s * s + l * l + c * c + i * i), l *= a, c *= a, i *= a)
            }
            e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = i
        }
    }), Object.defineProperties(n.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(n.prototype, {
        isQuaternion: !0,
        set: function(e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e.order;
            var o = Math.cos,
                a = Math.sin,
                s = o(i / 2),
                l = o(n / 2);
            return o = o(r / 2), i = a(i / 2), n = a(n / 2), r = a(r / 2), "XYZ" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o - i * n * r) : "YXZ" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o + i * n * r) : "ZXY" === e ? (this._x = i * l * o - s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o - i * n * r) : "ZYX" === e ? (this._x = i * l * o - s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o + i * n * r) : "YZX" === e ? (this._x = i * l * o + s * n * r, this._y = s * n * o + i * l * r, this._z = s * l * r - i * n * o, this._w = s * l * o - i * n * r) : "XZY" === e && (this._x = i * l * o - s * n * r, this._y = s * n * o - i * l * r, this._z = s * l * r + i * n * o, this._w = s * l * o + i * n * r), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(e, t) {
            t /= 2;
            var i = Math.sin(t);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(t), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e) {
            var t = e.elements,
                i = t[0];
            e = t[4];
            var n = t[8],
                r = t[1],
                o = t[5],
                a = t[9],
                s = t[2],
                l = t[6],
                c = i + o + (t = t[10]);
            return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - a) * i, this._y = (n - s) * i, this._z = (r - e) * i) : i > o && i > t ? (i = 2 * Math.sqrt(1 + i - o - t), this._w = (l - a) / i, this._x = .25 * i, this._y = (e + r) / i, this._z = (n + s) / i) : o > t ? (i = 2 * Math.sqrt(1 + o - i - t), this._w = (n - s) / i, this._x = (e + r) / i, this._y = .25 * i, this._z = (a + l) / i) : (i = 2 * Math.sqrt(1 + t - i - o), this._w = (r - e) / i, this._x = (n + s) / i, this._y = (a + l) / i, this._z = .25 * i), this.onChangeCallback(), this
        },
        setFromUnitVectors: function(e, t) {
            var i = e.dot(t) + 1;
            return 1e-6 > i ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(uo.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var i = this.angleTo(e);
            return 0 === i || this.slerp(e, Math.min(1, t / i)), this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e._w;
            var o = t._x,
                a = t._y,
                s = t._z;
            return t = t._w, this._x = i * t + e * o + n * s - r * a, this._y = n * t + e * a + r * o - i * s, this._z = r * t + e * s + i * a - n * o, this._w = e * t - i * o - n * a - r * s, this.onChangeCallback(), this
        },
        slerp: function(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x,
                n = this._y,
                r = this._z,
                o = this._w,
                a = o * e._w + i * e._x + n * e._y + r * e._z;
            if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), 1 <= a) return this._w = o, this._x = i, this._y = n, this._z = r, this;
            if ((e = 1 - a * a) <= Number.EPSILON) return a = 1 - t, this._w = a * o + t * this._w, this._x = a * i + t * this._x, this._y = a * n + t * this._y, this._z = a * r + t * this._z, this.normalize();
            e = Math.sqrt(e);
            var s = Math.atan2(e, a);
            return a = Math.sin((1 - t) * s) / e, t = Math.sin(t * s) / e, this._w = o * a + this._w * t, this._x = i * a + this._x * t, this._y = n * a + this._y * t, this._z = r * a + this._z * t, this.onChangeCallback(), this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(r.prototype, {
        isVector3: !0,
        set: function(e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setScalar: function(e) {
            return this.z = this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: (ho = new n, function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ho.setFromEuler(e))
        }),
        applyAxisAngle: function() {
            var e = new n;
            return function(t, i) {
                return this.applyQuaternion(e.setFromAxisAngle(t, i))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
        },
        applyQuaternion: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = e.x,
                o = e.y,
                a = e.z,
                s = (e = e.w) * t + o * n - a * i,
                l = e * i + a * t - r * n,
                c = e * n + r * i - o * t;
            return t = -r * t - o * i - a * n, this.x = s * e + t * -r + l * -a - c * -o, this.y = l * e + t * -o + c * -r - s * -a, this.z = c * e + t * -a + s * -o - l * -r, this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = t.x,
                o = t.y;
            return t = t.z, this.x = n * t - e * o, this.y = e * r - i * t, this.z = i * o - n * r, this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function() {
            var e = new r;
            return function(t) {
                return e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function() {
            var e = new r;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()), Math.acos(uo.clamp(e, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return t * t + i * i + (e = this.z - e.z) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, i) {
            return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
        },
        setFromMatrixPosition: function(e) {
            return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                i = this.setFromMatrixColumn(e, 1).length();
            return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(o.prototype, {
        isMatrix3: !0,
        set: function(e, t, i, n, r, o, a, s, l) {
            var c = this.elements;
            return c[0] = e, c[1] = n, c[2] = a, c[3] = t, c[4] = r, c[5] = s, c[6] = i, c[7] = o, c[8] = l, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
        },
        setFromMatrix4: function(e) {
            return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function() {
            var e = new r;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[3],
                o = i[6],
                a = i[1],
                s = i[4],
                l = i[7],
                c = i[2],
                h = i[5];
            i = i[8];
            var u = n[0],
                d = n[3],
                p = n[6],
                f = n[1],
                m = n[4],
                g = n[7],
                v = n[2],
                y = n[5];
            return n = n[8], t[0] = e * u + r * f + o * v, t[3] = e * d + r * m + o * y, t[6] = e * p + r * g + o * n, t[1] = a * u + s * f + l * v, t[4] = a * d + s * m + l * y, t[7] = a * p + s * g + l * n, t[2] = c * u + h * f + i * v, t[5] = c * d + h * m + i * y, t[8] = c * p + h * g + i * n, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[1],
                n = e[2],
                r = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                l = e[7];
            return t * o * (e = e[8]) - t * a * l - i * r * e + i * a * s + n * r * l - n * o * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = e.elements;
            e = this.elements;
            var n = i[0],
                r = i[1],
                o = i[2],
                a = i[3],
                s = i[4],
                l = i[5],
                c = i[6],
                h = i[7],
                u = (i = i[8]) * s - l * h,
                d = l * c - i * a,
                p = h * a - s * c,
                f = n * u + r * d + o * p;
            if (0 === f) {
                if (!0 === t) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / f, e[0] = u * t, e[1] = (o * h - i * r) * t, e[2] = (l * r - o * s) * t, e[3] = d * t, e[4] = (i * n - o * c) * t, e[5] = (o * a - l * n) * t, e[6] = p * t, e[7] = (r * c - h * n) * t, e[8] = (s * n - r * a) * t, this
        },
        transpose: function() {
            var e = this.elements,
                t = e[1];
            return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        setUvTransform: function(e, t, i, n, r, o, a) {
            var s = Math.cos(r);
            r = Math.sin(r), this.set(i * s, i * r, -i * (s * o + r * a) + o + e, -n * r, n * s, -n * (-r * o + s * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var i = this.elements;
            return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
        },
        rotate: function(e) {
            var t = Math.cos(e);
            e = Math.sin(e);
            var i = this.elements,
                n = i[0],
                r = i[3],
                o = i[6],
                a = i[1],
                s = i[4],
                l = i[7];
            return i[0] = t * n + e * a, i[3] = t * r + e * s, i[6] = t * o + e * l, i[1] = -e * n + t * a, i[4] = -e * r + t * s, i[7] = -e * o + t * l, this
        },
        translate: function(e, t) {
            var i = this.elements;
            return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 9 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        }
    });
    var po, fo = {
            getDataURL: function(e) {
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (!(e instanceof HTMLCanvasElement)) {
                    void 0 === po && (po = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), po.width = e.width, po.height = e.height;
                    var t = po.getContext("2d");
                    e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), e = po
                }
                return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        mo = 0;
    a.DEFAULT_IMAGE = void 0, a.DEFAULT_MAPPING = 300, a.prototype = Object.assign(Object.create(t.prototype), {
        constructor: a,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = uo.generateUUID()), !t && void 0 === e.images[n.uuid]) {
                    if (Array.isArray(n))
                        for (var r = [], o = 0, a = n.length; o < a; o++) r.push(fo.getDataURL(n[o]));
                    else r = fo.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i), i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
                case 1e3:
                    e.x -= Math.floor(e.x);
                    break;
                case 1001:
                    e.x = 0 > e.x ? 0 : 1;
                    break;
                case 1002:
                    e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
            }
            if (0 > e.y || 1 < e.y) switch (this.wrapT) {
                case 1e3:
                    e.y -= Math.floor(e.y);
                    break;
                case 1001:
                    e.y = 0 > e.y ? 0 : 1;
                    break;
                case 1002:
                    e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(a.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(s.prototype, {
        isVector4: !0,
        set: function(e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        },
        setScalar: function(e) {
            return this.w = this.z = this.y = this.x = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setW: function(e) {
            return this.w = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t = (e = e.elements)[0],
                i = e[4],
                n = e[8],
                r = e[1],
                o = e[5],
                a = e[9],
                s = e[2],
                l = e[6],
                c = e[10];
            return .01 > Math.abs(i - r) && .01 > Math.abs(n - s) && .01 > Math.abs(a - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + s) && .1 > Math.abs(a + l) && .1 > Math.abs(t + o + c - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, c = (c + 1) / 2, i = (i + r) / 4, n = (n + s) / 4, a = (a + l) / 4, (t = (t + 1) / 2) > (o = (o + 1) / 2) && t > c ? .01 > t ? (l = 0, i = s = .707106781) : (s = i / (l = Math.sqrt(t)), i = n / l) : o > c ? .01 > o ? (l = .707106781, s = 0, i = .707106781) : (l = i / (s = Math.sqrt(o)), i = a / s) : .01 > c ? (s = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(c)), s = a / i), this.set(l, s, i, e), this) : (e = Math.sqrt((l - a) * (l - a) + (n - s) * (n - s) + (r - i) * (r - i)), .001 > Math.abs(e) && (e = 1), this.x = (l - a) / e, this.y = (n - s) / e, this.z = (r - i) / e, this.w = Math.acos((t + o + c - 1) / 2), this)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function() {
            var e, t;
            return function(i, n) {
                return void 0 === e && (e = new s, t = new s), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), l.prototype = Object.assign(Object.create(t.prototype), {
        constructor: l,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), c.prototype = Object.assign(Object.create(l.prototype), {
        constructor: c,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return l.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    }), h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.prototype.isWebGLRenderTargetCube = !0, u.prototype = Object.create(a.prototype), u.prototype.constructor = u, u.prototype.isDataTexture = !0, Object.assign(d.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                var c = e[s],
                    h = e[s + 1],
                    u = e[s + 2];
                c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, i, n), this.max.set(r, o, a), this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.count; s < l; s++) {
                var c = e.getX(s),
                    h = e.getY(s),
                    u = e.getZ(s);
                c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, i, n), this.max.set(r, o, a), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new r;
            return function(t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function() {
            function e(e) {
                var r = e.geometry;
                if (void 0 !== r)
                    if (r.isGeometry)
                        for (r = r.vertices, i = 0, n = r.length; i < n; i++) o.copy(r[i]), o.applyMatrix4(e.matrixWorld), t.expandByPoint(o);
                    else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position))
                    for (i = 0, n = r.count; i < n; i++) o.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), t.expandByPoint(o)
            }
            var t, i, n, o = new r;
            return function(i) {
                return t = this, i.updateMatrixWorld(!0), i.traverse(e), this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new r), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var e = new r;
            return function(t) {
                return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function(e) {
            if (0 < e.normal.x) var t = e.normal.x * this.min.x,
                i = e.normal.x * this.max.x;
            else t = e.normal.x * this.max.x, i = e.normal.x * this.min.x;
            return 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
        },
        intersectsTriangle: function() {
            function e(e) {
                var r, o = 0;
                for (r = e.length - 3; o <= r; o += 3) {
                    l.fromArray(e, o);
                    var a = h.x * Math.abs(l.x) + h.y * Math.abs(l.y) + h.z * Math.abs(l.z),
                        s = t.dot(l),
                        c = i.dot(l),
                        u = n.dot(l);
                    if (Math.max(-Math.max(s, c, u), Math.min(s, c, u)) > a) return !1
                }
                return !0
            }
            var t = new r,
                i = new r,
                n = new r,
                o = new r,
                a = new r,
                s = new r,
                l = new r,
                c = new r,
                h = new r,
                u = new r;
            return function(r) {
                return !this.isEmpty() && (this.getCenter(c), h.subVectors(this.max, c), t.subVectors(r.a, c), i.subVectors(r.b, c), n.subVectors(r.c, c), o.subVectors(i, t), a.subVectors(n, i), s.subVectors(t, n), !!e(r = [0, -o.z, o.y, 0, -a.z, a.y, 0, -s.z, s.y, o.z, 0, -o.x, a.z, 0, -a.x, s.z, 0, -s.x, -o.y, o.x, 0, -a.y, a.x, 0, -s.y, s.x, 0]) && !!e(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(o, a), e(r = [u.x, u.y, u.z])))
            }
        }(),
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new r), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new r;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new r;
            return function(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function() {
            var e = [new r, new r, new r, new r, new r, new r, new r, new r];
            return function(t) {
                return this.isEmpty() || (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e)), this
            }
        }(),
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(p.prototype, {
        set: function(e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function() {
            var e = new d;
            return function(t, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : e.setFromPoints(t).getCenter(n);
                for (var r = i = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new r), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new d), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function(e) {
            return this.center.add(e), this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(f.prototype, {
        set: function(e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function(e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var e = new r,
                t = new r;
            return function(i, n, r) {
                return n = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function() {
            var e = new r;
            return function(t, i) {
                void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new r);
                var n = t.delta(e),
                    o = this.normal.dot(n);
                if (0 === o) {
                    if (0 === this.distanceToPoint(t.start)) return i.copy(t.start)
                } else if (!(0 > (o = -(t.start.dot(this.normal) + this.constant) / o) || 1 < o)) return i.copy(n).multiplyScalar(o).add(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new r,
                t = new o;
            return function(i, n) {
                return n = n || t.getNormalMatrix(i), i = this.coplanarPoint(e).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(m.prototype, {
        set: function(e, t, i, n, r, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes,
                i = e.elements;
            e = i[0];
            var n = i[1],
                r = i[2],
                o = i[3],
                a = i[4],
                s = i[5],
                l = i[6],
                c = i[7],
                h = i[8],
                u = i[9],
                d = i[10],
                p = i[11],
                f = i[12],
                m = i[13],
                g = i[14];
            return i = i[15], t[0].setComponents(o - e, c - a, p - h, i - f).normalize(), t[1].setComponents(o + e, c + a, p + h, i + f).normalize(), t[2].setComponents(o + n, c + s, p + u, i + m).normalize(), t[3].setComponents(o - n, c - s, p - u, i - m).normalize(), t[4].setComponents(o - r, c - l, p - d, i - g).normalize(), t[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
        },
        intersectsObject: function() {
            var e = new p;
            return function(t) {
                var i = t.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function() {
            var e = new p;
            return function(t) {
                return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var n = 0; 6 > n; n++)
                if (t[n].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function() {
            var e = new r;
            return function(t) {
                for (var i = this.planes, n = 0; 6 > n; n++) {
                    var r = i[n];
                    if (e.x = 0 < r.normal.x ? t.max.x : t.min.x, e.y = 0 < r.normal.y ? t.max.y : t.min.y, e.z = 0 < r.normal.z ? t.max.z : t.min.z, 0 > r.distanceToPoint(e)) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++)
                if (0 > t[i].distanceToPoint(e)) return !1;
            return !0
        }
    }), Object.assign(g.prototype, {
        isMatrix4: !0,
        set: function(e, t, i, n, r, o, a, s, l, c, h, u, d, p, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new g).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
        },
        copyPosition: function(e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractBasis: function(e, t, i) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var e = new r;
            return function(t) {
                var i = this.elements,
                    n = t.elements,
                    r = 1 / e.setFromMatrixColumn(t, 0).length(),
                    o = 1 / e.setFromMatrixColumn(t, 1).length();
                return t = 1 / e.setFromMatrixColumn(t, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
            }
        }(),
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                o = Math.cos(i);
            i = Math.sin(i);
            var a = Math.cos(n);
            n = Math.sin(n);
            var s = Math.cos(r);
            if (r = Math.sin(r), "XYZ" === e.order) {
                e = o * s;
                var l = o * r,
                    c = i * s,
                    h = i * r;
                t[0] = a * s, t[4] = -a * r, t[8] = n, t[1] = l + c * n, t[5] = e - h * n, t[9] = -i * a, t[2] = h - e * n, t[6] = c + l * n, t[10] = o * a
            } else "YXZ" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e + h * i, t[4] = c * i - l, t[8] = o * n, t[1] = o * r, t[5] = o * s, t[9] = -i, t[2] = l * i - c, t[6] = h + e * i, t[10] = o * a) : "ZXY" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e - h * i, t[4] = -o * r, t[8] = c + l * i, t[1] = l + c * i, t[5] = o * s, t[9] = h - e * i, t[2] = -o * n, t[6] = i, t[10] = o * a) : "ZYX" === e.order ? (e = o * s, l = o * r, c = i * s, h = i * r, t[0] = a * s, t[4] = c * n - l, t[8] = e * n + h, t[1] = a * r, t[5] = h * n + e, t[9] = l * n - c, t[2] = -n, t[6] = i * a, t[10] = o * a) : "YZX" === e.order ? (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = h - e * r, t[8] = c * r + l, t[1] = r, t[5] = o * s, t[9] = -i * s, t[2] = -n * s, t[6] = l * r + c, t[10] = e - h * r) : "XZY" === e.order && (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = -r, t[8] = n * s, t[1] = e * r + h, t[5] = o * s, t[9] = l * r - c, t[2] = c * r - l, t[6] = i * s, t[10] = h * r + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function() {
            var e = new r(0, 0, 0),
                t = new r(1, 1, 1);
            return function(i) {
                return this.compose(e, i, t)
            }
        }(),
        lookAt: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, r, o) {
                var a = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), e.crossVectors(o, i), 0 === e.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(o, i)), e.normalize(), t.crossVectors(i, e), a[0] = e.x, a[4] = t.x, a[8] = i.x, a[1] = e.y, a[5] = t.y, a[9] = i.y, a[2] = e.z, a[6] = t.z, a[10] = i.z, this
            }
        }(),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[4],
                o = i[8],
                a = i[12],
                s = i[1],
                l = i[5],
                c = i[9],
                h = i[13],
                u = i[2],
                d = i[6],
                p = i[10],
                f = i[14],
                m = i[3],
                g = i[7],
                v = i[11];
            i = i[15];
            var y = n[0],
                b = n[4],
                x = n[8],
                w = n[12],
                _ = n[1],
                E = n[5],
                M = n[9],
                T = n[13],
                S = n[2],
                A = n[6],
                C = n[10],
                L = n[14],
                D = n[3],
                P = n[7],
                R = n[11];
            return n = n[15], t[0] = e * y + r * _ + o * S + a * D, t[4] = e * b + r * E + o * A + a * P, t[8] = e * x + r * M + o * C + a * R, t[12] = e * w + r * T + o * L + a * n, t[1] = s * y + l * _ + c * S + h * D, t[5] = s * b + l * E + c * A + h * P, t[9] = s * x + l * M + c * C + h * R, t[13] = s * w + l * T + c * L + h * n, t[2] = u * y + d * _ + p * S + f * D, t[6] = u * b + d * E + p * A + f * P, t[10] = u * x + d * M + p * C + f * R, t[14] = u * w + d * T + p * L + f * n, t[3] = m * y + g * _ + v * S + i * D, t[7] = m * b + g * E + v * A + i * P, t[11] = m * x + g * M + v * C + i * R, t[15] = m * w + g * T + v * L + i * n, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function() {
            var e = new r;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[4],
                n = e[8],
                r = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                l = e[13],
                c = e[2],
                h = e[6],
                u = e[10],
                d = e[14];
            return e[3] * (+r * s * h - n * l * h - r * a * u + i * l * u + n * a * d - i * s * d) + e[7] * (+t * s * d - t * l * u + r * o * u - n * o * d + n * l * c - r * s * c) + e[11] * (+t * l * h - t * a * d - r * o * h + i * o * d + r * a * c - i * l * c) + e[15] * (-n * a * c - t * s * h + t * a * u + n * o * h - i * o * u + i * s * c)
        },
        transpose: function() {
            var e = this.elements,
                t = e[1];
            return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function(e, t, i) {
            var n = this.elements;
            return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
        },
        getInverse: function(e, t) {
            var i = this.elements,
                n = e.elements;
            e = n[0];
            var r = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                l = n[5],
                c = n[6],
                h = n[7],
                u = n[8],
                d = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = d * v * h - g * p * h + g * c * f - l * v * f - d * c * (n = n[15]) + l * p * n,
                b = m * p * h - u * v * h - m * c * f + s * v * f + u * c * n - s * p * n,
                x = u * g * h - m * d * h + m * l * f - s * g * f - u * l * n + s * d * n,
                w = m * d * c - u * g * c - m * l * p + s * g * p + u * l * v - s * d * v,
                _ = e * y + r * b + o * x + a * w;
            if (0 === _) {
                if (!0 === t) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / _, i[0] = y * t, i[1] = (g * p * a - d * v * a - g * o * f + r * v * f + d * o * n - r * p * n) * t, i[2] = (l * v * a - g * c * a + g * o * h - r * v * h - l * o * n + r * c * n) * t, i[3] = (d * c * a - l * p * a - d * o * h + r * p * h + l * o * f - r * c * f) * t, i[4] = b * t, i[5] = (u * v * a - m * p * a + m * o * f - e * v * f - u * o * n + e * p * n) * t, i[6] = (m * c * a - s * v * a - m * o * h + e * v * h + s * o * n - e * c * n) * t, i[7] = (s * p * a - u * c * a + u * o * h - e * p * h - s * o * f + e * c * f) * t, i[8] = x * t, i[9] = (m * d * a - u * g * a - m * r * f + e * g * f + u * r * n - e * d * n) * t, i[10] = (s * g * a - m * l * a + m * r * h - e * g * h - s * r * n + e * l * n) * t, i[11] = (u * l * a - s * d * a - u * r * h + e * d * h + s * r * f - e * l * f) * t, i[12] = w * t, i[13] = (u * g * o - m * d * o + m * r * p - e * g * p - u * r * v + e * d * v) * t, i[14] = (m * l * o - s * g * o - m * r * c + e * g * c + s * r * v - e * l * v) * t, i[15] = (s * d * o - u * l * o + u * r * c - e * d * c - s * r * p + e * l * p) * t, this
        },
        scale: function(e) {
            var t = this.elements,
                i = e.x,
                n = e.y;
            return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
        },
        makeTranslation: function(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = 1 - i,
                r = e.x,
                o = e.y;
            e = e.z;
            var a = n * r,
                s = n * o;
            return this.set(a * r + i, a * o - t * e, a * e + t * o, 0, a * o + t * e, s * o + i, s * e - t * r, 0, a * e - t * o, s * e + t * r, n * e * e + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function(e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(e, t, i) {
            var n = this.elements,
                r = t._x,
                o = t._y,
                a = t._z,
                s = t._w,
                l = r + r,
                c = o + o,
                h = a + a;
            t = r * l;
            var u = r * c;
            r *= h;
            var d = o * c;
            o *= h, a *= h, l *= s, c *= s, s *= h, h = i.x;
            var p = i.y;
            return i = i.z, n[0] = (1 - (d + a)) * h, n[1] = (u + s) * h, n[2] = (r - c) * h, n[3] = 0, n[4] = (u - s) * p, n[5] = (1 - (t + a)) * p, n[6] = (o + l) * p, n[7] = 0, n[8] = (r + c) * i, n[9] = (o - l) * i, n[10] = (1 - (t + d)) * i, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
        },
        decompose: function() {
            var e = new r,
                t = new g;
            return function(i, n, r) {
                var o = this.elements,
                    a = e.set(o[0], o[1], o[2]).length(),
                    s = e.set(o[4], o[5], o[6]).length(),
                    l = e.set(o[8], o[9], o[10]).length();
                0 > this.determinant() && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], t.copy(this), i = 1 / a, o = 1 / s;
                var c = 1 / l;
                return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= c, t.elements[9] *= c, t.elements[10] *= c, n.setFromRotationMatrix(t), r.x = a, r.y = s, r.z = l, this
            }
        }(),
        makePerspective: function(e, t, i, n, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements;
            return a[0] = 2 * r / (t - e), a[4] = 0, a[8] = (t + e) / (t - e), a[12] = 0, a[1] = 0, a[5] = 2 * r / (i - n), a[9] = (i + n) / (i - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + r) / (o - r), a[14] = -2 * o * r / (o - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(e, t, i, n, r, o) {
            var a = this.elements,
                s = 1 / (t - e),
                l = 1 / (i - n),
                c = 1 / (o - r);
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -(t + e) * s, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -(i + n) * l, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -(o + r) * c, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 16 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        }
    });
    var go = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        vo = {
            clone: v,
            merge: y
        },
        yo = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
    Object.assign(b.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function(e) {
            return this.b = this.g = this.r = e, this
        },
        setHex: function(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function(e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function() {
            function e(e, t, i) {
                return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? e + 6 * (t - e) * i : .5 > i ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }
            return function(t, i, n) {
                return t = uo.euclideanModulo(t, 1), i = uo.clamp(i, 0, 1), n = uo.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i), this.r = e(n, i, t + 1 / 3), this.g = e(n, i, t), this.b = e(n, i, t - 1 / 3)), this
            }
        }(),
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n = i[2];
                switch (i[1]) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                        if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                            n = parseFloat(i[1]) / 360;
                            var r = parseInt(i[2], 10) / 100,
                                o = parseInt(i[3], 10) / 100;
                            return t(i[5]), this.setHSL(n, r, o)
                        }
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(e)) {
                if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
            }
            return e && 0 < e.length && (void 0 !== (i = yo[e]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function(e, t) {
            return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e), this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e), this
        },
        copySRGBToLinear: function() {
            function e(e) {
                return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function(t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        copyLinearToSRGB: function() {
            function e(e) {
                return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function(t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, i = this.r,
                n = this.g,
                r = this.b,
                o = Math.max(i, n, r),
                a = Math.min(i, n, r),
                s = (a + o) / 2;
            if (a === o) a = t = 0;
            else {
                var l = o - a;
                switch (a = .5 >= s ? l / (o + a) : l / (2 - o - a), o) {
                    case i:
                        t = (n - r) / l + (n < r ? 6 : 0);
                        break;
                    case n:
                        t = (r - i) / l + 2;
                        break;
                    case r:
                        t = (i - n) / l + 4
                }
                t /= 6
            }
            return e.h = t, e.s = a, e.l = s, e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var e = {};
            return function(t, i, n) {
                return this.getHSL(e), e.h += t, e.s += i, e.l += n, this.setHSL(e.h, e.s, e.l), this
            }
        }(),
        add: function(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function(e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        lerpHSL: function() {
            var e = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                t = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            return function(i, n) {
                this.getHSL(e), i.getHSL(t), i = uo.lerp(e.h, t.h, n);
                var r = uo.lerp(e.s, t.s, n);
                return n = uo.lerp(e.l, t.l, n), this.setHSL(i, r, n), this
            }
        }(),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var bo = {
            common: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new i(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new b(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            },
            sprite: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new i(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            }
        },
        xo = {
            basic: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.fog]),
                vertexShader: go.meshbasic_vert,
                fragmentShader: go.meshbasic_frag
            },
            lambert: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    }
                }]),
                vertexShader: go.meshlambert_vert,
                fragmentShader: go.meshlambert_frag
            },
            phong: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.gradientmap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    specular: {
                        value: new b(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: go.meshphong_vert,
                fragmentShader: go.meshphong_frag
            },
            standard: {
                uniforms: y([bo.common, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.roughnessmap, bo.metalnessmap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshphysical_vert,
                fragmentShader: go.meshphysical_frag
            },
            matcap: {
                uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: go.meshmatcap_vert,
                fragmentShader: go.meshmatcap_frag
            },
            points: {
                uniforms: y([bo.points, bo.fog]),
                vertexShader: go.points_vert,
                fragmentShader: go.points_frag
            },
            dashed: {
                uniforms: y([bo.common, bo.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: go.linedashed_vert,
                fragmentShader: go.linedashed_frag
            },
            depth: {
                uniforms: y([bo.common, bo.displacementmap]),
                vertexShader: go.depth_vert,
                fragmentShader: go.depth_frag
            },
            normal: {
                uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.normal_vert,
                fragmentShader: go.normal_frag
            },
            sprite: {
                uniforms: y([bo.sprite, bo.fog]),
                vertexShader: go.sprite_vert,
                fragmentShader: go.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new o
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: go.background_vert,
                fragmentShader: go.background_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: go.cube_vert,
                fragmentShader: go.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: go.equirect_vert,
                fragmentShader: go.equirect_frag
            },
            distanceRGBA: {
                uniforms: y([bo.common, bo.displacementmap, {
                    referencePosition: {
                        value: new r
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: go.distanceRGBA_vert,
                fragmentShader: go.distanceRGBA_frag
            },
            shadow: {
                uniforms: y([bo.lights, bo.fog, {
                    color: {
                        value: new b(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.shadow_vert,
                fragmentShader: go.shadow_frag
            }
        };
    xo.physical = {
        uniforms: y([xo.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: go.meshphysical_vert,
        fragmentShader: go.meshphysical_frag
    }, Object.assign(_.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }), E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), E.DefaultOrder = "XYZ", Object.defineProperties(E.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(E.prototype, {
        isEuler: !0,
        set: function(e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e, t, i) {
            var n = uo.clamp,
                r = e.elements;
            e = r[0];
            var o = r[4],
                a = r[8],
                s = r[1],
                l = r[5],
                c = r[9],
                h = r[2],
                u = r[6];
            return r = r[10], "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, e)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(a, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-h, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, e))) : "ZYX" === t ? (this._y = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, e)) : (this._x = 0, this._y = Math.atan2(a, r))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, e)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function() {
            var e = new n;
            return function(t) {
                return e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(M.prototype, {
        set: function(e) {
            this.mask = 1 << e
        },
        enable: function(e) {
            this.mask = this.mask | 1 << e
        },
        toggle: function(e) {
            this.mask ^= 1 << e
        },
        disable: function(e) {
            this.mask &= ~(1 << e)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var wo = 0;
    T.DefaultUp = new r(0, 1, 0), T.DefaultMatrixAutoUpdate = !0, T.prototype = Object.assign(Object.create(t.prototype), {
        constructor: T,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function() {
            var e = new n;
            return function(t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
            }
        }(),
        rotateOnWorldAxis: function() {
            var e = new n;
            return function(t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.premultiply(e), this
            }
        }(),
        rotateX: function() {
            var e = new r(1, 0, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new r(0, 1, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new r(0, 0, 1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new r;
            return function(t, i) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
            }
        }(),
        translateX: function() {
            var e = new r(1, 0, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new r(0, 1, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new r(0, 0, 1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var e = new g;
            return function(t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var e = new n,
                t = new g,
                i = new r,
                o = new r;
            return function(n, r, a) {
                n.isVector3 ? i.copy(n) : i.set(n, r, a), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(o, i, this.up) : t.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(t), n && (t.extractRotation(n.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(t, 1)), this
        },
        attach: function() {
            var e = new g;
            return function(t) {
                return this.updateWorldMatrix(!0, !1), e.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), e.multiply(t.parent.matrixWorld)), t.applyMatrix(e), t.updateWorldMatrix(!1, !1), this.add(t), this
            }
        }(),
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new r), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var e = new r,
                t = new r;
            return function(i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
            }
        }(),
        getWorldScale: function() {
            var e = new r,
                t = new n;
            return function(i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
            }
        }(),
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (t = 0, i = (e = this.children).length; t < i; t++) e[t].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            function t(t, i) {
                return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
            }

            function i(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var n = void 0 === e || "string" == typeof e,
                r = {};
            n && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var o = {};
            if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                o.geometry = t(e.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes)
                    if (a = a.shapes, Array.isArray(a))
                        for (var s = 0, l = a.length; s < l; s++) t(e.shapes, a[s]);
                    else t(e.shapes, a)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (a = [], s = 0, l = this.material.length; s < l; s++) a.push(t(e.materials, this.material[s]));
                    o.material = a
                } else o.material = t(e.materials, this.material);
            if (0 < this.children.length)
                for (o.children = [], s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(e).object);
            if (n) {
                n = i(e.geometries), s = i(e.materials), l = i(e.textures);
                var c = i(e.images);
                a = i(e.shapes), 0 < n.length && (r.geometries = n), 0 < s.length && (r.materials = s), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < a.length && (r.shapes = a)
            }
            return r.object = o, r
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
            return this
        }
    });
    var _o = 0;
    S.prototype = Object.assign(Object.create(t.prototype), {
        constructor: S,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new o).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, n = this.faces.length; i < n; i++) {
                (e = this.faces[i]).normal.applyMatrix3(t).normalize();
                for (var r = 0, a = e.vertexNormals.length; r < a; r++) e.vertexNormals[r].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
        },
        rotateX: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new T;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function(e) {
            function t(e, t, o, a) {
                var s = void 0 === c ? [] : [n.colors[e].clone(), n.colors[t].clone(), n.colors[o].clone()];
                a = new _(e, t, o, void 0 === l ? [] : [(new r).fromArray(l, 3 * e), (new r).fromArray(l, 3 * t), (new r).fromArray(l, 3 * o)], s, a), n.faces.push(a), void 0 !== h && n.faceVertexUvs[0].push([(new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * o)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * o)])
            }
            var n = this,
                o = null !== e.index ? e.index.array : void 0,
                a = e.attributes,
                s = a.position.array,
                l = void 0 !== a.normal ? a.normal.array : void 0,
                c = void 0 !== a.color ? a.color.array : void 0,
                h = void 0 !== a.uv ? a.uv.array : void 0,
                u = void 0 !== a.uv2 ? a.uv2.array : void 0;
            for (void 0 !== u && (this.faceVertexUvs[1] = []), a = 0; a < s.length; a += 3) n.vertices.push((new r).fromArray(s, a)), void 0 !== c && n.colors.push((new b).fromArray(c, a));
            var d = e.groups;
            if (0 < d.length)
                for (a = 0; a < d.length; a++) {
                    var p = (s = d[a]).start,
                        f = p;
                    for (p += s.count; f < p; f += 3) void 0 !== o ? t(o[f], o[f + 1], o[f + 2], s.materialIndex) : t(f, f + 1, f + 2, s.materialIndex)
                } else if (void 0 !== o)
                    for (a = 0; a < o.length; a += 3) t(o[a], o[a + 1], o[a + 2]);
                else
                    for (a = 0; a < s.length / 3; a += 3) t(a, a + 1, a + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            var e = new r;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius;
            t = 0 === t ? 1 : 1 / t;
            var i = new g;
            return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix(i), this
        },
        computeFaceNormals: function() {
            for (var e = new r, t = new r, i = 0, n = this.faces.length; i < n; i++) {
                var o = this.faces[i],
                    a = this.vertices[o.a],
                    s = this.vertices[o.b];
                e.subVectors(this.vertices[o.c], s), t.subVectors(a, s), e.cross(t), e.normalize(), o.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t;
            void 0 === e && (e = !0);
            var i = Array(this.vertices.length),
                n = 0;
            for (t = this.vertices.length; n < t; n++) i[n] = new r;
            if (e) {
                var o = new r,
                    a = new r;
                for (e = 0, n = this.faces.length; e < n; e++) {
                    t = this.faces[e];
                    var s = this.vertices[t.a],
                        l = this.vertices[t.b],
                        c = this.vertices[t.c];
                    o.subVectors(c, l), a.subVectors(s, l), o.cross(a), i[t.a].add(o), i[t.b].add(o), i[t.c].add(o)
                }
            } else
                for (this.computeFaceNormals(), e = 0, n = this.faces.length; e < n; e++) i[(t = this.faces[e]).a].add(t.normal), i[t.b].add(t.normal), i[t.c].add(t.normal);
            for (n = 0, t = this.vertices.length; n < t; n++) i[n].normalize();
            for (e = 0, n = this.faces.length; e < n; e++) 3 === (s = (t = this.faces[e]).vertexNormals).length ? (s[0].copy(i[t.a]), s[1].copy(i[t.b]), s[2].copy(i[t.c])) : (s[0] = i[t.a].clone(), s[1] = i[t.b].clone(), s[2] = i[t.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e;
            this.computeFaceNormals();
            var t = 0;
            for (e = this.faces.length; t < e; t++) {
                var i = this.faces[t],
                    n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, i = 0;
            for (t = this.faces.length; i < t; i++) {
                var n = this.faces[i];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                var o = 0;
                for (e = n.vertexNormals.length; o < e; o++) n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone()
            }
            var a = new S;
            for (a.faces = this.faces, o = 0, e = this.morphTargets.length; o < e; o++) {
                if (!this.morphNormals[o]) {
                    this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
                    var s = this.morphNormals[o].vertexNormals;
                    for (i = 0, t = this.faces.length; i < t; i++) {
                        var l = new r,
                            c = {
                                a: new r,
                                b: new r,
                                c: new r
                            };
                        n.push(l), s.push(c)
                    }
                }
                for (s = this.morphNormals[o], a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, t = this.faces.length; i < t; i++) n = this.faces[i], l = s.faceNormals[i], c = s.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
            }
            for (i = 0, t = this.faces.length; i < t; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length,
                    a = this.vertices,
                    s = e.vertices,
                    l = this.faces,
                    c = e.faces,
                    h = this.faceVertexUvs[0],
                    u = e.faceVertexUvs[0],
                    d = this.colors,
                    p = e.colors;
                void 0 === i && (i = 0), void 0 !== t && (n = (new o).getNormalMatrix(t)), e = 0;
                for (var f = s.length; e < f; e++) {
                    var m = s[e].clone();
                    void 0 !== t && m.applyMatrix4(t), a.push(m)
                }
                for (e = 0, f = p.length; e < f; e++) d.push(p[e].clone());
                for (e = 0, f = c.length; e < f; e++) {
                    var g = (s = c[e]).vertexNormals;
                    for (p = s.vertexColors, (d = new _(s.a + r, s.b + r, s.c + r)).normal.copy(s.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize(), t = 0, a = g.length; t < a; t++) m = g[t].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), d.vertexNormals.push(m);
                    for (d.color.copy(s.color), t = 0, a = p.length; t < a; t++) m = p[t], d.vertexColors.push(m.clone());
                    d.materialIndex = s.materialIndex + i, l.push(d)
                }
                for (e = 0, f = u.length; e < f; e++)
                    if (n = [], void 0 !== (i = u[e])) {
                        for (t = 0, a = i.length; t < a; t++) n.push(i[t].clone());
                        h.push(n)
                    }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t = {},
                i = [],
                n = [],
                r = Math.pow(10, 4),
                o = 0;
            for (e = this.vertices.length; o < e; o++) {
                var a = this.vertices[o];
                void 0 === t[a = Math.round(a.x * r) + "_" + Math.round(a.y * r) + "_" + Math.round(a.z * r)] ? (t[a] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[t[a]]
            }
            for (t = [], o = 0, e = this.faces.length; o < e; o++)
                for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], a = 0; 3 > a; a++)
                    if (r[a] === r[(a + 1) % 3]) {
                        t.push(o);
                        break
                    } for (o = t.length - 1; 0 <= o; o--)
                for (r = t[o], this.faces.splice(r, 1), n = 0, e = this.faceVertexUvs.length; n < e; n++) this.faceVertexUvs[n].splice(r, 1);
            return o = this.vertices.length - i.length, this.vertices = i, o
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new r(n.x, n.y, n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
            e.sort((function(e, t) {
                return e.materialIndex - t.materialIndex
            }));
            var n, r, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            for (o && o.length === t && (n = []), a && a.length === t && (r = []), i = 0; i < t; i++) {
                var s = e[i]._id;
                n && n.push(o[s]), r && r.push(a[s])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] || (c[t] = l.length / 3, l.push(e.x, e.y, e.z)), c[t]
            }

            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] || (u[t] = h.length, h.push(e.getHex())), u[t]
            }

            function n(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] || (p[t] = d.length / 2, d.push(e.x, e.y)), p[t]
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var o, a = this.parameters;
                for (o in a) void 0 !== a[o] && (r[o] = a[o]);
                return r
            }
            for (a = [], o = 0; o < this.vertices.length; o++) {
                var s = this.vertices[o];
                a.push(s.x, s.y, s.z)
            }
            s = [];
            var l = [],
                c = {},
                h = [],
                u = {},
                d = [],
                p = {};
            for (o = 0; o < this.faces.length; o++) {
                var f = this.faces[o],
                    m = void 0 !== this.faceVertexUvs[0][o],
                    g = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length,
                    y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    b = 0 < f.vertexColors.length,
                    x = 0;
                x = e(x, 0, 0), x = e(x, 1, !0), x = e(x, 2, !1), x = e(x, 3, m), x = e(x, 4, g), x = e(x, 5, v), x = e(x, 6, y), x = e(x, 7, b), s.push(x), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(t(f.normal)), v && (g = f.vertexNormals, s.push(t(g[0]), t(g[1]), t(g[2]))), y && s.push(i(f.color)), b && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {}, r.data.vertices = a, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < d.length && (r.data.uvs = [d]), r.data.faces = s, r
        },
        clone: function() {
            return (new S).copy(this)
        },
        copy: function(e) {
            var t, i, n;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var r = e.vertices,
                o = 0;
            for (t = r.length; o < t; o++) this.vertices.push(r[o].clone());
            for (o = 0, t = (r = e.colors).length; o < t; o++) this.colors.push(r[o].clone());
            for (o = 0, t = (r = e.faces).length; o < t; o++) this.faces.push(r[o].clone());
            for (o = 0, t = e.faceVertexUvs.length; o < t; o++) {
                var a = e.faceVertexUvs[o];
                for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = a.length; r < i; r++) {
                    var s = a[r],
                        l = [],
                        c = 0;
                    for (n = s.length; c < n; c++) l.push(s[c].clone());
                    this.faceVertexUvs[o].push(l)
                }
            }
            for (o = 0, t = (c = e.morphTargets).length; o < t; o++) {
                if ((n = {}).name = c[o].name, void 0 !== c[o].vertices)
                    for (n.vertices = [], r = 0, i = c[o].vertices.length; r < i; r++) n.vertices.push(c[o].vertices[r].clone());
                if (void 0 !== c[o].normals)
                    for (n.normals = [], r = 0, i = c[o].normals.length; r < i; r++) n.normals.push(c[o].normals[r].clone());
                this.morphTargets.push(n)
            }
            for (o = 0, t = (c = e.morphNormals).length; o < t; o++) {
                if (n = {}, void 0 !== c[o].vertexNormals)
                    for (n.vertexNormals = [], r = 0, i = c[o].vertexNormals.length; r < i; r++) a = c[o].vertexNormals[r], (s = {}).a = a.a.clone(), s.b = a.b.clone(), s.c = a.c.clone(), n.vertexNormals.push(s);
                if (void 0 !== c[o].faceNormals)
                    for (n.faceNormals = [], r = 0, i = c[o].faceNormals.length; r < i; r++) n.faceNormals.push(c[o].faceNormals[r].clone());
                this.morphNormals.push(n)
            }
            for (o = 0, t = (r = e.skinWeights).length; o < t; o++) this.skinWeights.push(r[o].clone());
            for (o = 0, t = (r = e.skinIndices).length; o < t; o++) this.skinIndices.push(r[o].clone());
            for (o = 0, t = (r = e.lineDistances).length; o < t; o++) this.lineDistances.push(r[o]);
            return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()), null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(A.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(A.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
        },
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e), this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new b), t[i++] = o.r, t[i++] = o.g, t[i++] = o.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, o = e.length; r < o; r++) {
                var a = e[r];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), t[n++] = a.x, t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, o = e.length; n < o; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new r), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new s), t[i++] = o.x, t[i++] = o.y, t[i++] = o.z, t[i++] = o.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function(e, t, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
        },
        setXYZ: function(e, t, i, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
        },
        setXYZW: function(e, t, i, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), C.prototype = Object.create(A.prototype), C.prototype.constructor = C, L.prototype = Object.create(A.prototype), L.prototype.constructor = L, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, P.prototype = Object.create(A.prototype), P.prototype.constructor = P, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, z.prototype = Object.create(A.prototype), z.prototype.constructor = z, N.prototype = Object.create(A.prototype), N.prototype.constructor = N, Object.assign(B.prototype, {
        computeGroups: function(e) {
            var t = [],
                i = void 0;
            e = e.faces;
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                if (r.materialIndex !== i) {
                    i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, t.push(o));
                    var o = {
                        start: 3 * n,
                        materialIndex: i
                    }
                }
            }
            void 0 !== o && (o.count = 3 * n - o.start, t.push(o)), this.groups = t
        },
        fromGeometry: function(e) {
            var t = e.faces,
                n = e.vertices,
                r = e.faceVertexUvs,
                o = r[0] && 0 < r[0].length,
                a = r[1] && 0 < r[1].length,
                s = e.morphTargets,
                l = s.length;
            if (0 < l) {
                for (var c = [], h = 0; h < l; h++) c[h] = {
                    name: s[h].name,
                    data: []
                };
                this.morphTargets.position = c
            }
            var u = e.morphNormals,
                d = u.length;
            if (0 < d) {
                var p = [];
                for (h = 0; h < d; h++) p[h] = {
                    name: u[h].name,
                    data: []
                };
                this.morphTargets.normal = p
            }
            var f = e.skinIndices,
                m = e.skinWeights,
                g = f.length === n.length,
                v = m.length === n.length;
            for (0 < n.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < t.length; h++) {
                var y = t[h];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var b = y.vertexNormals;
                for (3 === b.length ? this.normals.push(b[0], b[1], b[2]) : (b = y.normal, this.normals.push(b, b, b)), 3 === (b = y.vertexColors).length ? this.colors.push(b[0], b[1], b[2]) : (b = y.color, this.colors.push(b, b, b)), !0 === o && (void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === a && (void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), b = 0; b < l; b++) {
                    var x = s[b].vertices;
                    c[b].data.push(x[y.a], x[y.b], x[y.c])
                }
                for (b = 0; b < d; b++) x = u[b].vertexNormals[h], p[b].data.push(x.a, x.b, x.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    });
    var Eo = 1;
    k.prototype = Object.assign(Object.create(t.prototype), {
        constructor: k,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new(65535 < F(e) ? I : R)(e, 1) : this.index = e
        },
        addAttribute: function(e, t, i) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new A(t, i)))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e], this
        },
        addGroup: function(e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var i = this.attributes.normal;
            return void 0 !== i && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new g;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new g;
            return function(t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new T;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            var e = new r;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                e = new z(3 * t.vertices.length, 3);
                var i = new z(3 * t.colors.length, 3);
                this.addAttribute("position", e.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new z(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new z(t, 3)), this
        },
        updateFromObject: function(e) {
            var t = e.geometry;
            if (e.isMesh) {
                var i = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (i = void 0, t.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(t);
                i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
            }
            return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new B).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            for (var i in this.addAttribute("position", new A(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", new A(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", new A(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", new A(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", new A(t, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) {
                t = [];
                for (var n = e.morphTargets[i], r = 0, o = n.length; r < o; r++) {
                    var a = n[r],
                        s = new z(3 * a.data.length, 3);
                    s.name = a.name, t.push(s.copyVector3sArray(a.data))
                }
                this.morphAttributes[i] = t
            }
            return 0 < e.skinIndices.length && (i = new z(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new z(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            var e = new d;
            return function() {
                null === this.boundingBox && (this.boundingBox = new d);
                var t = this.attributes.position,
                    i = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), i) {
                        t = 0;
                        for (var n = i.length; t < n; t++) e.setFromBufferAttribute(i[t]), this.boundingBox.expandByPoint(e.min), this.boundingBox.expandByPoint(e.max)
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function() {
            var e = new d,
                t = new d,
                i = new r;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new p);
                var n = this.attributes.position,
                    r = this.morphAttributes.position;
                if (n) {
                    var o = this.boundingSphere.center;
                    if (e.setFromBufferAttribute(n), r)
                        for (var a = 0, s = r.length; a < s; a++) {
                            var l = r[a];
                            t.setFromBufferAttribute(l), e.expandByPoint(t.min), e.expandByPoint(t.max)
                        }
                    e.getCenter(o);
                    var c = 0;
                    for (a = 0, s = n.count; a < s; a++) i.fromBufferAttribute(n, a), c = Math.max(c, o.distanceToSquared(i));
                    if (r)
                        for (a = 0, s = r.length; a < s; a++) {
                            n = 0;
                            for (var h = (l = r[a]).count; n < h; n++) i.fromBufferAttribute(l, n), c = Math.max(c, o.distanceToSquared(i))
                        }
                    this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index,
                t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3));
                else
                    for (var n = t.normal.array, o = 0, a = n.length; o < a; o++) n[o] = 0;
                n = t.normal.array;
                var s = new r,
                    l = new r,
                    c = new r,
                    h = new r,
                    u = new r;
                if (e) {
                    var d = e.array;
                    for (o = 0, a = e.count; o < a; o += 3) {
                        e = 3 * d[o + 0];
                        var p = 3 * d[o + 1],
                            f = 3 * d[o + 2];
                        s.fromArray(i, e), l.fromArray(i, p), c.fromArray(i, f), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[e] += h.x, n[e + 1] += h.y, n[e + 2] += h.z, n[p] += h.x, n[p + 1] += h.y, n[p + 2] += h.z, n[f] += h.x, n[f + 1] += h.y, n[f + 2] += h.z
                    }
                } else
                    for (o = 0, a = i.length; o < a; o += 9) s.fromArray(i, o), l.fromArray(i, o + 3), c.fromArray(i, o + 6), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[o] = h.x, n[o + 1] = h.y, n[o + 2] = h.z, n[o + 3] = h.x, n[o + 4] = h.y, n[o + 5] = h.z, n[o + 6] = h.x, n[o + 7] = h.y, n[o + 8] = h.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== e.attributes[i]) {
                        var r = n[i].array,
                            o = e.attributes[i],
                            a = o.array,
                            s = o.itemSize * t;
                        o = Math.min(a.length, r.length - s);
                        for (var l = 0; l < o; l++, s++) r[s] = a[l]
                    } return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            var e = new r;
            return function() {
                for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.normalize(), t.setXYZ(i, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function() {
            function e(e, t) {
                var i = e.array;
                e = e.itemSize;
                for (var n, r = new i.constructor(t.length * e), o = 0, a = 0, s = t.length; a < s; a++) {
                    n = t[a] * e;
                    for (var l = 0; l < e; l++) r[o++] = i[n++]
                }
                return new A(r, e)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t, i = new k,
                n = this.index.array,
                r = this.attributes;
            for (t in r) {
                var o = r[t];
                o = e(o, n), i.addAttribute(t, o)
            }
            var a = this.morphAttributes;
            for (t in a) {
                var s = [],
                    l = a[t];
                r = 0;
                for (var c = l.length; r < c; r++) o = e(o = l[r], n), s.push(o);
                i.morphAttributes[t] = s
            }
            for (r = 0, t = (n = this.groups).length; r < t; r++) o = n[r], i.addGroup(o.start, o.count, o.materialIndex);
            return i
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (c in t) void 0 !== t[c] && (e[c] = t[c]);
                return e
            }
            e.data = {
                attributes: {}
            }, null !== (t = this.index) && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            var i = this.attributes;
            for (c in i) {
                var n = (t = i[c]).toJSON();
                "" !== t.name && (n.name = t.name), e.data.attributes[c] = n
            }
            i = {};
            var r = !1;
            for (c in this.morphAttributes) {
                for (var o = this.morphAttributes[c], a = [], s = 0, l = o.length; s < l; s++) n = (t = o[s]).toJSON(), "" !== t.name && (n.name = t.name), a.push(n);
                0 < a.length && (i[c] = a, r = !0)
            }
            r && (e.data.morphAttributes = i);
            var c = this.groups;
            return 0 < c.length && (e.data.groups = JSON.parse(JSON.stringify(c))), null !== (c = this.boundingSphere) && (e.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }), e
        },
        clone: function() {
            return (new k).copy(this)
        },
        copy: function(e) {
            var t;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var i = e.index;
            for (a in null !== i && this.setIndex(i.clone()), i = e.attributes) this.addAttribute(a, i[a].clone());
            var n = e.morphAttributes;
            for (a in n) {
                var r = [],
                    o = n[a];
                for (i = 0, t = o.length; i < t; i++) r.push(o[i].clone());
                this.morphAttributes[a] = r
            }
            var a = e.groups;
            for (i = 0, t = a.length; i < t; i++) n = a[i], this.addGroup(n.start, n.count, n.materialIndex);
            return null !== (a = e.boundingBox) && (this.boundingBox = a.clone()), null !== (a = e.boundingSphere) && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), U.prototype = Object.create(S.prototype), U.prototype.constructor = U, H.prototype = Object.create(k.prototype), H.prototype.constructor = H, G.prototype = Object.create(S.prototype), G.prototype.constructor = G, j.prototype = Object.create(k.prototype), j.prototype.constructor = j;
    var Mo = 0;
    V.prototype = Object.assign(Object.create(t.prototype), {
        constructor: V,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else if ("shading" === t) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                    else {
                        var n = this[t];
                        void 0 === n ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
                    }
                }
        },
        toJSON: function(e) {
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var i = void 0 === e || "string" == typeof e;
            i && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = t(e.textures), e = t(e.images), 0 < i.length && (n.textures = i), 0 < e.length && (n.images = e)), n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes,
                i = null;
            if (null !== t) {
                var n = t.length;
                i = Array(n);
                for (var r = 0; r !== n; ++r) i[r] = t[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = v(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, W.prototype.toJSON = function(e) {
        var t = V.prototype.toJSON.call(this, e);
        for (var i in t.uniforms = {}, this.uniforms) {
            var n = this.uniforms[i].value;
            t.uniforms[i] = n && n.isTexture ? {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? {
                type: "m4",
                value: n.toArray()
            } : {
                value: n
            }
        }
        for (var r in 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, this.extensions) !0 === this.extensions[r] && (e[r] = !0);
        return 0 < Object.keys(e).length && (t.extensions = e), t
    }, Object.assign(q.prototype, {
        set: function(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new r), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function() {
            var e = new r;
            return function(t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new r), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new r;
            return function(t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, r, o, a) {
                e.copy(n).add(r).multiplyScalar(.5), t.copy(r).sub(n).normalize(), i.copy(this.origin).sub(e);
                var s = .5 * n.distanceTo(r),
                    l = -this.direction.dot(t),
                    c = i.dot(this.direction),
                    h = -i.dot(t),
                    u = i.lengthSq(),
                    d = Math.abs(1 - l * l);
                if (0 < d) {
                    r = l * c - h;
                    var p = s * d;
                    0 <= (n = l * h - c) ? r >= -p ? r <= p ? l = (n *= s = 1 / d) * (n + l * (r *= s) + 2 * c) + r * (l * n + r + 2 * h) + u : (r = s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : (r = -s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : r <= -p ? l = -(n = Math.max(0, -(-l * s + c))) * n + (r = 0 < n ? -s : Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u : r <= p ? (n = 0, l = (r = Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u) : l = -(n = Math.max(0, -(l * s + c))) * n + (r = 0 < n ? s : Math.min(Math.max(-s, -h), s)) * (r + 2 * h) + u
                } else r = 0 < l ? -s : s, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u;
                return o && o.copy(this.direction).multiplyScalar(n).add(this.origin), a && a.copy(t).multiplyScalar(r).add(e), l
            }
        }(),
        intersectSphere: function() {
            var e = new r;
            return function(t, i) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction),
                    r = e.dot(e) - n * n;
                return r > (t = t.radius * t.radius) ? null : (r = n - (t = Math.sqrt(t - r)), n += t, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
        },
        intersectPlane: function(e, t) {
            return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || 0 > e.normal.dot(this.direction) * t
        },
        intersectBox: function(e, t) {
            var i = 1 / this.direction.x,
                n = 1 / this.direction.y,
                r = 1 / this.direction.z,
                o = this.origin;
            if (0 <= i) {
                var a = (e.min.x - o.x) * i;
                i *= e.max.x - o.x
            } else a = (e.max.x - o.x) * i, i *= e.min.x - o.x;
            if (0 <= n) {
                var s = (e.min.y - o.y) * n;
                n *= e.max.y - o.y
            } else s = (e.max.y - o.y) * n, n *= e.min.y - o.y;
            return a > n || s > i ? null : ((s > a || a != a) && (a = s), (n < i || i != i) && (i = n), 0 <= r ? (s = (e.min.z - o.z) * r, e = (e.max.z - o.z) * r) : (s = (e.max.z - o.z) * r, e = (e.min.z - o.z) * r), a > e || s > i ? null : ((s > a || a != a) && (a = s), (e < i || i != i) && (i = e), 0 > i ? null : this.at(0 <= a ? a : i, t)))
        },
        intersectsBox: function() {
            var e = new r;
            return function(t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function() {
            var e = new r,
                t = new r,
                i = new r,
                n = new r;
            return function(r, o, a, s, l) {
                if (t.subVectors(o, r), i.subVectors(a, r), n.crossVectors(t, i), 0 < (o = this.direction.dot(n))) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > o)) return null;
                    s = -1, o = -o
                }
                return e.subVectors(this.origin, r), 0 > (r = s * this.direction.dot(i.crossVectors(e, i))) || 0 > (a = s * this.direction.dot(t.cross(e))) || r + a > o || 0 > (r = -s * e.dot(n)) ? null : this.at(r / o, l)
            }
        }(),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), Object.assign(X, {
        getNormal: function() {
            var e = new r;
            return function(t, i, n, o) {
                return void 0 === o && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new r), o.subVectors(n, i), e.subVectors(t, i), o.cross(e), 0 < (t = o.lengthSq()) ? o.multiplyScalar(1 / Math.sqrt(t)) : o.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var e = new r,
                t = new r,
                i = new r;
            return function(n, o, a, s, l) {
                e.subVectors(s, o), t.subVectors(a, o), i.subVectors(n, o), n = e.dot(e), o = e.dot(t), a = e.dot(i);
                var c = t.dot(t);
                s = t.dot(i);
                var h = n * c - o * o;
                return void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new r), 0 === h ? l.set(-2, -1, -1) : (c = (c * a - o * s) * (h = 1 / h), n = (n * s - o * a) * h, l.set(1 - c - n, n, c))
            }
        }(),
        containsPoint: function() {
            var e = new r;
            return function(t, i, n, r) {
                return X.getBarycoord(t, i, n, r, e), 0 <= e.x && 0 <= e.y && 1 >= e.x + e.y
            }
        }(),
        getUV: function() {
            var e = new r;
            return function(t, i, n, r, o, a, s, l) {
                return this.getBarycoord(t, i, n, r, e), l.set(0, 0), l.addScaledVector(o, e.x), l.addScaledVector(a, e.y), l.addScaledVector(s, e.z), l
            }
        }(),
        isFrontFacing: function() {
            var e = new r,
                t = new r;
            return function(i, n, r, o) {
                return e.subVectors(r, n), t.subVectors(i, n), 0 > e.cross(t).dot(o)
            }
        }()
    }), Object.assign(X.prototype, {
        set: function(e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function(e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: function() {
            var e = new r,
                t = new r;
            return function() {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new r), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return X.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new r), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return X.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function(e, t, i, n, r) {
            return X.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        containsPoint: function(e) {
            return X.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function(e) {
            return X.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var e = new r,
                t = new r,
                i = new r,
                n = new r,
                o = new r,
                a = new r;
            return function(s, l) {
                void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new r);
                var c = this.a,
                    h = this.b,
                    u = this.c;
                e.subVectors(h, c), t.subVectors(u, c), n.subVectors(s, c);
                var d = e.dot(n),
                    p = t.dot(n);
                if (0 >= d && 0 >= p) return l.copy(c);
                o.subVectors(s, h);
                var f = e.dot(o),
                    m = t.dot(o);
                if (0 <= f && m <= f) return l.copy(h);
                var g = d * m - f * p;
                if (0 >= g && 0 <= d && 0 >= f) return h = d / (d - f), l.copy(c).addScaledVector(e, h);
                a.subVectors(s, u), s = e.dot(a);
                var v = t.dot(a);
                return 0 <= v && s <= v ? l.copy(u) : 0 >= (d = s * p - d * v) && 0 <= p && 0 >= v ? (g = p / (p - v), l.copy(c).addScaledVector(t, g)) : 0 >= (p = f * v - s * m) && 0 <= m - f && 0 <= s - v ? (i.subVectors(u, h), g = (m - f) / (m - f + (s - v)), l.copy(h).addScaledVector(i, g)) : (h = d * (u = 1 / (p + d + g)), g *= u, l.copy(c).addScaledVector(e, h).addScaledVector(t, g))
            }
        }(),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Z.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Z,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return T.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
        },
        updateMorphTargets: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                e = e.morphAttributes;
                var t = Object.keys(e);
                if (0 < t.length) {
                    var i = e[t[0]];
                    if (void 0 !== i)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = i.length; e < t; e++) {
                            var n = i[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                }
            } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        raycast: function() {
            function e(e, t, i, n, r, o, a, s) {
                return null === (1 === t.side ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, 2 !== t.side, s)) ? null : (E.copy(s), E.applyMatrix4(e.matrixWorld), (t = i.ray.origin.distanceTo(E)) < i.near || t > i.far ? null : {
                    distance: t,
                    point: E.clone(),
                    object: e
                })
            }

            function t(t, n, r, o, a, p, g, E, M, T) {
                if (s.fromBufferAttribute(a, E), l.fromBufferAttribute(a, M), c.fromBufferAttribute(a, T), a = t.morphTargetInfluences, n.morphTargets && p && a) {
                    f.set(0, 0, 0), m.set(0, 0, 0), v.set(0, 0, 0);
                    for (var S = 0, A = p.length; S < A; S++) {
                        var C = a[S],
                            L = p[S];
                        0 !== C && (h.fromBufferAttribute(L, E), u.fromBufferAttribute(L, M), d.fromBufferAttribute(L, T), f.addScaledVector(h.sub(s), C), m.addScaledVector(u.sub(l), C), v.addScaledVector(d.sub(c), C))
                    }
                    s.add(f), l.add(m), c.add(v)
                }
                return (t = e(t, n, r, o, s, l, c, w)) && (g && (y.fromBufferAttribute(g, E), b.fromBufferAttribute(g, M), x.fromBufferAttribute(g, T), t.uv = X.getUV(w, s, l, c, y, b, x, new i)), g = new _(E, M, T), X.getNormal(s, l, c, g.normal), t.face = g), t
            }
            var n = new g,
                o = new q,
                a = new p,
                s = new r,
                l = new r,
                c = new r,
                h = new r,
                u = new r,
                d = new r,
                f = new r,
                m = new r,
                v = new r,
                y = new i,
                b = new i,
                x = new i,
                w = new r,
                E = new r;
            return function(r, s) {
                var l = this.geometry,
                    c = this.material,
                    h = this.matrixWorld;
                if (void 0 !== c && (null === l.boundingSphere && l.computeBoundingSphere(), a.copy(l.boundingSphere), a.applyMatrix4(h), !1 !== r.ray.intersectsSphere(a) && (n.getInverse(h), o.copy(r.ray).applyMatrix4(n), null === l.boundingBox || !1 !== o.intersectsBox(l.boundingBox))))
                    if (l.isBufferGeometry) {
                        var u = l.index;
                        h = l.attributes.position;
                        var d, p, f = l.morphAttributes.position,
                            m = l.attributes.uv,
                            g = l.groups,
                            v = l.drawRange;
                        if (null !== u)
                            if (Array.isArray(c)) {
                                var _ = 0;
                                for (d = g.length; _ < d; _++) {
                                    var E = g[_],
                                        M = c[E.materialIndex],
                                        T = Math.max(E.start, v.start);
                                    for (p = l = Math.min(E.start + E.count, v.start + v.count); T < p; T += 3) {
                                        l = u.getX(T);
                                        var S = u.getX(T + 1),
                                            A = u.getX(T + 2);
                                        (l = t(this, M, r, o, h, f, m, l, S, A)) && (l.faceIndex = Math.floor(T / 3), l.face.materialIndex = E.materialIndex, s.push(l))
                                    }
                                }
                            } else
                                for (_ = T = Math.max(0, v.start), d = l = Math.min(u.count, v.start + v.count); _ < d; _ += 3) l = u.getX(_), S = u.getX(_ + 1), A = u.getX(_ + 2), (l = t(this, c, r, o, h, f, m, l, S, A)) && (l.faceIndex = Math.floor(_ / 3), s.push(l));
                        else if (void 0 !== h)
                            if (Array.isArray(c))
                                for (_ = 0, d = g.length; _ < d; _++)
                                    for (M = c[(E = g[_]).materialIndex], T = Math.max(E.start, v.start), p = l = Math.min(E.start + E.count, v.start + v.count); T < p; T += 3)(l = t(this, M, r, o, h, f, m, l = T, S = T + 1, A = T + 2)) && (l.faceIndex = Math.floor(T / 3), l.face.materialIndex = E.materialIndex, s.push(l));
                            else
                                for (_ = T = Math.max(0, v.start), d = l = Math.min(h.count, v.start + v.count); _ < d; _ += 3)(l = t(this, c, r, o, h, f, m, l = _, S = _ + 1, A = _ + 2)) && (l.faceIndex = Math.floor(_ / 3), s.push(l))
                    } else if (l.isGeometry)
                    for (h = Array.isArray(c), f = l.vertices, m = l.faces, 0 < (l = l.faceVertexUvs[0]).length && (u = l), d = 0, E = m.length; d < E; d++) M = m[d], void 0 !== (l = h ? c[M.materialIndex] : c) && (g = f[M.a], v = f[M.b], _ = f[M.c], l = e(this, l, r, o, g, v, _, w)) && (u && u[d] && (T = u[d], y.copy(T[0]), b.copy(T[1]), x.copy(T[2]), l.uv = X.getUV(w, g, v, _, y, b, x, new i)), l.face = M, l.faceIndex = d, s.push(l))
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), se.prototype = Object.create(a.prototype), se.prototype.constructor = se, se.prototype.isCubeTexture = !0, Object.defineProperty(se.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }), le.prototype = Object.create(a.prototype), le.prototype.constructor = le, le.prototype.isDataTexture2DArray = !0, ce.prototype = Object.create(a.prototype), ce.prototype.constructor = ce, ce.prototype.isDataTexture3D = !0;
    var To = new a,
        So = new le,
        Ao = new ce,
        Co = new se,
        Lo = [],
        Do = [],
        Po = new Float32Array(16),
        Ro = new Float32Array(9),
        Oo = new Float32Array(4);
    je.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), de(t, e)
    }, Ve.prototype.setValue = function(e, t, i) {
        for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
            var a = n[r];
            a.setValue(e, t[a.id], i)
        }
    };
    var Io = /([\w\d_]+)(\])?(\[|\.)?/g;
    We.prototype.setValue = function(e, t, i, n) {
        void 0 !== (t = this.map[t]) && t.setValue(e, i, n)
    }, We.prototype.setOptional = function(e, t, i) {
        void 0 !== (t = t[i]) && this.setValue(e, i, t)
    }, We.upload = function(e, t, i, n) {
        for (var r = 0, o = t.length; r !== o; ++r) {
            var a = t[r],
                s = i[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, n)
        }
    }, We.seqWithValue = function(e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var o = e[n];
            o.id in t && i.push(o)
        }
        return i
    };
    var zo = 0,
        No = 0;
    pt.prototype = Object.create(V.prototype), pt.prototype.constructor = pt, pt.prototype.isMeshDepthMaterial = !0, pt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ft.prototype = Object.create(V.prototype), ft.prototype.constructor = ft, ft.prototype.isMeshDistanceMaterial = !0, ft.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }, bt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: bt,
        isGroup: !0
    }), xt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: xt,
        isCamera: !0,
        copy: function(e, t) {
            return T.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            T.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), wt.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: wt,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return xt.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function(e) {
            e = .5 * this.getFilmHeight() / e, this.fov = 2 * uo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * uo.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * uo.RAD2DEG * Math.atan(Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, i, n, r, o) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near,
                t = e * Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom,
                i = 2 * t,
                n = this.aspect * i,
                r = -.5 * n,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                r += o.offsetX * n / a, t -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
            }
            0 !== (o = this.filmOffset) && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), _t.prototype = Object.assign(Object.create(wt.prototype), {
        constructor: _t,
        isArrayCamera: !0
    });
    var Bo, Fo = new r,
        ko = new r;
    Object.assign(At.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new At(this.color, this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(Ct.prototype, {
        isFog: !0,
        clone: function() {
            return new Ct(this.color, this.near, this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Lt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Lt,
        isScene: !0,
        copy: function(e, t) {
            return T.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function(e) {
            var t = T.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(Dt.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(Dt.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
        },
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, i) {
            e *= this.stride, i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        }
    }), Object.defineProperties(Pt.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(Pt.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
        },
        setXYZ: function(e, t, i, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
        },
        setXYZW: function(e, t, i, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
        }
    }), Rt.prototype = Object.create(V.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isSpriteMaterial = !0, Rt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    }, Ot.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Ot,
        isSprite: !0,
        raycast: function() {
            function e(e, t, i, n, r, o) {
                a.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = o * a.x - r * a.y, s.y = r * a.x + o * a.y) : s.copy(a), e.copy(t), e.x += s.x, e.y += s.y, e.applyMatrix4(l)
            }
            var t = new r,
                n = new r,
                o = new r,
                a = new i,
                s = new i,
                l = new g,
                c = new r,
                h = new r,
                u = new r,
                d = new i,
                p = new i,
                f = new i;
            return function(r, a) {
                n.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                var s = this.material.rotation;
                if (0 !== s) var m = Math.cos(s),
                    g = Math.sin(s);
                s = this.center, e(c.set(-.5, -.5, 0), o, s, n, g, m), e(h.set(.5, -.5, 0), o, s, n, g, m), e(u.set(.5, .5, 0), o, s, n, g, m), d.set(0, 0), p.set(1, 0), f.set(1, 1);
                var v = r.ray.intersectTriangle(c, h, u, !1, t);
                null === v && (e(h.set(-.5, .5, 0), o, s, n, g, m), p.set(0, 1), null === (v = r.ray.intersectTriangle(c, u, h, !1, t))) || (g = r.ray.origin.distanceTo(t)) < r.near || g > r.far || a.push({
                    distance: g,
                    point: t.clone(),
                    uv: X.getUV(t, c, h, u, d, p, f, new i),
                    face: null,
                    object: this
                })
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return T.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    }), It.prototype = Object.assign(Object.create(T.prototype), {
        constructor: It,
        isLOD: !0,
        copy: function(e) {
            T.prototype.copy.call(this, e, !1);
            for (var t = 0, i = (e = e.levels).length; t < i; t++) {
                var n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
            return i.splice(n, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++);
            return t[i - 1].object
        },
        raycast: function() {
            var e = new r;
            return function(t, i) {
                e.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(n).raycast(t, i)
            }
        }(),
        update: function() {
            var e = new r,
                t = new r;
            return function(i) {
                var n = this.levels;
                if (1 < n.length) {
                    e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), n[0].object.visible = !0;
                    for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                    for (; r < o; r++) n[r].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            (e = T.prototype.toJSON.call(this, e)).object.levels = [];
            for (var t = this.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return e
        }
    }), zt.prototype = Object.assign(Object.create(Z.prototype), {
        constructor: zt,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new s, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
                e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
                var r = 1 / e.manhattanLength();
                1 / 0 !== r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Object.assign(Nt.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new g;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function() {
            var e, t, i = 0;
            for (t = this.bones.length; i < t; i++)(e = this.bones[i]) && e.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, t = this.bones.length; i < t; i++)(e = this.bones[i]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            var e = new g,
                t = new g;
            return function() {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) e.multiplyMatrices(i[a] ? i[a].matrixWorld : t, n[a]), e.toArray(r, 16 * a);
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new Nt(this.bones, this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e) return n
            }
        }
    }), Bt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Bt,
        isBone: !0
    }), Ft.prototype = Object.create(V.prototype), Ft.prototype.constructor = Ft, Ft.prototype.isLineBasicMaterial = !0, Ft.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, kt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: kt,
        isLine: !0,
        computeLineDistances: function() {
            var e = new r,
                t = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [0], o = 1, a = n.count; o < a; o++) e.fromBufferAttribute(n, o - 1), t.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += e.distanceTo(t);
                        i.addAttribute("lineDistance", new z(r, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, (r = i.lineDistances)[0] = 0, o = 1, a = n.length; o < a; o++) r[o] = r[o - 1], r[o] += n[o - 1].distanceTo(n[o]);
                return this
            }
        }(),
        raycast: function() {
            var e = new g,
                t = new q,
                i = new p;
            return function(n, o) {
                var a = n.linePrecision,
                    s = this.geometry,
                    l = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(l), i.radius += a, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(l), t.copy(n.ray).applyMatrix4(e), a /= (this.scale.x + this.scale.y + this.scale.z) / 3, a *= a;
                    var c = new r,
                        h = new r;
                    l = new r;
                    var u = new r,
                        d = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var p = s.index,
                            f = s.attributes.position.array;
                        if (null !== p) {
                            s = 0;
                            for (var m = (p = p.array).length - 1; s < m; s += d) {
                                var g = p[s + 1];
                                c.fromArray(f, 3 * p[s]), h.fromArray(f, 3 * g), (g = t.distanceSqToSegment(c, h, u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                                    distance: g,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (s = 0, m = f.length / 3 - 1; s < m; s += d) c.fromArray(f, 3 * s), h.fromArray(f, 3 * s + 3), (g = t.distanceSqToSegment(c, h, u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                                distance: g,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (s.isGeometry)
                        for (h = (c = s.vertices).length, s = 0; s < h - 1; s += d)(g = t.distanceSqToSegment(c[s], c[s + 1], u, l)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
                            distance: g,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: s,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ut.prototype = Object.assign(Object.create(kt.prototype), {
        constructor: Ut,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = new r,
                t = new r;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2) e.fromBufferAttribute(n, o), t.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                        i.addAttribute("lineDistance", new z(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, r = i.lineDistances, o = 0, a = n.length; o < a; o += 2) e.copy(n[o]), t.copy(n[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                return this
            }
        }()
    }), Ht.prototype = Object.assign(Object.create(kt.prototype), {
        constructor: Ht,
        isLineLoop: !0
    }), Gt.prototype = Object.create(V.prototype), Gt.prototype.constructor = Gt, Gt.prototype.isPointsMaterial = !0, Gt.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    }, jt.prototype = Object.assign(Object.create(T.prototype), {
        constructor: jt,
        isPoints: !0,
        raycast: function() {
            var e = new g,
                t = new q,
                i = new p;
            return function(n, o) {
                function a(e, i) {
                    var r = t.distanceSqToPoint(e);
                    r < u && (t.closestPointToPoint(e, d), d.applyMatrix4(c), (e = n.ray.origin.distanceTo(d)) < n.near || e > n.far || o.push({
                        distance: e,
                        distanceToRay: Math.sqrt(r),
                        point: d.clone(),
                        index: i,
                        face: null,
                        object: s
                    }))
                }
                var s = this,
                    l = this.geometry,
                    c = this.matrixWorld,
                    h = n.params.Points.threshold;
                if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
                    var u = (h /= (this.scale.x + this.scale.y + this.scale.z) / 3) * h;
                    h = new r;
                    var d = new r;
                    if (l.isBufferGeometry) {
                        var p = l.index;
                        if (l = l.attributes.position.array, null !== p) {
                            var f = p.array;
                            p = 0;
                            for (var m = f.length; p < m; p++) {
                                var g = f[p];
                                h.fromArray(l, 3 * g), a(h, g)
                            }
                        } else
                            for (p = 0, f = l.length / 3; p < f; p++) h.fromArray(l, 3 * p), a(h, p)
                    } else
                        for (p = 0, f = (h = l.vertices).length; p < f; p++) a(h[p], p)
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Vt.prototype = Object.assign(Object.create(a.prototype), {
        constructor: Vt,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), Wt.prototype = Object.create(a.prototype), Wt.prototype.constructor = Wt, Wt.prototype.isCompressedTexture = !0, qt.prototype = Object.create(a.prototype), qt.prototype.constructor = qt, qt.prototype.isCanvasTexture = !0, Xt.prototype = Object.create(a.prototype), Xt.prototype.constructor = Xt, Xt.prototype.isDepthTexture = !0, Yt.prototype = Object.create(k.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(S.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(k.prototype), Jt.prototype.constructor = Jt, Qt.prototype = Object.create(S.prototype), Qt.prototype.constructor = Qt, $t.prototype = Object.create(k.prototype), $t.prototype.constructor = $t, Kt.prototype = Object.create(S.prototype), Kt.prototype.constructor = Kt, ei.prototype = Object.create($t.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(S.prototype), ti.prototype.constructor = ti, ii.prototype = Object.create($t.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(S.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create($t.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(S.prototype), oi.prototype.constructor = oi, ai.prototype = Object.create($t.prototype), ai.prototype.constructor = ai, si.prototype = Object.create(S.prototype), si.prototype.constructor = si, li.prototype = Object.create(k.prototype), li.prototype.constructor = li, li.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(), e
    }, ci.prototype = Object.create(S.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(k.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(S.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(k.prototype), di.prototype.constructor = di;
    var Uo = {
        area: function(e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        },
        isClockWise: function(e) {
            return 0 > Uo.area(e)
        },
        triangulateShape: function(e, t) {
            var i = [],
                n = [],
                r = [];
            Ci(e), Li(i, e);
            var o = e.length;
            for (t.forEach(Ci), e = 0; e < t.length; e++) n.push(o), o += t[e].length, Li(i, t[e]);
            for (t = function(e, t, i) {
                    i = i || 2;
                    var n, r = t && t.length,
                        o = r ? t[0] * i : e.length,
                        a = pi(e, 0, o, i, !0),
                        s = [];
                    if (!a) return s;
                    if (r) {
                        var l, c = i;
                        r = [];
                        var h = 0;
                        for (l = t.length; h < l; h++) {
                            var u = t[h] * c;
                            (u = pi(e, u, h < l - 1 ? t[h + 1] * c : e.length, c, !1)) === u.next && (u.steiner = !0), r.push(yi(u))
                        }
                        for (r.sort(mi), h = 0; h < r.length; h++)(c = gi(t = r[h], c = a)) && fi(t = Mi(c, t), t.next), a = fi(a, a.next)
                    }
                    if (e.length > 80 * i) {
                        var d = n = e[0],
                            p = r = e[1];
                        for (c = i; c < o; c += i)(h = e[c]) < d && (d = h), (t = e[c + 1]) < p && (p = t), h > n && (n = h), t > r && (r = t);
                        n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0
                    }
                    return function e(t, i, n, r, o, a, s) {
                        if (t) {
                            if (!s && a) {
                                var l = t,
                                    c = l;
                                do {
                                    null === c.z && (c.z = vi(c.x, c.y, r, o, a)), c.prevZ = c.prev, c = c.nextZ = c.next
                                } while (c !== l);
                                c.prevZ.nextZ = null, c.prevZ = null, l = c;
                                var h, u, d, p, f = 1;
                                do {
                                    c = l;
                                    var m = l = null;
                                    for (u = 0; c;) {
                                        u++;
                                        var g = c;
                                        for (h = d = 0; h < f && (d++, g = g.nextZ); h++);
                                        for (p = f; 0 < d || 0 < p && g;) 0 !== d && (0 === p || !g || c.z <= g.z) ? (h = c, c = c.nextZ, d--) : (h = g, g = g.nextZ, p--), m ? m.nextZ = h : l = h, h.prevZ = m, m = h;
                                        c = g
                                    }
                                    m.nextZ = null, f *= 2
                                } while (1 < u)
                            }
                            for (l = t; t.prev !== t.next;) {
                                if (c = t.prev, g = t.next, a) e: {
                                    p = r;
                                    var v = o,
                                        y = a;
                                    if (0 <= xi(u = (m = t).prev, d = m, f = m.next)) m = !1;
                                    else {
                                        var b = u.x > d.x ? u.x > f.x ? u.x : f.x : d.x > f.x ? d.x : f.x,
                                            x = u.y > d.y ? u.y > f.y ? u.y : f.y : d.y > f.y ? d.y : f.y;
                                        for (h = vi(u.x < d.x ? u.x < f.x ? u.x : f.x : d.x < f.x ? d.x : f.x, u.y < d.y ? u.y < f.y ? u.y : f.y : d.y < f.y ? d.y : f.y, p, v, y), p = vi(b, x, p, v, y), v = m.nextZ; v && v.z <= p;) {
                                            if (v !== m.prev && v !== m.next && bi(u.x, u.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= xi(v.prev, v, v.next)) {
                                                m = !1;
                                                break e
                                            }
                                            v = v.nextZ
                                        }
                                        for (v = m.prevZ; v && v.z >= h;) {
                                            if (v !== m.prev && v !== m.next && bi(u.x, u.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= xi(v.prev, v, v.next)) {
                                                m = !1;
                                                break e
                                            }
                                            v = v.prevZ
                                        }
                                        m = !0
                                    }
                                }
                                else e: if (m = t, u = m.prev, d = m, f = m.next, 0 <= xi(u, d, f)) m = !1;
                                    else {
                                        for (h = m.next.next; h !== m.prev;) {
                                            if (bi(u.x, u.y, d.x, d.y, f.x, f.y, h.x, h.y) && 0 <= xi(h.prev, h, h.next)) {
                                                m = !1;
                                                break e
                                            }
                                            h = h.next
                                        }
                                        m = !0
                                    } if (m) i.push(c.i / n), i.push(t.i / n), i.push(g.i / n), Si(t), l = t = g.next;
                                else if ((t = g) === l) {
                                    if (s) {
                                        if (1 === s) {
                                            s = i, l = n, c = t;
                                            do {
                                                !wi(g = c.prev, m = c.next.next) && _i(g, c, c.next, m) && Ei(g, m) && Ei(m, g) && (s.push(g.i / l), s.push(c.i / l), s.push(m.i / l), Si(c), Si(c.next), c = t = m), c = c.next
                                            } while (c !== t);
                                            e(t = c, i, n, r, o, a, 2)
                                        } else if (2 === s) e: {
                                            s = t;do {
                                                for (l = s.next.next; l !== s.prev;) {
                                                    if (c = s.i !== l.i) {
                                                        if (g = l, m = (c = s).next.i !== g.i && c.prev.i !== g.i) {
                                                            t: {
                                                                m = c;do {
                                                                    if (m.i !== c.i && m.next.i !== c.i && m.i !== g.i && m.next.i !== g.i && _i(m, m.next, c, g)) {
                                                                        m = !0;
                                                                        break t
                                                                    }
                                                                    m = m.next
                                                                } while (m !== c);m = !1
                                                            }
                                                            m = !m
                                                        }
                                                        if (m = m && Ei(c, g) && Ei(g, c)) {
                                                            m = c, u = !1, d = (c.x + g.x) / 2, g = (c.y + g.y) / 2;
                                                            do {
                                                                m.y > g != m.next.y > g && m.next.y !== m.y && d < (m.next.x - m.x) * (g - m.y) / (m.next.y - m.y) + m.x && (u = !u), m = m.next
                                                            } while (m !== c);
                                                            m = u
                                                        }
                                                        c = m
                                                    }
                                                    if (c) {
                                                        t = Mi(s, l), s = fi(s, s.next), t = fi(t, t.next), e(s, i, n, r, o, a), e(t, i, n, r, o, a);
                                                        break e
                                                    }
                                                    l = l.next
                                                }
                                                s = s.next
                                            } while (s !== t)
                                        }
                                    } else e(fi(t), i, n, r, o, a, 1);
                                    break
                                }
                            }
                        }
                    }(a, s, i, d, p, n), s
                }(i, n), e = 0; e < t.length; e += 3) r.push(t.slice(e, e + 3));
            return r
        }
    };
    Di.prototype = Object.create(S.prototype), Di.prototype.constructor = Di, Di.prototype.toJSON = function() {
        var e = S.prototype.toJSON.call(this);
        return Ri(this.parameters.shapes, this.parameters.options, e)
    }, Pi.prototype = Object.create(k.prototype), Pi.prototype.constructor = Pi, Pi.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return Ri(this.parameters.shapes, this.parameters.options, e)
    };
    var Ho = {
        generateTopUV: function(e, t, n, r, o) {
            e = t[3 * r], r = t[3 * r + 1];
            var a = t[3 * o];
            return o = t[3 * o + 1], [new i(t[3 * n], t[3 * n + 1]), new i(e, r), new i(a, o)]
        },
        generateSideWallUV: function(e, t, n, r, o, a) {
            e = t[3 * n];
            var s = t[3 * n + 1];
            n = t[3 * n + 2];
            var l = t[3 * r],
                c = t[3 * r + 1];
            r = t[3 * r + 2];
            var h = t[3 * o],
                u = t[3 * o + 1];
            o = t[3 * o + 2];
            var d = t[3 * a],
                p = t[3 * a + 1];
            return t = t[3 * a + 2], .01 > Math.abs(s - c) ? [new i(e, 1 - n), new i(l, 1 - r), new i(h, 1 - o), new i(d, 1 - t)] : [new i(s, 1 - n), new i(c, 1 - r), new i(u, 1 - o), new i(p, 1 - t)]
        }
    };
    Oi.prototype = Object.create(S.prototype), Oi.prototype.constructor = Oi, Ii.prototype = Object.create(Pi.prototype), Ii.prototype.constructor = Ii, zi.prototype = Object.create(S.prototype), zi.prototype.constructor = zi, Ni.prototype = Object.create(k.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(S.prototype), Bi.prototype.constructor = Bi, Fi.prototype = Object.create(k.prototype), Fi.prototype.constructor = Fi, ki.prototype = Object.create(S.prototype), ki.prototype.constructor = ki, Ui.prototype = Object.create(k.prototype), Ui.prototype.constructor = Ui, Hi.prototype = Object.create(S.prototype), Hi.prototype.constructor = Hi, Hi.prototype.toJSON = function() {
        var e = S.prototype.toJSON.call(this);
        return ji(this.parameters.shapes, e)
    }, Gi.prototype = Object.create(k.prototype), Gi.prototype.constructor = Gi, Gi.prototype.toJSON = function() {
        var e = k.prototype.toJSON.call(this);
        return ji(this.parameters.shapes, e)
    }, Vi.prototype = Object.create(k.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(S.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(k.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(Wi.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(qi.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(S.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(k.prototype), Ji.prototype.constructor = Ji;
    var Go = Object.freeze({
        WireframeGeometry: Yt,
        ParametricGeometry: Zt,
        ParametricBufferGeometry: Jt,
        TetrahedronGeometry: Kt,
        TetrahedronBufferGeometry: ei,
        OctahedronGeometry: ti,
        OctahedronBufferGeometry: ii,
        IcosahedronGeometry: ni,
        IcosahedronBufferGeometry: ri,
        DodecahedronGeometry: oi,
        DodecahedronBufferGeometry: ai,
        PolyhedronGeometry: Qt,
        PolyhedronBufferGeometry: $t,
        TubeGeometry: si,
        TubeBufferGeometry: li,
        TorusKnotGeometry: ci,
        TorusKnotBufferGeometry: hi,
        TorusGeometry: ui,
        TorusBufferGeometry: di,
        TextGeometry: Oi,
        TextBufferGeometry: Ii,
        SphereGeometry: zi,
        SphereBufferGeometry: Ni,
        RingGeometry: Bi,
        RingBufferGeometry: Fi,
        PlaneGeometry: G,
        PlaneBufferGeometry: j,
        LatheGeometry: ki,
        LatheBufferGeometry: Ui,
        ShapeGeometry: Hi,
        ShapeBufferGeometry: Gi,
        ExtrudeGeometry: Di,
        ExtrudeBufferGeometry: Pi,
        EdgesGeometry: Vi,
        ConeGeometry: Xi,
        ConeBufferGeometry: Yi,
        CylinderGeometry: Wi,
        CylinderBufferGeometry: qi,
        CircleGeometry: Zi,
        CircleBufferGeometry: Ji,
        BoxGeometry: U,
        BoxBufferGeometry: H
    });
    Qi.prototype = Object.create(V.prototype), Qi.prototype.constructor = Qi, Qi.prototype.isShadowMaterial = !0, Qi.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, $i.prototype = Object.create(W.prototype), $i.prototype.constructor = $i, $i.prototype.isRawShaderMaterial = !0, Ki.prototype = Object.create(V.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isMeshStandardMaterial = !0, Ki.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, en.prototype = Object.create(Ki.prototype), en.prototype.constructor = en, en.prototype.isMeshPhysicalMaterial = !0, en.prototype.copy = function(e) {
        return Ki.prototype.copy.call(this, e), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, tn.prototype = Object.create(V.prototype), tn.prototype.constructor = tn, tn.prototype.isMeshPhongMaterial = !0, tn.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, nn.prototype = Object.create(tn.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshToonMaterial = !0, nn.prototype.copy = function(e) {
        return tn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, rn.prototype = Object.create(V.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshNormalMaterial = !0, rn.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, on.prototype.isMeshLambertMaterial = !0, on.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, an.prototype = Object.create(V.prototype), an.prototype.constructor = an, an.prototype.isMeshMatcapMaterial = !0, an.prototype.copy = function(e) {
        return V.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, sn.prototype = Object.create(Ft.prototype), sn.prototype.constructor = sn, sn.prototype.isLineDashedMaterial = !0, sn.prototype.copy = function(e) {
        return Ft.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var jo = Object.freeze({
            ShadowMaterial: Qi,
            SpriteMaterial: Rt,
            RawShaderMaterial: $i,
            ShaderMaterial: W,
            PointsMaterial: Gt,
            MeshPhysicalMaterial: en,
            MeshStandardMaterial: Ki,
            MeshPhongMaterial: tn,
            MeshToonMaterial: nn,
            MeshNormalMaterial: rn,
            MeshLambertMaterial: on,
            MeshDepthMaterial: pt,
            MeshDistanceMaterial: ft,
            MeshBasicMaterial: Y,
            MeshMatcapMaterial: an,
            LineDashedMaterial: sn,
            LineBasicMaterial: Ft,
            Material: V
        }),
        Vo = {
            arraySlice: function(e, t, i) {
                return Vo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
            },
            convertArray: function(e, t, i) {
                return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function(e) {
                for (var t = e.length, i = Array(t), n = 0; n !== t; ++n) i[n] = n;
                return i.sort((function(t, i) {
                    return e[t] - e[i]
                })), i
            },
            sortedArray: function(e, t, i) {
                for (var n = e.length, r = new e.constructor(n), o = 0, a = 0; a !== n; ++o)
                    for (var s = i[o] * t, l = 0; l !== t; ++l) r[a++] = e[s + l];
                return r
            },
            flattenJSON: function(e, t, i, n) {
                for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[n];) o = e[r++];
                if (void 0 !== o) {
                    var a = o[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                void 0 !== (a = o[n]) && (t.push(o.time), i.push.apply(i, a)), o = e[r++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time), a.toArray(i, i.length)), o = e[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time), i.push(a)), o = e[r++]
                        } while (void 0 !== o)
                }
            }
        };
    Object.assign(ln.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions,
                i = this._cachedIndex,
                n = t[i],
                r = t[i - 1];
            e: {
                t: {
                    i: {
                        n: if (!(e < n)) {
                            for (var o = i + 2;;) {
                                if (void 0 === n) {
                                    if (e < r) break n;
                                    return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, e, r)
                                }
                                if (i === o) break;
                                if (r = n, e < (n = t[++i])) break t
                            }
                            n = t.length;
                            break i
                        }if (e >= r) break e;
                        for (e < (o = t[1]) && (i = 2, r = o), o = i - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (i === o) break;
                            if (n = r, e >= (r = t[--i - 1])) break t
                        }
                        n = i,
                        i = 0
                    }
                    for (; i < n;) e < t[r = i + n >>> 1] ? n = r : i = r + 1;
                    if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, e, n);
                    if (void 0 === n) return this._cachedIndex = i = t.length,
                    this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            var t = this.resultBuffer,
                i = this.sampleValues,
                n = this.valueSize;
            e *= n;
            for (var r = 0; r !== n; ++r) t[r] = i[e + r];
            return t
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }), Object.assign(ln.prototype, {
        beforeStart_: ln.prototype.copySampleValue_,
        afterEnd_: ln.prototype.copySampleValue_
    }), cn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: cn,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(e, t, i) {
            var n = this.parameterPositions,
                r = e - 2,
                o = e + 1,
                a = n[r],
                s = n[o];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e, a = 2 * t - i;
                    break;
                case 2402:
                    a = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e, a = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = e, s = 2 * i - t;
                    break;
                case 2402:
                    o = 1, s = i + n[1] - n[0];
                    break;
                default:
                    o = e - 1, s = t
            }
            e = .5 * (i - t), n = this.valueSize, this._weightPrev = e / (t - a), this._weightNext = e / (s - i), this._offsetPrev = r * n, this._offsetNext = o * n
        },
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                s = (e *= a) - a,
                l = this._offsetPrev,
                c = this._offsetNext,
                h = this._weightPrev,
                u = this._weightNext,
                d = (i - t) / (n - t);
            for (t = -h * (n = (i = d * d) * d) + 2 * h * i - h * d, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== a; ++i) r[i] = t * o[l + i] + h * o[s + i] + d * o[e + i] + u * o[c + i];
            return r
        }
    }), hn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: hn,
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                s = (e *= a) - a;
            for (i = 1 - (t = (i - t) / (n - t)), n = 0; n !== a; ++n) r[n] = o[s + n] * i + o[e + n] * t;
            return r
        }
    }), un.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: un,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }), Object.assign(dn, {
        toJSON: function(e) {
            var t = e.constructor;
            if (void 0 !== t.toJSON) t = t.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: Vo.convertArray(e.times, Array),
                    values: Vo.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName, t
        }
    }), Object.assign(dn.prototype, {
        constructor: dn,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new un(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new hn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new cn(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function(e) {
            switch (e) {
                case 2300:
                    var t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", t), this
            }
            return this.createInterpolant = t, this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
            return this
        },
        trim: function(e, t) {
            for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < e;) ++r;
            for (; - 1 !== o && i[o] > t;) --o;
            return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), e = this.getValueSize(), this.times = Vo.arraySlice(i, r, o), this.values = Vo.arraySlice(this.values, r * e, o * e)), this
        },
        validate: function() {
            var e = !0,
                t = this.getValueSize();
            0 != t - Math.floor(t) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var i = this.times;
            t = this.values;
            var n = i.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            for (var r = null, o = 0; o !== n; o++) {
                var a = i[o];
                if ("number" == typeof a && isNaN(a)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a), e = !1;
                    break
                }
                if (null !== r && r > a) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, r), e = !1;
                    break
                }
                r = a
            }
            if (void 0 !== t && Vo.isTypedArray(t))
                for (o = 0, i = t.length; o !== i; ++o)
                    if (n = t[o], isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), e = !1;
                        break
                    } return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = e.length - 1, a = 1; a < o; ++a) {
                var s = !1,
                    l = e[a];
                if (l !== e[a + 1] && (1 !== a || l !== l[0]))
                    if (n) s = !0;
                    else {
                        var c = a * i,
                            h = c - i,
                            u = c + i;
                        for (l = 0; l !== i; ++l) {
                            var d = t[c + l];
                            if (d !== t[h + l] || d !== t[u + l]) {
                                s = !0;
                                break
                            }
                        }
                    } if (s) {
                    if (a !== r)
                        for (e[r] = e[a], s = a * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[s + l];
                    ++r
                }
            }
            if (0 < o) {
                for (e[r] = e[o], s = o * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[s + l];
                ++r
            }
            return r !== e.length && (this.times = Vo.arraySlice(e, 0, r), this.values = Vo.arraySlice(t, 0, r * i)), this
        },
        clone: function() {
            var e = Vo.arraySlice(this.times, 0),
                t = Vo.arraySlice(this.values, 0);
            return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, e
        }
    }), pn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: pn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), fn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: fn,
        ValueTypeName: "color"
    }), mn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: mn,
        ValueTypeName: "number"
    }), gn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: gn,
        interpolate_: function(e, t, i, r) {
            var o = this.resultBuffer,
                a = this.sampleValues,
                s = this.valueSize;
            for (t = (i - t) / (r - t), i = (e *= s) + s; e !== i; e += 4) n.slerpFlat(o, 0, a, e - s, a, e, t);
            return o
        }
    }), vn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: vn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new gn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), yn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: yn,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), bn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: bn,
        ValueTypeName: "vector"
    }), Object.assign(xn, {
        parse: function(e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, o = i.length; r !== o; ++r) t.push(wn(i[r]).scale(n));
            return new xn(e.name, e.duration, t)
        },
        toJSON: function(e) {
            var t = [],
                i = e.tracks;
            e = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            };
            for (var n = 0, r = i.length; n !== r; ++n) t.push(dn.toJSON(i[n]));
            return e
        },
        CreateFromMorphTargetSequence: function(e, t, i, n) {
            for (var r = t.length, o = [], a = 0; a < r; a++) {
                var s = [],
                    l = [];
                s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                var c = Vo.getKeyframeOrder(s);
                s = Vo.sortedArray(s, 1, c), l = Vo.sortedArray(l, 1, c), n || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new mn(".morphTargetInfluences[" + t[a].name + "]", s, l).scale(1 / i))
            }
            return new xn(e, -1, o)
        },
        findByName: function(e, t) {
            var i = e;
            for (Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations), e = 0; e < i.length; e++)
                if (i[e].name === t) return i[e];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                var s = e[o],
                    l = s.name.match(r);
                if (l && 1 < l.length) {
                    var c = l[1];
                    (l = n[c]) || (n[c] = l = []), l.push(s)
                }
            }
            for (c in e = [], n) e.push(xn.CreateFromMorphTargetSequence(c, n[c], t, i));
            return e
        },
        parseAnimation: function(e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            var i = function(e, t, i, n, r) {
                    if (0 !== i.length) {
                        var o = [],
                            a = [];
                        Vo.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new e(t, o, a))
                    }
                },
                n = [],
                r = e.name || "default",
                o = e.length || -1,
                a = e.fps || 30;
            e = e.hierarchy || [];
            for (var s = 0; s < e.length; s++) {
                var l = e[s].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        o = {};
                        for (var c = 0; c < l.length; c++)
                            if (l[c].morphTargets)
                                for (var h = 0; h < l[c].morphTargets.length; h++) o[l[c].morphTargets[h]] = -1;
                        for (var u in o) {
                            var d = [],
                                p = [];
                            for (h = 0; h !== l[c].morphTargets.length; ++h) {
                                var f = l[c];
                                d.push(f.time), p.push(f.morphTarget === u ? 1 : 0)
                            }
                            n.push(new mn(".morphTargetInfluence[" + u + "]", d, p))
                        }
                        o = o.length * (a || 1)
                    } else i(bn, (c = ".bones[" + t[s].name + "]") + ".position", l, "pos", n), i(vn, c + ".quaternion", l, "rot", n), i(bn, c + ".scale", l, "scl", n)
            }
            return 0 === n.length ? null : new xn(r, o, n)
        }
    }), Object.assign(xn.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new xn(this.name, this.duration, e)
        }
    });
    var Wo = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        },
        qo = new _n,
        Xo = {};
    Object.assign(En.prototype, {
        load: function(e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = Wo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            if (void 0 === Xo[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    i = a[1];
                    var s = !!a[2];
                    a = a[3], a = decodeURIComponent(a), s && (a = atob(a));
                    try {
                        var l = (this.responseType || "").toLowerCase();
                        switch (l) {
                            case "arraybuffer":
                            case "blob":
                                var c = new Uint8Array(a.length);
                                for (s = 0; s < a.length; s++) c[s] = a.charCodeAt(s);
                                var h = "blob" === l ? new Blob([c.buffer], {
                                    type: i
                                }) : c.buffer;
                                break;
                            case "document":
                                h = (new DOMParser).parseFromString(a, i);
                                break;
                            case "json":
                                h = JSON.parse(a);
                                break;
                            default:
                                h = a
                        }
                        setTimeout((function() {
                            t && t(h), r.manager.itemEnd(e)
                        }), 0)
                    } catch (t) {
                        setTimeout((function() {
                            n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                        }), 0)
                    }
                } else {
                    Xo[e] = [], Xo[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    var u = new XMLHttpRequest;
                    for (s in u.open("GET", e, !0), u.addEventListener("load", (function(t) {
                            var i = this.response;
                            Wo.add(e, i);
                            var n = Xo[e];
                            if (delete Xo[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, a = n.length; o < a; o++) {
                                    var s = n[o];
                                    s.onLoad && s.onLoad(i)
                                }
                            } else {
                                for (o = 0, a = n.length; o < a; o++)(s = n[o]).onError && s.onError(t);
                                r.manager.itemError(e)
                            }
                            r.manager.itemEnd(e)
                        }), !1), u.addEventListener("progress", (function(t) {
                            for (var i = Xo[e], n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o.onProgress && o.onProgress(t)
                            }
                        }), !1), u.addEventListener("error", (function(t) {
                            var i = Xo[e];
                            delete Xo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), u.addEventListener("abort", (function(t) {
                            var i = Xo[e];
                            delete Xo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(s, this.requestHeader[s]);
                    u.send(null)
                }
                return r.manager.itemStart(e), u
            }
            Xo[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
            })
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResponseType: function(e) {
            return this.responseType = e, this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e, this
        },
        setMimeType: function(e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(Mn.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = xn.parse(e[i]);
                t.push(n)
            }
            return t
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Tn.prototype, {
        load: function(e, t, i, n) {
            function r(r) {
                l.load(e[r], (function(e) {
                    e = o._parser(e, !0), a[r] = {
                        width: e.width,
                        height: e.height,
                        format: e.format,
                        mipmaps: e.mipmaps
                    }, 6 === (c += 1) && (1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s))
                }), i, n)
            }
            var o = this,
                a = [],
                s = new Wt;
            s.image = a;
            var l = new En(this.manager);
            if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
                for (var c = 0, h = 0, u = e.length; h < u; ++h) r(h);
            else l.load(e, (function(e) {
                if ((e = o._parser(e, !0)).isCubemap)
                    for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                        a[n] = {
                            mipmaps: []
                        };
                        for (var r = 0; r < e.mipmapCount; r++) a[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), a[n].format = e.format, a[n].width = e.width, a[n].height = e.height
                    } else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s)
            }), i, n);
            return s
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Sn.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new u,
                a = new En(this.manager);
            return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(e, (function(e) {
                (e = r._parser(e)) && (void 0 !== e.image ? o.image = e.image : void 0 !== e.data && (o.image.width = e.width, o.image.height = e.height, o.image.data = e.data), o.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, o.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, o.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, o.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008, o.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (o.format = e.format), void 0 !== e.type && (o.type = e.type), void 0 !== e.mipmaps && (o.mipmaps = e.mipmaps), 1 === e.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, t && t(o, e))
            }), i, n), o
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(An.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            function r() {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), Wo.add(e, this), t && t(this), a.manager.itemEnd(e)
            }

            function o(t) {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), n && n(t), a.manager.itemError(e), a.manager.itemEnd(e)
            }
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var a = this,
                s = Wo.get(e);
            if (void 0 !== s) return a.manager.itemStart(e), setTimeout((function() {
                t && t(s), a.manager.itemEnd(e)
            }), 0), s;
            var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return l.addEventListener("load", r, !1), l.addEventListener("error", o, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Cn.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            function r(i) {
                a.load(e[i], (function(e) {
                    o.images[i] = e, 6 === ++s && (o.needsUpdate = !0, t && t(o))
                }), void 0, n)
            }
            var o = new se,
                a = new An(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var s = 0;
            for (i = 0; i < e.length; ++i) r(i);
            return o
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Ln.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = new a,
                o = new An(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(i) {
                r.image = i, i = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r)
            }), i, n), r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Dn.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(e, t) {
            return e = this.getUtoTmapping(e), this.getPoint(e, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i = [],
                n = this.getPoint(0),
                r = 0;
            for (i.push(0), t = 1; t <= e; t++) {
                var o = this.getPoint(t / e);
                r += o.distanceTo(n), i.push(r), n = o
            }
            return this.cacheArcLengths = i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var i = this.getLengths(),
                n = i.length;
            t = t || e * i[n - 1];
            for (var r, o = 0, a = n - 1; o <= a;)
                if (0 > (r = i[e = Math.floor(o + (a - o) / 2)] - t)) o = e + 1;
                else {
                    if (!(0 < r)) {
                        a = e;
                        break
                    }
                    a = e - 1
                } return i[e = a] === t ? e / (n - 1) : (e + (t - (o = i[e])) / (i[e + 1] - o)) / (n - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4;
            return 0 > t && (t = 0), 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
        },
        getTangentAt: function(e) {
            return e = this.getUtoTmapping(e), this.getTangent(e)
        },
        computeFrenetFrames: function(e, t) {
            var i, n = new r,
                o = [],
                a = [],
                s = [],
                l = new r,
                c = new g;
            for (i = 0; i <= e; i++) {
                var h = i / e;
                o[i] = this.getTangentAt(h), o[i].normalize()
            }
            a[0] = new r, s[0] = new r, i = Number.MAX_VALUE, h = Math.abs(o[0].x);
            var u = Math.abs(o[0].y),
                d = Math.abs(o[0].z);
            for (h <= i && (i = h, n.set(1, 0, 0)), u <= i && (i = u, n.set(0, 1, 0)), d <= i && n.set(0, 0, 1), l.crossVectors(o[0], n).normalize(), a[0].crossVectors(o[0], l), s[0].crossVectors(o[0], a[0]), i = 1; i <= e; i++) a[i] = a[i - 1].clone(), s[i] = s[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(uo.clamp(o[i - 1].dot(o[i]), -1, 1)), a[i].applyMatrix4(c.makeRotationAxis(l, n))), s[i].crossVectors(o[i], a[i]);
            if (!0 === t)
                for (n = Math.acos(uo.clamp(a[0].dot(a[e]), -1, 1)), n /= e, 0 < o[0].dot(l.crossVectors(a[0], a[e])) && (n = -n), i = 1; i <= e; i++) a[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), s[i].crossVectors(o[i], a[i]);
            return {
                tangents: o,
                normals: a,
                binormals: s
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), Pn.prototype = Object.create(Dn.prototype), Pn.prototype.constructor = Pn, Pn.prototype.isEllipseCurve = !0, Pn.prototype.getPoint = function(e, t) {
        t = t || new i;
        for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + e * r, e = this.aX + this.xRadius * Math.cos(n);
        var a = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), e = (o = e - this.aX) * n - (a -= this.aY) * r + this.aX, a = o * r + a * n + this.aY), t.set(e, a)
    }, Pn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, Pn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, Pn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, Rn.prototype = Object.create(Pn.prototype), Rn.prototype.constructor = Rn, Rn.prototype.isArcCurve = !0;
    var Yo = new r,
        Zo = new On,
        Jo = new On,
        Qo = new On;
    In.prototype = Object.create(Dn.prototype), In.prototype.constructor = In, In.prototype.isCatmullRomCurve3 = !0, In.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.points,
            n = i.length;
        e *= n - (this.closed ? 0 : 1);
        var o = Math.floor(e);
        if (e -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === e && o === n - 1 && (o = n - 2, e = 1), this.closed || 0 < o) var a = i[(o - 1) % n];
        else Yo.subVectors(i[0], i[1]).add(i[0]), a = Yo;
        var s = i[o % n],
            l = i[(o + 1) % n];
        if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Yo.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Yo), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var c = "chordal" === this.curveType ? .5 : .25;
            n = Math.pow(a.distanceToSquared(s), c), 1e-4 > (o = Math.pow(s.distanceToSquared(l), c)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (c = Math.pow(l.distanceToSquared(i), c)) && (c = o), Zo.initNonuniformCatmullRom(a.x, s.x, l.x, i.x, n, o, c), Jo.initNonuniformCatmullRom(a.y, s.y, l.y, i.y, n, o, c), Qo.initNonuniformCatmullRom(a.z, s.z, l.z, i.z, n, o, c)
        } else "catmullrom" === this.curveType && (Zo.initCatmullRom(a.x, s.x, l.x, i.x, this.tension), Jo.initCatmullRom(a.y, s.y, l.y, i.y, this.tension), Qo.initCatmullRom(a.z, s.z, l.z, i.z, this.tension));
        return t.set(Zo.calc(e), Jo.calc(e), Qo.calc(e)), t
    }, In.prototype.copy = function(e) {
        Dn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, In.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, In.prototype.fromJSON = function(e) {
        Dn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new r).fromArray(n))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, Fn.prototype = Object.create(Dn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isCubicBezierCurve = !0, Fn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return t.set(Bn(e, n.x, r.x, o.x, a.x), Bn(e, n.y, r.y, o.y, a.y)), t
    }, Fn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, Fn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, Fn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, kn.prototype = Object.create(Dn.prototype), kn.prototype.constructor = kn, kn.prototype.isCubicBezierCurve3 = !0, kn.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2,
            a = this.v3;
        return t.set(Bn(e, i.x, n.x, o.x, a.x), Bn(e, i.y, n.y, o.y, a.y), Bn(e, i.z, n.z, o.z, a.z)), t
    }, kn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, kn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, kn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, Un.prototype = Object.create(Dn.prototype), Un.prototype.constructor = Un, Un.prototype.isLineCurve = !0, Un.prototype.getPoint = function(e, t) {
        return t = t || new i, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Un.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, Un.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }, Un.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Un.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Un.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Hn.prototype = Object.create(Dn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isLineCurve3 = !0, Hn.prototype.getPoint = function(e, t) {
        return t = t || new r, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Hn.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, Hn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Hn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Hn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Gn.prototype = Object.create(Dn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isQuadraticBezierCurve = !0, Gn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2;
        return t.set(Nn(e, n.x, r.x, o.x), Nn(e, n.y, r.y, o.y)), t
    }, Gn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Gn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Gn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, jn.prototype = Object.create(Dn.prototype), jn.prototype.constructor = jn, jn.prototype.isQuadraticBezierCurve3 = !0, jn.prototype.getPoint = function(e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2;
        return t.set(Nn(e, i.x, n.x, o.x), Nn(e, i.y, n.y, o.y), Nn(e, i.z, n.z, o.z)), t
    }, jn.prototype.copy = function(e) {
        return Dn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, jn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, jn.prototype.fromJSON = function(e) {
        return Dn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Vn.prototype = Object.create(Dn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isSplineCurve = !0, Vn.prototype.getPoint = function(e, t) {
        t = t || new i;
        var n = this.points,
            r = (n.length - 1) * e;
        r -= e = Math.floor(r);
        var o = n[0 === e ? e : e - 1],
            a = n[e],
            s = n[e > n.length - 2 ? n.length - 1 : e + 1];
        return n = n[e > n.length - 3 ? n.length - 1 : e + 2], t.set(zn(r, o.x, a.x, s.x, n.x), zn(r, o.y, a.y, s.y, n.y)), t
    }, Vn.prototype.copy = function(e) {
        Dn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this
    }, Vn.prototype.toJSON = function() {
        var e = Dn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e
    }, Vn.prototype.fromJSON = function(e) {
        Dn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new i).fromArray(r))
        }
        return this
    };
    var $o = Object.freeze({
        ArcCurve: Rn,
        CatmullRomCurve3: In,
        CubicBezierCurve: Fn,
        CubicBezierCurve3: kn,
        EllipseCurve: Pn,
        LineCurve: Un,
        LineCurve3: Hn,
        QuadraticBezierCurve: Gn,
        QuadraticBezierCurve3: jn,
        SplineCurve: Vn
    });
    Wn.prototype = Object.assign(Object.create(Dn.prototype), {
        constructor: Wn,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Un(t, e))
        },
        getPoint: function(e) {
            var t = e * this.getLength(),
                i = this.getCurveLengths();
            for (e = 0; e < i.length;) {
                if (i[e] >= t) return t = i[e] - t, i = (e = this.curves[e]).getLength(), e.getPointAt(0 === i ? 0 : 1 - t / i);
                e++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++) {
                var o = r[n];
                o = o.getPoints(o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e);
                for (var a = 0; a < o.length; a++) {
                    var s = o[a];
                    t && t.equals(s) || (i.push(s), t = s)
                }
            }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        copy: function(e) {
            Dn.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) this.curves.push(e.curves[t].clone());
            return this.autoClose = e.autoClose, this
        },
        toJSON: function() {
            var e = Dn.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) e.curves.push(this.curves[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            Dn.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new $o[n.type]).fromJSON(n))
            }
            return this
        }
    }), qn.prototype = Object.assign(Object.create(Wn.prototype), {
        constructor: qn,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var n = new Un(this.currentPoint.clone(), new i(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            e = new Gn(this.currentPoint.clone(), new i(e, t), new i(n, r)), this.curves.push(e), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(e, t, n, r, o, a) {
            e = new Fn(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(o, a)), this.curves.push(e), this.currentPoint.set(o, a)
        },
        splineThru: function(e) {
            var t = [this.currentPoint.clone()].concat(e);
            t = new Vn(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, i, n, r, o) {
            this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o)
        },
        absarc: function(e, t, i, n, r, o) {
            this.absellipse(e, t, i, i, n, r, o)
        },
        ellipse: function(e, t, i, n, r, o, a, s) {
            this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o, a, s)
        },
        absellipse: function(e, t, i, n, r, o, a, s) {
            e = new Pn(e, t, i, n, r, o, a, s), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e)
        },
        copy: function(e) {
            return Wn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function() {
            var e = Wn.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function(e) {
            return Wn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), Xn.prototype = Object.assign(Object.create(qn.prototype), {
        constructor: Xn,
        getPointsHoles: function(e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            qn.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) this.holes.push(e.holes[t].clone());
            return this
        },
        toJSON: function() {
            var e = qn.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) e.holes.push(this.holes[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            qn.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new qn).fromJSON(n))
            }
            return this
        }
    }), Yn.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Yn,
        isLight: !0,
        copy: function(e) {
            return T.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Zn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Zn,
        isHemisphereLight: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(Jn.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), Qn.prototype = Object.assign(Object.create(Jn.prototype), {
        constructor: Qn,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera,
                i = 2 * uo.RAD2DEG * e.angle,
                n = this.mapSize.width / this.mapSize.height;
            e = e.distance || t.far, i === t.fov && n === t.aspect && e === t.far || (t.fov = i, t.aspect = n, t.far = e, t.updateProjectionMatrix())
        }
    }), $n.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: $n,
        isSpotLight: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), Kn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Kn,
        isPointLight: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), er.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: er,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return xt.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function(e, t, i, n, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - e;
            if (i += e, e = n + t, t = n - t, null !== this.view && this.view.enabled) {
                i = this.zoom / (this.view.width / this.view.fullWidth), t = this.zoom / (this.view.height / this.view.fullHeight);
                var o = (this.right - this.left) / this.view.width;
                n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, t = (e -= this.view.offsetY / t * n) - this.view.height / t * n
            }
            this.projectionMatrix.makeOrthographic(r, i, e, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = T.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), tr.prototype = Object.assign(Object.create(Jn.prototype), {
        constructor: tr
    }), ir.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: ir,
        isDirectionalLight: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), nr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: nr,
        isAmbientLight: !0
    }), rr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: rr,
        isRectAreaLight: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function(e) {
            return (e = Yn.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, e
        }
    }), Object.assign(or.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            function t(e) {
                return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
            }
            var n = this.textures,
                a = new jo[e.type];
            if (void 0 !== e.uuid && (a.uuid = e.uuid), void 0 !== e.name && (a.name = e.name), void 0 !== e.color && a.color.setHex(e.color), void 0 !== e.roughness && (a.roughness = e.roughness), void 0 !== e.metalness && (a.metalness = e.metalness), void 0 !== e.emissive && a.emissive.setHex(e.emissive), void 0 !== e.specular && a.specular.setHex(e.specular), void 0 !== e.shininess && (a.shininess = e.shininess), void 0 !== e.clearCoat && (a.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (a.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (a.vertexColors = e.vertexColors), void 0 !== e.fog && (a.fog = e.fog), void 0 !== e.flatShading && (a.flatShading = e.flatShading), void 0 !== e.blending && (a.blending = e.blending), void 0 !== e.combine && (a.combine = e.combine), void 0 !== e.side && (a.side = e.side), void 0 !== e.opacity && (a.opacity = e.opacity), void 0 !== e.transparent && (a.transparent = e.transparent), void 0 !== e.alphaTest && (a.alphaTest = e.alphaTest), void 0 !== e.depthTest && (a.depthTest = e.depthTest), void 0 !== e.depthWrite && (a.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (a.colorWrite = e.colorWrite), void 0 !== e.wireframe && (a.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (a.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (a.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (a.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (a.rotation = e.rotation), 1 !== e.linewidth && (a.linewidth = e.linewidth), void 0 !== e.dashSize && (a.dashSize = e.dashSize), void 0 !== e.gapSize && (a.gapSize = e.gapSize), void 0 !== e.scale && (a.scale = e.scale), void 0 !== e.polygonOffset && (a.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (a.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (a.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (a.skinning = e.skinning), void 0 !== e.morphTargets && (a.morphTargets = e.morphTargets), void 0 !== e.dithering && (a.dithering = e.dithering), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.uniforms)
                for (var l in e.uniforms) {
                    var c = e.uniforms[l];
                    switch (a.uniforms[l] = {}, c.type) {
                        case "t":
                            a.uniforms[l].value = t(c.value);
                            break;
                        case "c":
                            a.uniforms[l].value = (new b).setHex(c.value);
                            break;
                        case "v2":
                            a.uniforms[l].value = (new i).fromArray(c.value);
                            break;
                        case "v3":
                            a.uniforms[l].value = (new r).fromArray(c.value);
                            break;
                        case "v4":
                            a.uniforms[l].value = (new s).fromArray(c.value);
                            break;
                        case "m3":
                            a.uniforms[l].value = (new o).fromArray(c.value);
                        case "m4":
                            a.uniforms[l].value = (new g).fromArray(c.value);
                            break;
                        default:
                            a.uniforms[l].value = c.value
                    }
                }
            if (void 0 !== e.defines && (a.defines = e.defines), void 0 !== e.vertexShader && (a.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (a.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var h in e.extensions) a.extensions[h] = e.extensions[h];
            return void 0 !== e.shading && (a.flatShading = 1 === e.shading), void 0 !== e.size && (a.size = e.size), void 0 !== e.sizeAttenuation && (a.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (a.map = t(e.map)), void 0 !== e.matcap && (a.matcap = t(e.matcap)), void 0 !== e.alphaMap && (a.alphaMap = t(e.alphaMap), a.transparent = !0), void 0 !== e.bumpMap && (a.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (a.bumpScale = e.bumpScale), void 0 !== e.normalMap && (a.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (a.normalMapType = e.normalMapType), void 0 !== e.normalScale && (l = e.normalScale, !1 === Array.isArray(l) && (l = [l, l]), a.normalScale = (new i).fromArray(l)), void 0 !== e.displacementMap && (a.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (a.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (a.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (a.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (a.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (a.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (a.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (a.specularMap = t(e.specularMap)), void 0 !== e.envMap && (a.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (a.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (a.reflectivity = e.reflectivity), void 0 !== e.lightMap && (a.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (a.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (a.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (a.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (a.gradientMap = t(e.gradientMap)), a
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setTextures: function(e) {
            return this.textures = e, this
        }
    });
    var Ko = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };
    ar.prototype = Object.assign(Object.create(k.prototype), {
        constructor: ar,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return k.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = k.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
        }
    }), sr.prototype = Object.assign(Object.create(A.prototype), {
        constructor: sr,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return A.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function() {
            var e = A.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Object.assign(lr.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function(e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function(e) {
            var t = e.isInstancedBufferGeometry ? new ar : new k,
                i = e.data.index;
            if (void 0 !== i) {
                var n = new ea[i.type](i.array);
                t.setIndex(new A(n, 1))
            }
            for (var o in i = e.data.attributes) {
                var a = i[o];
                n = new ea[a.type](a.array), n = new(a.isInstancedBufferAttribute ? sr : A)(n, a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), t.addAttribute(o, n)
            }
            var s = e.data.morphAttributes;
            if (s)
                for (o in s) {
                    var l = s[o],
                        c = [];
                    i = 0;
                    for (var h = l.length; i < h; i++) a = l[i], n = new A(n = new ea[a.type](a.array), a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), c.push(n);
                    t.morphAttributes[o] = c
                }
            if (void 0 !== (o = e.data.groups || e.data.drawcalls || e.data.offsets))
                for (i = 0, a = o.length; i !== a; ++i) n = o[i], t.addGroup(n.start, n.count, n.materialIndex);
            return void 0 !== (i = e.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), t.boundingSphere = new p(o, i.radius)), e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
        },
        setPath: function(e) {
            return this.path = e, this
        }
    });
    var ea = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Object.assign(cr.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = this,
                o = void 0 === this.path ? Ko.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o, (o = new En(r.manager)).setPath(this.path), o.load(e, (function(i) {
                var o = null;
                try {
                    o = JSON.parse(i)
                } catch (t) {
                    return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e) : r.parse(o, t)
            }), i, n)
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e, this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        parse: function(e, t) {
            var i = this.parseShape(e.shapes);
            i = this.parseGeometries(e.geometries, i);
            var n = this.parseImages(e.images, (function() {
                void 0 !== t && t(r)
            }));
            n = this.parseTextures(e.textures, n), n = this.parseMaterials(e.materials, n);
            var r = this.parseObject(e.object, i, n);
            return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var i = 0, n = e.length; i < n; i++) {
                    var r = (new Xn).fromJSON(e[i]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var n = new lr, r = 0, o = e.length; r < o; r++) {
                    var a = e[r];
                    switch (a.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            var s = new Go[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new Go[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new Go[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new Go[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new Go[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new Go[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new Go[a.type](a.radius, a.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new Go[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new Go[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new Go[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            s = new Go[a.type]((new $o[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new Go[a.type](a.points, a.segments, a.phiStart, a.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new Go[a.type](a.vertices, a.indices, a.radius, a.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            s = [];
                            for (var l = 0, c = a.shapes.length; l < c; l++) {
                                var h = t[a.shapes[l]];
                                s.push(h)
                            }
                            s = new Go[a.type](s, a.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (s = [], l = 0, c = a.shapes.length; l < c; l++) h = t[a.shapes[l]], s.push(h);
                            void 0 !== (l = a.options.extrudePath) && (a.options.extrudePath = (new $o[l.type]).fromJSON(l)), s = new Go[a.type](s, a.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            s = n.parse(a);
                            break;
                        case "Geometry":
                            "THREE" in window && "LegacyJSONLoader" in THREE ? s = (new THREE.LegacyJSONLoader).parse(a, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
                            continue
                    }
                    s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s
                }
            return i
        },
        parseMaterials: function(e, t) {
            var i = {},
                n = {};
            if (void 0 !== e) {
                var r = new or;
                r.setTextures(t), t = 0;
                for (var o = e.length; t < o; t++) {
                    var a = e[t];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], l = 0; l < a.materials.length; l++) {
                            var c = a.materials[l];
                            void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), s.push(i[c.uuid])
                        }
                        n[a.uuid] = s
                    } else void 0 === i[a.uuid] && (i[a.uuid] = r.parse(a)), n[a.uuid] = i[a.uuid]
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i],
                    r = xn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            function i(e) {
                return n.manager.itemStart(e), o.load(e, (function() {
                    n.manager.itemEnd(e)
                }), void 0, (function() {
                    n.manager.itemError(e), n.manager.itemEnd(e)
                }))
            }
            var n = this,
                r = {};
            if (void 0 !== e && 0 < e.length) {
                var o = new An(t = new _n(t));
                o.setCrossOrigin(this.crossOrigin), t = 0;
                for (var a = e.length; t < a; t++) {
                    var s = e[t],
                        l = s.url;
                    if (Array.isArray(l)) {
                        r[s.uuid] = [];
                        for (var c = 0, h = l.length; c < h; c++) {
                            var u = l[c];
                            u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[s.uuid].push(i(u))
                        }
                    } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url, r[s.uuid] = i(u)
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var n = {};
            if (void 0 !== e)
                for (var r = 0, o = e.length; r < o; r++) {
                    var s = e[r];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    var l = Array.isArray(t[s.image]) ? new se(t[s.image]) : new a(t[s.image]);
                    l.needsUpdate = !0, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = i(s.mapping, ta)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = i(s.wrap[0], ia), l.wrapT = i(s.wrap[1], ia)), void 0 !== s.format && (l.format = s.format), void 0 !== s.type && (l.type = s.type), void 0 !== s.encoding && (l.encoding = s.encoding), void 0 !== s.minFilter && (l.minFilter = i(s.minFilter, na)), void 0 !== s.magFilter && (l.magFilter = i(s.magFilter, na)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), n[s.uuid] = l
                }
            return n
        },
        parseObject: function(e, t, i) {
            function n(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
            }

            function r(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var o = e[n];
                            void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(i[o])
                        }
                        return t
                    }
                    return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e]
                }
            }
            switch (e.type) {
                case "Scene":
                    var o = new Lt;
                    void 0 !== e.background && Number.isInteger(e.background) && (o.background = new b(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new Ct(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new At(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    o = new wt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    o = new er(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    o = new nr(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    o = new ir(e.color, e.intensity);
                    break;
                case "PointLight":
                    o = new Kn(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    o = new rr(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    o = new $n(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case "HemisphereLight":
                    o = new Zn(e.color, e.groundColor, e.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    o = n(e.geometry);
                    var a = r(e.material);
                    o = o.bones && 0 < o.bones.length ? new zt(o, a) : new Z(o, a), void 0 !== e.drawMode && o.setDrawMode(e.drawMode);
                    break;
                case "LOD":
                    o = new It;
                    break;
                case "Line":
                    o = new kt(n(e.geometry), r(e.material), e.mode);
                    break;
                case "LineLoop":
                    o = new Ht(n(e.geometry), r(e.material));
                    break;
                case "LineSegments":
                    o = new Ut(n(e.geometry), r(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    o = new jt(n(e.geometry), r(e.material));
                    break;
                case "Sprite":
                    o = new Ot(r(e.material));
                    break;
                case "Group":
                    o = new bt;
                    break;
                default:
                    o = new T
            }
            if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.layers && (o.layers.mask = e.layers), void 0 !== e.children) {
                a = e.children;
                for (var s = 0; s < a.length; s++) o.add(this.parseObject(a[s], t, i))
            }
            if ("LOD" === e.type)
                for (e = e.levels, a = 0; a < e.length; a++) {
                    s = e[a];
                    var l = o.getObjectByProperty("uuid", s.object);
                    void 0 !== l && o.addLevel(l, s.distance)
                }
            return o
        }
    });
    var ta = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        ia = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        na = {
            NearestFilter: 1003,
            NearestMipMapNearestFilter: 1004,
            NearestMipMapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: 1008
        };
    hr.prototype = {
        constructor: hr,
        setOptions: function(e) {
            return this.options = e, this
        },
        load: function(e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = Wo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            fetch(e).then((function(e) {
                return e.blob()
            })).then((function(e) {
                return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
            })).then((function(i) {
                Wo.add(e, i), t && t(i), r.manager.itemEnd(e)
            })).catch((function(t) {
                n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
            })), r.manager.itemStart(e)
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }, Object.assign(ur.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new qn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, o) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, o)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i],
                        o = new Xn;
                    o.curves = r.curves, t.push(o)
                }
                return t
            }

            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                    var a = t[r],
                        s = t[o],
                        l = s.x - a.x,
                        c = s.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (0 > c && (a = t[o], l = -l, s = t[r], c = -c), !(e.y < a.y || e.y > s.y))
                            if (e.y === a.y) {
                                if (e.x === a.x) return !0
                            } else {
                                if (0 === (r = c * (e.x - a.x) - l * (e.y - a.y))) return !0;
                                0 > r || (n = !n)
                            }
                    } else if (e.y === a.y && (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x)) return !0
                }
                return n
            }
            var r = Uo.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === t) return i(o);
            if (t = [], 1 === o.length) {
                var a = o[0],
                    s = new Xn;
                return s.curves = a.curves, t.push(s), t
            }
            var l = !r(o[0].getPoints());
            l = e ? !l : l, s = [];
            var c = [],
                h = [],
                u = 0;
            c[u] = void 0, h[u] = [];
            for (var d = 0, p = o.length; d < p; d++) {
                var f = (a = o[d]).getPoints(),
                    m = r(f);
                (m = e ? !m : m) ? (!l && c[u] && u++, c[u] = {
                    s: new Xn,
                    p: f
                }, c[u].s.curves = a.curves, l && u++, h[u] = []) : h[u].push({
                    h: a,
                    p: f[0]
                })
            }
            if (!c[0]) return i(o);
            if (1 < c.length) {
                for (d = !1, e = [], r = 0, o = c.length; r < o; r++) s[r] = [];
                for (r = 0, o = c.length; r < o; r++)
                    for (a = h[r], m = 0; m < a.length; m++) {
                        for (l = a[m], u = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && e.push({
                            froms: r,
                            tos: f,
                            hole: m
                        }), u ? (u = !1, s[f].push(l)) : d = !0);
                        u && s[r].push(l)
                    }
                0 < e.length && (d || (h = s))
            }
            for (d = 0, r = c.length; d < r; d++)
                for (s = c[d].s, t.push(s), o = 0, a = (e = h[d]).length; o < a; o++) s.holes.push(e[o].h);
            return t
        }
    }), Object.assign(dr.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            var i = [],
                n = t;
            t = this.data;
            var r = Array.from ? Array.from(e) : String(e).split("");
            n /= t.resolution;
            var o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n;
            e = [];
            for (var a = 0, s = 0, l = 0; l < r.length; l++) {
                var c = r[l];
                if ("\n" === c) a = 0, s -= o;
                else {
                    var h = n,
                        u = a,
                        d = s;
                    if (c = t.glyphs[c] || t.glyphs["?"]) {
                        var p = new ur;
                        if (c.o)
                            for (var f = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * h + u,
                                        y = f[m++] * h + d;
                                    p.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * h + u, y = f[m++] * h + d, p.lineTo(v, y);
                                    break;
                                case "q":
                                    var b = f[m++] * h + u,
                                        x = f[m++] * h + d,
                                        w = f[m++] * h + u,
                                        _ = f[m++] * h + d;
                                    p.quadraticCurveTo(w, _, b, x);
                                    break;
                                case "b":
                                    b = f[m++] * h + u, x = f[m++] * h + d, w = f[m++] * h + u, _ = f[m++] * h + d, v = f[m++] * h + u, y = f[m++] * h + d, p.bezierCurveTo(w, _, v, y, b, x)
                            }
                        h = {
                            offsetX: c.ha * h,
                            path: p
                        }
                    } else h = void 0;
                    a += h.offsetX, e.push(h.path)
                }
            }
            for (t = 0, r = e.length; t < r; t++) Array.prototype.push.apply(i, e[t].toShapes());
            return i
        }
    }), Object.assign(pr.prototype, {
        load: function(e, t, i, n) {
            var r = this,
                o = new En(this.manager);
            o.setPath(this.path), o.load(e, (function(e) {
                try {
                    var i = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
                }
                e = r.parse(i), t && t(e)
            }), i, n)
        },
        parse: function(e) {
            return new dr(e)
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), fr.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i + 1];
                if (t[i].test(e)) return r
            }
            return null
        }
    }, Object.assign(fr.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: function() {
            var e = {
                    NoBlending: 0,
                    NormalBlending: 1,
                    AdditiveBlending: 2,
                    SubtractiveBlending: 3,
                    MultiplyBlending: 4,
                    CustomBlending: 5
                },
                t = new b,
                i = new Ln,
                n = new or;
            return function(r, o, a) {
                function s(e, t, n, r, s) {
                    e = o + e;
                    var l = fr.Handlers.get(e);
                    return null !== l ? e = l.load(e) : (i.setCrossOrigin(a), e = i.load(e)), void 0 !== t && (e.repeat.fromArray(t), 1 !== t[0] && (e.wrapS = 1e3), 1 !== t[1] && (e.wrapT = 1e3)), void 0 !== n && e.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (e.wrapS = 1e3), "mirror" === r[0] && (e.wrapS = 1002), "repeat" === r[1] && (e.wrapT = 1e3), "mirror" === r[1] && (e.wrapT = 1002)), void 0 !== s && (e.anisotropy = s), t = uo.generateUUID(), c[t] = e, t
                }
                var l, c = {},
                    h = {
                        uuid: uo.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (l in r) {
                    var u = r[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "DbgName":
                            h.name = u;
                            break;
                        case "blending":
                            h.blending = e[u];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            h.color = t.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            h.specular = t.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            h.emissive = t.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            h.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            h.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapEmissive":
                            h.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case "mapLight":
                            h.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapAO":
                            h.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapBump":
                            h.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            h.bumpScale = u;
                            break;
                        case "mapNormal":
                            h.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            h.normalScale = u;
                            break;
                        case "mapSpecular":
                            h.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapMetalness":
                            h.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case "mapRoughness":
                            h.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case "mapAlpha":
                            h.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "flipSided":
                            h.side = 1;
                            break;
                        case "doubleSided":
                            h.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), h.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            h[l] = u;
                            break;
                        case "vertexColors":
                            !0 === u && (h.vertexColors = 2), "face" === u && (h.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                    }
                }
                return "MeshBasicMaterial" === h.type && delete h.emissive, "MeshPhongMaterial" !== h.type && delete h.specular, 1 > h.opacity && (h.transparent = !0), n.setTextures(c), n.parse(h)
            }
        }()
    });
    var ra, oa, aa, sa = {
        getContext: function() {
            return void 0 === ra && (ra = new(window.AudioContext || window.webkitAudioContext)), ra
        },
        setContext: function(e) {
            ra = e
        }
    };
    Object.assign(mr.prototype, {
        load: function(e, t, i, n) {
            var r = new En(this.manager);
            r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function(e) {
                e = e.slice(0), sa.getContext().decodeAudioData(e, (function(e) {
                    t(e)
                }))
            }), i, n)
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(gr.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .282095 * r[0], t += .488603 * r[1] * n, t += .488603 * r[2] * e, t += .488603 * r[3] * i, t += 1.092548 * r[4] * i * n, t += 1.092548 * r[5] * n * e, t += .315392 * r[6] * (3 * e * e - 1), (t += 1.092548 * r[7] * i * e) + .546274 * r[8] * (i * i - n * n)
        },
        getIrradianceAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .886227 * r[0], t += 1.023328 * r[1] * n, t += 1.023328 * r[2] * e, t += 1.023328 * r[3] * i, t += .858086 * r[4] * i * n, t += .858086 * r[5] * n * e, t += r[6] * (.743125 * e * e - .247708), (t += .858086 * r[7] * i * e) + .429043 * r[8] * (i * i - n * n)
        },
        add: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function(e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var i = 0; 9 > i; i++) this.coefficients[i].lerp(e.coefficients[i], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; 9 > t; t++)
                if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e) {
            for (var t = this.coefficients, i = 0; 9 > i; i++) t[i].fromArray(e, 3 * i);
            return this
        },
        toArray: function() {
            for (var e = [], t = this.coefficients, i = 0; 9 > i; i++) t[i].toArray(e, 3 * i);
            return e
        }
    }), Object.assign(gr, {
        getBasisAt: function(e, t) {
            var i = e.x,
                n = e.y;
            e = e.z, t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * e, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * i * e, t[8] = .546274 * (i * i - n * n)
        }
    }), vr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: vr,
        isLightProbe: !0,
        copy: function(e) {
            return Yn.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            return Yn.prototype.toJSON.call(this, e)
        }
    }), yr.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: yr,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return vr.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return vr.prototype.toJSON.call(this, e)
        }
    }), br.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: br,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return vr.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return vr.prototype.toJSON.call(this, e)
        }
    }), Object.assign(xr.prototype, {
        update: function() {
            var e, t, i, n, r, o, a, s, l = new g,
                c = new g;
            return function(h) {
                if (e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep) {
                    e = this, t = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, o = h.far, a = h.zoom;
                    var u = h.projectionMatrix.clone(),
                        d = (s = this.eyeSep / 2) * r / t,
                        p = r * Math.tan(uo.DEG2RAD * i * .5) / a;
                    c.elements[12] = -s, l.elements[12] = s;
                    var f = -p * n + d,
                        m = p * n + d;
                    u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(u), f = -p * n - d, m = p * n - d, u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(u)
                }
                this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(l)
            }
        }()
    }), wr.prototype = Object.create(T.prototype), wr.prototype.constructor = wr, Object.assign(_r.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }), Er.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Er,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function() {
            var e = new r,
                t = new n,
                i = new r,
                o = new r,
                a = new _r;
            return function(n) {
                T.prototype.updateMatrixWorld.call(this, n), n = this.context.listener;
                var r = this.up;
                if (this.timeDelta = a.getDelta(), this.matrixWorld.decompose(e, t, i), o.set(0, 0, -1).applyQuaternion(t), n.positionX) {
                    var s = this.context.currentTime + this.timeDelta;
                    n.positionX.linearRampToValueAtTime(e.x, s), n.positionY.linearRampToValueAtTime(e.y, s), n.positionZ.linearRampToValueAtTime(e.z, s), n.forwardX.linearRampToValueAtTime(o.x, s), n.forwardY.linearRampToValueAtTime(o.y, s), n.forwardZ.linearRampToValueAtTime(o.z, s), n.upX.linearRampToValueAtTime(r.x, s), n.upY.linearRampToValueAtTime(r.y, s), n.upZ.linearRampToValueAtTime(r.z, s)
                } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z, r.x, r.y, r.z)
            }
        }()
    }), Mr.prototype = Object.assign(Object.create(T.prototype), {
        constructor: Mr,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        },
        setBuffer: function(e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function() {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        setDetune: function(e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    }), Tr.prototype = Object.assign(Object.create(Mr.prototype), {
        constructor: Tr,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e, this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e, this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e, this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e, this
        },
        setDirectionalCone: function(e, t, i) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
        },
        updateMatrixWorld: function() {
            var e = new r,
                t = new n,
                i = new r,
                o = new r;
            return function(n) {
                if (T.prototype.updateMatrixWorld.call(this, n), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                    if (this.matrixWorld.decompose(e, t, i), o.set(0, 0, 1).applyQuaternion(t), (n = this.panner).positionX) {
                        var r = this.context.currentTime + this.listener.timeDelta;
                        n.positionX.linearRampToValueAtTime(e.x, r), n.positionY.linearRampToValueAtTime(e.y, r), n.positionZ.linearRampToValueAtTime(e.z, r), n.orientationX.linearRampToValueAtTime(o.x, r), n.orientationY.linearRampToValueAtTime(o.y, r), n.orientationZ.linearRampToValueAtTime(o.z, r)
                    } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z)
            }
        }()
    }), Object.assign(Sr.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
            return e / t.length
        }
    }), Object.assign(Ar.prototype, {
        accumulate: function(e, t) {
            var i = this.buffer,
                n = this.valueSize;
            e = e * n + n;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== n; ++r) i[e + r] = i[r];
                r = t
            } else r += t, this._mixBufferRegion(i, e, 0, t / r, n);
            this.cumulativeWeight = r
        },
        apply: function(e) {
            var t = this.valueSize,
                i = this.buffer;
            e = e * t + t;
            var n = this.cumulativeWeight,
                r = this.binding;
            this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, e, 3 * t, 1 - n, t), n = t;
            for (var o = t + t; n !== o; ++n)
                if (i[n] !== i[n + t]) {
                    r.setValue(i, e);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.buffer,
                t = this.valueSize,
                i = 3 * t;
            this.binding.getValue(e, i);
            for (var n = t; n !== i; ++n) e[n] = e[i + n % t];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(e, t, i, n, r) {
            if (.5 <= n)
                for (n = 0; n !== r; ++n) e[t + n] = e[i + n]
        },
        _slerp: function(e, t, i, r) {
            n.slerpFlat(e, t, e, t, e, i, r)
        },
        _lerp: function(e, t, i, n, r) {
            for (var o = 1 - n, a = 0; a !== r; ++a) {
                var s = t + a;
                e[s] = e[s] * o + e[i + a] * n
            }
        }
    }), Object.assign(Cr.prototype, {
        getValue: function(e, t) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
        }
    }), Object.assign(Lr, {
        Composite: Cr,
        create: function(e, t, i) {
            return e && e.isAnimationObjectGroup ? new Lr.Composite(e, t, i) : new Lr(e, t, i)
        },
        sanitizeNodeName: function() {
            var e = /[\[\]\.:\/]/g;
            return function(t) {
                return t.replace(/\s/g, "_").replace(e, "")
            }
        }(),
        parseTrackName: function() {
            var e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                t = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            e = /(WCOD+)?/.source.replace("WCOD", e);
            var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                r = new RegExp("^" + t + e + i + n + "$"),
                o = ["material", "materials", "bones"];
            return function(e) {
                var t = r.exec(e);
                if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                var i = (t = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }).nodeName && t.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = t.nodeName.substring(i + 1); - 1 !== o.indexOf(n) && (t.nodeName = t.nodeName.substring(0, i), t.objectName = n)
                }
                if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return t
            }
        }(),
        findNode: function(e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                var i = e.skeleton.getBoneByName(t);
                if (void 0 !== i) return i
            }
            if (e.children) {
                var n = function(e) {
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.name === t || r.uuid === t || (r = n(r.children))) return r
                    }
                    return null
                };
                if (e = n(e.children)) return e
            }
            return null
        }
    }), Object.assign(Lr.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }, function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
        }, function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
            }, function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function(e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function() {
            var e = this.node,
                t = this.parsedPath,
                i = t.objectName,
                n = t.propertyName,
                r = t.propertyIndex;
            if (e || (this.node = e = Lr.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (i) {
                    var o = t.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            for (e = e.skeleton.bones, i = 0; i < e.length; i++)
                                if (e[i].name === o) {
                                    o = i;
                                    break
                                } break;
                        default:
                            if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[o]
                    }
                }
                if (void 0 === (o = e[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
                else {
                    if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (e.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (e.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Lr.prototype, {
        _getValue_unbound: Lr.prototype.getValue,
        _setValue_unbound: Lr.prototype.setValue
    }), Object.assign(Dr.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
                var u = arguments[c],
                    d = u.uuid,
                    p = n[d];
                if (void 0 === p) {
                    p = t++, n[d] = p, e.push(u), d = 0;
                    for (var f = s; d !== f; ++d) a[d].push(new Lr(u, r[d], o[d]))
                } else if (p < i) {
                    l = e[p];
                    var m = --i;
                    for (n[(f = e[m]).uuid] = p, e[p] = f, n[d] = m, e[m] = u, d = 0, f = s; d !== f; ++d) {
                        var g = a[d],
                            v = g[p];
                        g[p] = g[m], void 0 === v && (v = new Lr(u, r[d], o[d])), g[m] = v
                    }
                } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o],
                    l = s.uuid,
                    c = i[l];
                if (void 0 !== c && c >= t) {
                    var h = t++,
                        u = e[h];
                    for (i[u.uuid] = c, e[c] = u, i[l] = h, e[h] = s, s = 0, l = r; s !== l; ++s) {
                        var d = (u = n[s])[c];
                        u[c] = u[h], u[h] = d
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var l = arguments[a].uuid,
                    c = n[l];
                if (void 0 !== c)
                    if (delete n[l], c < i) {
                        var h = e[l = --i],
                            u = --t,
                            d = e[u];
                        for (n[h.uuid] = c, e[c] = h, n[d.uuid] = l, e[l] = d, e.pop(), h = 0, d = o; h !== d; ++h) {
                            var p = r[h],
                                f = p[u];
                            p[c] = p[l], p[l] = f, p.pop()
                        }
                    } else
                        for (n[(d = e[u = --t]).uuid] = c, e[c] = d, e.pop(), h = 0, d = o; h !== d; ++h)(p = r[h])[c] = p[u], p.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(e, t) {
            var i = this._bindingsIndicesByPath,
                n = i[e],
                r = this._bindings;
            if (void 0 !== n) return r[n];
            var o = this._paths,
                a = this._parsedPaths,
                s = this._objects,
                l = this.nCachedObjects_,
                c = Array(s.length);
            for (n = r.length, i[e] = n, o.push(e), a.push(t), r.push(c), i = l, n = s.length; i !== n; ++i) c[i] = new Lr(s[i], e, t);
            return c
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath,
                i = t[e];
            if (void 0 !== i) {
                var n = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    a = o.length - 1,
                    s = o[a];
                t[e[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
            }
        }
    }), Object.assign(Pr.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e, this
        },
        setLoop: function(e, t) {
            return this.loop = e, this.repetitions = t, this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, i) {
            if (e.fadeOut(t), this.fadeIn(t), i) {
                i = this._clip.duration;
                var n = e._clip.duration,
                    r = i / n;
                e.warp(1, n / i, t), this.warp(r, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._timeScaleInterpolant,
                a = this.timeScale;
            return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = e / a, o[1] = t / a, this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (0 > (t = (e - r) * i) || 0 === i) return;
                    this._startTime = null, t *= i
                }
                if (t *= this._updateTimeScale(e), i = this._updateTime(t), 0 < (e = this._updateWeight(e))) {
                    t = this._interpolants, r = this._propertyBindings;
                    for (var o = 0, a = t.length; o !== a; ++o) t[o].evaluate(i), r[o].accumulate(n, e)
                }
            } else this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0];
                    t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var i = this._timeScaleInterpolant;
                null !== i && (t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
            }
            return this._effectiveTimeScale = t
        },
        _updateTime: function(e) {
            var t = this.time + e,
                i = this._clip.duration,
                n = this.loop,
                r = this._loopCount,
                o = 2202 === n;
            if (0 === e) return -1 === r || !o || 1 & ~r ? t : i - t;
            if (2200 === n) e: {
                if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
                else {
                    if (!(0 > t)) {
                        this.time = t;
                        break e
                    }
                    t = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = t,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > e ? -1 : 1
                })
            }
            else {
                if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= i || 0 > t) {
                    t -= i * (n = Math.floor(t / i)), r += Math.abs(n);
                    var a = this.repetitions - r;
                    0 >= a ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t = 0 < e ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < e ? 1 : -1
                    })) : (1 === a ? (e = 0 > e, this._setEndings(e, !e, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = t, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    }))
                } else this.time = t;
                if (o && !(1 & ~r)) return i - t
            }
            return t
        },
        _setEndings: function(e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._weightInterpolant;
            return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = t, n[1] = r + e, o[1] = i, this
        }
    }), Rr.prototype = Object.assign(Object.create(t.prototype), {
        constructor: Rr,
        _bindAction: function(e, t) {
            var i = e._localRoot || this._root,
                n = e._clip.tracks,
                r = n.length,
                o = e._propertyBindings;
            e = e._interpolants;
            var a = i.uuid,
                s = this._bindingsByRootAndName,
                l = s[a];
            for (void 0 === l && (l = {}, s[a] = l), s = 0; s !== r; ++s) {
                var c = n[s],
                    h = c.name,
                    u = l[h];
                if (void 0 === u) {
                    if (void 0 !== (u = o[s])) {
                        null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, h));
                        continue
                    }++(u = new Ar(Lr.create(i, h, t && t._propertyBindings[s].binding.parsedPath), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(u, a, h)
                }
                o[s] = u, e[s].resultBuffer = u.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid,
                        i = e._clip.uuid,
                        n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                }
                for (i = 0, n = (t = e._propertyBindings).length; i !== n; ++i) {
                    var r = t[i];
                    0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            return null !== (e = e._cacheIndex) && e < this._nActiveActions
        },
        _addInactiveAction: function(e, t, i) {
            var n = this._actions,
                r = this._actionsByClip,
                o = r[t];
            void 0 === o ? (o = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = o) : (t = o.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = n.length, n.push(e), o.actionByRoot[i] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions,
                i = t[t.length - 1],
                n = e._cacheIndex;
            i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null, t = e._clip.uuid;
            var r = (n = (i = this._actionsByClip)[t]).knownActions,
                o = r[r.length - 1],
                a = e._byClipCacheIndex;
            o._byClipCacheIndex = a, r[a] = o, r.pop(), e._byClipCacheIndex = null, delete n.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete i[t], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = 0, i = (e = e._propertyBindings).length; t !== i; ++t) {
                var n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = this._nActiveActions++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackAction: function(e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = --this._nActiveActions,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _addInactiveBinding: function(e, t, i) {
            var n = this._bindingsByRootAndName,
                r = n[t],
                o = this._bindings;
            void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = o.length, o.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings,
                i = e.binding,
                n = i.rootNode.uuid;
            i = i.path;
            var r = this._bindingsByRootAndName,
                o = r[n],
                a = t[t.length - 1];
            e = e._cacheIndex, a._cacheIndex = e, t[e] = a, t.pop(), delete o[i];
            e: {
                for (var s in o) break e;delete r[n]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = this._nActiveBindings++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackBinding: function(e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = --this._nActiveBindings,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                i = e[t];
            return void 0 === i && ((i = new hn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants,
                i = e.__cacheIndex,
                n = --this._nActiveControlInterpolants,
                r = t[n];
            e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var i = t || this._root,
                n = i.uuid;
            e = null !== (i = "string" == typeof e ? xn.findByName(i, e) : e) ? i.uuid : e;
            var r = this._actionsByClip[e],
                o = null;
            if (void 0 !== r) {
                if (void 0 !== (o = r.actionByRoot[n])) return o;
                o = r.knownActions[0], null === i && (i = o._clip)
            }
            return null === i ? null : (t = new Pr(this, i, t), this._bindAction(t, o), this._addInactiveAction(t, e, n), t)
        },
        existingAction: function(e, t) {
            var i = t || this._root;
            return t = i.uuid, i = "string" == typeof e ? xn.findByName(i, e) : e, void 0 !== (e = this._actionsByClip[i ? i.uuid : e]) && e.actionByRoot[t] || null
        },
        stopAllAction: function() {
            for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r) e[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) t[a]._update(n, e, r, o);
            for (e = this._bindings, t = this._nActiveBindings, a = 0; a !== t; ++a) e[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions;
            e = e.uuid;
            var i = this._actionsByClip,
                n = i[e];
            if (void 0 !== n) {
                for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) {
                    var a = n[r];
                    this._deactivateAction(a);
                    var s = a._cacheIndex,
                        l = t[t.length - 1];
                    a._cacheIndex = null, a._byClipCacheIndex = null, l._cacheIndex = s, t[s] = l, t.pop(), this._removeInactiveBindingsForAction(a)
                }
                delete i[e]
            }
        },
        uncacheRoot: function(e) {
            e = e.uuid;
            var t = this._actionsByClip;
            for (n in t) {
                var i = t[n].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[e];
            if (void 0 !== n)
                for (var r in n)(e = n[r]).restoreOriginalState(), this._removeInactiveBinding(e)
        },
        uncacheAction: function(e, t) {
            null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e))
        }
    }), Or.prototype.clone = function() {
        return new Or(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Ir.prototype = Object.assign(Object.create(Dt.prototype), {
        constructor: Ir,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return Dt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(zr.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, i) {
            return Br(e, this, i = i || [], t), i.sort(Nr), i
        },
        intersectObjects: function(e, t, i) {
            if (i = i || [], !1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var n = 0, r = e.length; n < r; n++) Br(e[n], this, i, t);
            return i.sort(Nr), i
        }
    }), Object.assign(Fr.prototype, {
        set: function(e, t, i) {
            return this.radius = e, this.phi = t, this.theta = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, i), this.phi = Math.acos(uo.clamp(t / this.radius, -1, 1))), this
        }
    }), Object.assign(kr.prototype, {
        set: function(e, t, i) {
            return this.radius = e, this.theta = t, this.y = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
        }
    }), Object.assign(Ur.prototype, {
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new i;
            return function(t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new i), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new i), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new i;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(Hr.prototype, {
        set: function(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new r), e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new r), e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new r), this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function() {
            var e = new r,
                t = new r;
            return function(i, n) {
                return e.subVectors(i, this.start), t.subVectors(this.end, this.start), i = t.dot(t), i = t.dot(e) / i, n && (i = uo.clamp(i, 0, 1)), i
            }
        }(),
        closestPointToPoint: function(e, t, i) {
            return e = this.closestPointToPointParameter(e, t), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), Gr.prototype = Object.create(T.prototype), Gr.prototype.constructor = Gr, Gr.prototype.isImmediateRenderObject = !0, jr.prototype = Object.create(Ut.prototype), jr.prototype.constructor = jr, jr.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new o;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
                o = this.geometry.attributes.position,
                a = this.object.geometry;
            if (a && a.isGeometry)
                for (var s = a.vertices, l = a.faces, c = a = 0, h = l.length; c < h; c++)
                    for (var u = l[c], d = 0, p = u.vertexNormals.length; d < p; d++) {
                        var f = u.vertexNormals[d];
                        e.copy(s[u[n[d]]]).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(a, e.x, e.y, e.z), a += 1, o.setXYZ(a, t.x, t.y, t.z), a += 1
                    } else if (a && a.isBufferGeometry)
                        for (n = a.attributes.position, s = a.attributes.normal, d = a = 0, p = n.count; d < p; d++) e.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), t.set(s.getX(d), s.getY(d), s.getZ(d)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(a, e.x, e.y, e.z), a += 1, o.setXYZ(a, t.x, t.y, t.z), a += 1;
            o.needsUpdate = !0
        }
    }(), Vr.prototype = Object.create(T.prototype), Vr.prototype.constructor = Vr, Vr.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Vr.prototype.update = function() {
        var e = new r;
        return function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3,
                i = t * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(), Wr.prototype = Object.create(Ut.prototype), Wr.prototype.constructor = Wr, Wr.prototype.updateMatrixWorld = function() {
        var e = new r,
            t = new g,
            i = new g;
        return function(n) {
            var r = this.bones,
                o = this.geometry,
                a = o.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var s = 0, l = 0; s < r.length; s++) {
                var c = r[s];
                c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
            }
            o.getAttribute("position").needsUpdate = !0, T.prototype.updateMatrixWorld.call(this, n)
        }
    }(), qr.prototype = Object.create(Z.prototype), qr.prototype.constructor = qr, qr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, qr.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, Xr.prototype = Object.create(kt.prototype), Xr.prototype.constructor = Xr, Xr.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color,
                t = Math.max(e.r, e.g, e.b);
            1 < t && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
        }
    }, Xr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype = Object.create(T.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype.update = function() {
        var e = new r,
            t = new b,
            i = new b;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                t.copy(this.light.color), i.copy(this.light.groundColor);
                for (var o = 0, a = r.count; o < a; o++) {
                    var s = o < a / 2 ? t : i;
                    r.setXYZ(o, s.r, s.g, s.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(), Zr.prototype = Object.create(Z.prototype), Zr.prototype.constructor = Zr, Zr.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, Zr.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
    }, Jr.prototype = Object.assign(Object.create(Ut.prototype), {
        constructor: Jr,
        copy: function(e) {
            return Ut.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Qr.prototype = Object.create(Ut.prototype), Qr.prototype.constructor = Qr, $r.prototype = Object.create(kt.prototype), $r.prototype.constructor = $r, $r.prototype.update = function() {
        function e(e, n, o, a) {
            for (o = (n - e) / o, p.setXYZ(h, 0, 0, 0), u++, t = e; t < n; t += o) i = h + u, p.setXYZ(i, Math.sin(t) * r, 0, Math.cos(t) * r), p.setXYZ(i + 1, Math.sin(Math.min(t + o, n)) * r, 0, Math.cos(Math.min(t + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), u += 3;
            d.addGroup(h, u, a), h += u, u = 0
        }
        var t, i, n = this.audio,
            r = this.range,
            o = this.divisionsInnerAngle,
            a = this.divisionsOuterAngle,
            s = uo.degToRad(n.panner.coneInnerAngle),
            l = s / 2,
            c = (n = uo.degToRad(n.panner.coneOuterAngle)) / 2,
            h = 0,
            u = 0,
            d = this.geometry,
            p = d.attributes.position;
        d.clearGroups(), e(-c, -l, a, 0), e(-l, l, o, 1), e(l, c, a, 0), p.needsUpdate = !0, s === n && (this.material[0].visible = !1)
    }, $r.prototype.dispose = function() {
        this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
    }, Kr.prototype = Object.create(Ut.prototype), Kr.prototype.constructor = Kr, Kr.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new o;
        return function() {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = 0, l = 0, c = (o = o.faces).length; l < c; l++) {
                var h = o[l],
                    u = h.normal;
                e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(n), t.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(s, e.x, e.y, e.z), s += 1, r.setXYZ(s, t.x, t.y, t.z), s += 1
            }
            r.needsUpdate = !0
        }
    }(), eo.prototype = Object.create(T.prototype), eo.prototype.constructor = eo, eo.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, eo.prototype.update = function() {
        var e = new r,
            t = new r,
            i = new r;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = i.length()
        }
    }(), to.prototype = Object.create(Ut.prototype), to.prototype.constructor = to, to.prototype.update = function() {
        function e(e, r, a, s) {
            if (n.set(r, a, s).unproject(o), void 0 !== (e = i[e]))
                for (r = t.getAttribute("position"), a = 0, s = e.length; a < s; a++) r.setXYZ(e[a], n.x, n.y, n.z)
        }
        var t, i, n = new r,
            o = new xt;
        return function() {
            t = this.geometry, i = this.pointMap, o.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        }
    }(), io.prototype = Object.create(Ut.prototype), io.prototype.constructor = io, io.prototype.update = function() {
        var e = new d;
        return function(t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                t = e.min;
                var i = e.max,
                    n = this.geometry.attributes.position,
                    r = n.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), io.prototype.setFromObject = function(e) {
        return this.object = e, this.update(), this
    }, io.prototype.copy = function(e) {
        return Ut.prototype.copy.call(this, e), this.object = e.object, this
    }, io.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, no.prototype = Object.create(Ut.prototype), no.prototype.constructor = no, no.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), T.prototype.updateMatrixWorld.call(this, e))
    }, ro.prototype = Object.create(kt.prototype), ro.prototype.constructor = ro, ro.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), T.prototype.updateMatrixWorld.call(this, e)
    }, oo.prototype = Object.create(T.prototype), oo.prototype.constructor = oo, oo.prototype.setDirection = function() {
        var e, t = new r;
        return function(i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), oo.prototype.setLength = function(e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, oo.prototype.setColor = function(e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, oo.prototype.copy = function(e) {
        return T.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }, oo.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, ao.prototype = Object.create(Ut.prototype), ao.prototype.constructor = ao, Dn.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Dn.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Object.assign(Wn.prototype, {
        createPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getPoints(e), this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getSpacedPoints(e), this.createGeometry(e)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new S, i = 0, n = e.length; i < n; i++) {
                var o = e[i];
                t.vertices.push(new r(o.x, o.y, o.z || 0))
            }
            return t
        }
    }), Object.assign(qn.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), so.prototype = Object.create(In.prototype), lo.prototype = Object.create(In.prototype), co.prototype = Object.create(In.prototype), Object.assign(co.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Jr.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Wr.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(fr.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ko.extractUrlBase(e)
        }
    }), Object.assign(cr.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(Ur.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(d.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Hr.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(uo, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), uo.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), uo.ceilPowerOfTwo(e)
        }
    }), Object.assign(o.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(g.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new r), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, i, n, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, o)
        }
    }), f.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, n.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(q.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(X.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(X, {
        barycoordFromPoint: function(e, t, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(e, t, i, n, r)
        },
        normal: function(e, t, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(e, t, i, n)
        }
    }), Object.assign(Xn.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Di(this, e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Hi(this, e)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(r.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(s.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(S.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(T.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(T.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(It.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Nt.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), zt.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Dn.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), wt.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Yn.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(A.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(k.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function(e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(k.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(Pi.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Or.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(V.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new b
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        }
    }), Object.defineProperties(tn.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(W.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(St.prototype, {
        clearTarget: function(e, t, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
    }), Object.defineProperties(St.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(mt.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(h.prototype, {
        activeCubeFace: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }), Object.defineProperties(l.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(Mt.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), Mr.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new mr).load(e, (function(e) {
            t.setBuffer(e)
        })), this
    }, Sr.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, wr.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    }, fo.crossOrigin = void 0, fo.loadTexture = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new Ln;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, fo.loadTextureCube = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Cn;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, fo.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, fo.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }, e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AmbientLight = nr, e.AmbientLightProbe = br, e.AnimationClip = xn, e.AnimationLoader = Mn, e.AnimationMixer = Rr, e.AnimationObjectGroup = Dr, e.AnimationUtils = Vo, e.ArcCurve = Rn, e.ArrayCamera = _t, e.ArrowHelper = oo, e.Audio = Mr, e.AudioAnalyser = Sr, e.AudioContext = sa, e.AudioListener = Er, e.AudioLoader = mr, e.AxesHelper = ao, e.AxisHelper = function(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ao(e)
    }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Sn(e)
    }, e.Bone = Bt, e.BooleanKeyframeTrack = pn, e.BoundingBoxHelper = function(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new io(e, t)
    }, e.Box2 = Ur, e.Box3 = d, e.Box3Helper = no, e.BoxBufferGeometry = H, e.BoxGeometry = U, e.BoxHelper = io, e.BufferAttribute = A, e.BufferGeometry = k, e.BufferGeometryLoader = lr, e.ByteType = 1010, e.Cache = Wo, e.Camera = xt, e.CameraHelper = to, e.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed")
    }, e.CanvasTexture = qt, e.CatmullRomCurve3 = In, e.CineonToneMapping = 4, e.CircleBufferGeometry = Ji, e.CircleGeometry = Zi, e.ClampToEdgeWrapping = 1001, e.Clock = _r, e.ClosedSplineCurve3 = so, e.Color = b, e.ColorKeyframeTrack = fn, e.CompressedTexture = Wt, e.CompressedTextureLoader = Tn, e.ConeBufferGeometry = Yi, e.ConeGeometry = Xi, e.CubeCamera = wr, e.CubeGeometry = U, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.CubeTexture = se, e.CubeTextureLoader = Cn, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = Fn, e.CubicBezierCurve3 = kn, e.CubicInterpolant = cn, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Dn, e.CurvePath = Wn, e.CustomBlending = 5, e.CylinderBufferGeometry = qi, e.CylinderGeometry = Wi, e.Cylindrical = kr, e.DataTexture = u, e.DataTexture2DArray = le, e.DataTexture3D = ce, e.DataTextureLoader = Sn, e.DefaultLoadingManager = qo, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.DepthTexture = Xt, e.DirectionalLight = ir, e.DirectionalLightHelper = eo, e.DirectionalLightShadow = tr, e.DiscreteInterpolant = un, e.DodecahedronBufferGeometry = ai, e.DodecahedronGeometry = oi, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(e, t).setDynamic(!0)
    }, e.EdgesGeometry = Vi, e.EdgesHelper = function(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ut(new Vi(e.geometry), new Ft({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.EllipseCurve = Pn, e.EqualDepth = 4, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.Euler = E, e.EventDispatcher = t, e.ExtrudeBufferGeometry = Pi, e.ExtrudeGeometry = Di, e.Face3 = _, e.Face4 = function(e, t, i, n, r, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new _(e, t, i, r, o, a)
    }, e.FaceColors = 1, e.FaceNormalsHelper = Kr, e.FileLoader = En, e.FlatShading = 1, e.Float32Attribute = function(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new z(e, t)
    }, e.Float32BufferAttribute = z, e.Float64Attribute = function(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new N(e, t)
    }, e.Float64BufferAttribute = N, e.FloatType = 1015, e.Fog = Ct, e.FogExp2 = At, e.Font = dr, e.FontLoader = pr, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = 0, e.Frustum = m, e.GammaEncoding = 3007, e.Geometry = S, e.GeometryUtils = {
        merge: function(e, t, i) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh) {
                t.matrixAutoUpdate && t.updateMatrix();
                var n = t.matrix;
                t = t.geometry
            }
            e.merge(t, n, i)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    }, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GridHelper = Jr, e.Group = bt, e.HalfFloatType = 1016, e.HemisphereLight = Zn, e.HemisphereLightHelper = Yr, e.HemisphereLightProbe = yr, e.IcosahedronBufferGeometry = ri, e.IcosahedronGeometry = ni, e.ImageBitmapLoader = hr, e.ImageLoader = An, e.ImageUtils = fo, e.ImmediateRenderObject = Gr, e.InstancedBufferAttribute = sr, e.InstancedBufferGeometry = ar, e.InstancedInterleavedBuffer = Ir, e.Int16Attribute = function(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new P(e, t)
    }, e.Int16BufferAttribute = P, e.Int32Attribute = function(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new O(e, t)
    }, e.Int32BufferAttribute = O, e.Int8Attribute = function(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new C(e, t)
    }, e.Int8BufferAttribute = C, e.IntType = 1013, e.InterleavedBuffer = Dt, e.InterleavedBufferAttribute = Pt, e.Interpolant = ln, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.")
    }, e.KeyframeTrack = dn, e.LOD = It, e.LatheBufferGeometry = Ui, e.LatheGeometry = ki, e.Layers = M, e.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }, e.LessDepth = 2, e.LessEqualDepth = 3, e.Light = Yn, e.LightProbe = vr, e.LightProbeHelper = Zr, e.LightShadow = Jn, e.Line = kt, e.Line3 = Hr, e.LineBasicMaterial = Ft, e.LineCurve = Un, e.LineCurve3 = Hn, e.LineDashedMaterial = sn, e.LineLoop = Ht, e.LinePieces = 1, e.LineSegments = Ut, e.LineStrip = 0, e.LinearEncoding = 3e3, e.LinearFilter = 1006, e.LinearInterpolant = hn, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearToneMapping = 1, e.Loader = fr, e.LoaderUtils = Ko, e.LoadingManager = _n, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, e.Material = V, e.MaterialLoader = or, e.Math = uo, e.Matrix3 = o, e.Matrix4 = g, e.MaxEquation = 104, e.Mesh = Z, e.MeshBasicMaterial = Y, e.MeshDepthMaterial = pt, e.MeshDistanceMaterial = ft, e.MeshFaceMaterial = function(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, e.MeshLambertMaterial = on, e.MeshMatcapMaterial = an, e.MeshNormalMaterial = rn, e.MeshPhongMaterial = tn, e.MeshPhysicalMaterial = en, e.MeshStandardMaterial = Ki, e.MeshToonMaterial = nn, e.MinEquation = 103, e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMaterial = function(e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
            return e.slice()
        }, e
    }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NeverDepth = 0, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NumberKeyframeTrack = mn, e.Object3D = T, e.ObjectLoader = cr, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = ii, e.OctahedronGeometry = ti, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = er, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.ParametricBufferGeometry = Jt, e.ParametricGeometry = Zt, e.Particle = function(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ot(e)
    }, e.ParticleBasicMaterial = function(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.ParticleSystem = function(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new jt(e, t)
    }, e.ParticleSystemMaterial = function(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.Path = qn, e.PerspectiveCamera = wt, e.Plane = f, e.PlaneBufferGeometry = j, e.PlaneGeometry = G, e.PlaneHelper = ro, e.PointCloud = function(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new jt(e, t)
    }, e.PointCloudMaterial = function(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Gt(e)
    }, e.PointLight = Kn, e.PointLightHelper = qr, e.Points = jt, e.PointsMaterial = Gt, e.PolarGridHelper = Qr, e.PolyhedronBufferGeometry = $t, e.PolyhedronGeometry = Qt, e.PositionalAudio = Tr, e.PositionalAudioHelper = $r, e.PropertyBinding = Lr, e.PropertyMixer = Ar, e.QuadraticBezierCurve = Gn, e.QuadraticBezierCurve3 = jn, e.Quaternion = n, e.QuaternionKeyframeTrack = vn, e.QuaternionLinearInterpolant = gn, e.REVISION = "105", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, e.RGB_S3TC_DXT1_Format = 33776, e.RawShaderMaterial = $i, e.Ray = q, e.Raycaster = zr, e.RectAreaLight = rr, e.RectAreaLightHelper = Xr, e.RedFormat = 1028, e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Fi, e.RingGeometry = Bi, e.Scene = Lt, e.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    }, e.ShaderChunk = go, e.ShaderLib = xo, e.ShaderMaterial = W, e.ShadowMaterial = Qi, e.Shape = Xn, e.ShapeBufferGeometry = Gi, e.ShapeGeometry = Hi, e.ShapePath = ur, e.ShapeUtils = Uo, e.ShortType = 1011, e.Skeleton = Nt, e.SkeletonHelper = Wr, e.SkinnedMesh = zt, e.SmoothShading = 2, e.Sphere = p, e.SphereBufferGeometry = Ni, e.SphereGeometry = zi, e.Spherical = Fr, e.SphericalHarmonics3 = gr, e.SphericalReflectionMapping = 305, e.Spline = co, e.SplineCurve = Vn, e.SplineCurve3 = lo, e.SpotLight = $n, e.SpotLightHelper = Vr, e.SpotLightShadow = Qn, e.Sprite = Ot, e.SpriteMaterial = Rt, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StereoCamera = xr, e.StringKeyframeTrack = yn, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = ei, e.TetrahedronGeometry = Kt, e.TextBufferGeometry = Ii, e.TextGeometry = Oi, e.Texture = a, e.TextureLoader = Ln, e.TorusBufferGeometry = di, e.TorusGeometry = ui, e.TorusKnotBufferGeometry = hi, e.TorusKnotGeometry = ci, e.Triangle = X, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = li, e.TubeGeometry = si, e.UVMapping = 300, e.Uint16Attribute = function(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new R(e, t)
    }, e.Uint16BufferAttribute = R, e.Uint32Attribute = function(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new I(e, t)
    }, e.Uint32BufferAttribute = I, e.Uint8Attribute = function(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new L(e, t)
    }, e.Uint8BufferAttribute = L, e.Uint8ClampedAttribute = function(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new D(e, t)
    }, e.Uint8ClampedBufferAttribute = D, e.Uncharted2ToneMapping = 3, e.Uniform = Or, e.UniformsLib = bo, e.UniformsUtils = vo, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.Vector2 = i, e.Vector3 = r, e.Vector4 = s, e.VectorKeyframeTrack = bn, e.Vertex = function(e, t, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(e, t, i)
    }, e.VertexColors = 2, e.VertexNormalsHelper = jr, e.VideoTexture = Vt, e.WebGLMultisampleRenderTarget = c, e.WebGLRenderTarget = l, e.WebGLRenderTargetCube = h, e.WebGLRenderer = St, e.WebGLUtils = yt, e.WireframeGeometry = Yt, e.WireframeHelper = function(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ut(new Yt(e.geometry), new Ft({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new En(e)
    }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", {
        value: !0
    })
})),
function(e, t) {
    if ("function" == typeof define && define.amd) define(["module", "exports"], t);
    else if ("undefined" != typeof exports) t(module, exports);
    else {
        var i = {
            exports: {}
        };
        t(i, i.exports), e.WOW = i.exports
    }
}(this, (function(e, t) {
    "use strict";

    function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        return t.indexOf(e) >= 0
    }

    function r(e, t, i) {
        null != e.addEventListener ? e.addEventListener(t, i, !1) : null != e.attachEvent ? e.attachEvent("on" + t, i) : e[t] = i
    }

    function o(e, t, i) {
        null != e.removeEventListener ? e.removeEventListener(t, i, !1) : null != e.detachEvent ? e.detachEvent("on" + t, i) : delete e[t]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var a, s, l = function() {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                }
            }
            return function(t, i, n) {
                return i && e(t.prototype, i), n && e(t, n), t
            }
        }(),
        c = window.WeakMap || window.MozWeakMap || function() {
            function e() {
                i(this, e), this.keys = [], this.values = []
            }
            return l(e, [{
                key: "get",
                value: function(e) {
                    for (var t = 0; t < this.keys.length; t++)
                        if (this.keys[t] === e) return this.values[t]
                }
            }, {
                key: "set",
                value: function(e, t) {
                    for (var i = 0; i < this.keys.length; i++)
                        if (this.keys[i] === e) return this.values[i] = t, this;
                    return this.keys.push(e), this.values.push(t), this
                }
            }]), e
        }(),
        h = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (s = a = function() {
            function e() {
                i(this, e), "undefined" != typeof console && null !== console && (console.warn("MutationObserver is not supported by your browser."), console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content."))
            }
            return l(e, [{
                key: "observe",
                value: function() {}
            }]), e
        }(), a.notSupported = !0, s),
        u = window.getComputedStyle || function(e) {
            var t = /(\-([a-z]){1})/g;
            return {
                getPropertyValue: function(i) {
                    "float" === i && (i = "styleFloat"), t.test(i) && i.replace(t, (function(e, t) {
                        return t.toUpperCase()
                    }));
                    var n = e.currentStyle;
                    return (null != n ? n[i] : void 0) || null
                }
            }
        },
        d = function() {
            function e() {
                var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
                i(this, e), this.defaults = {
                    boxClass: "wow",
                    animateClass: "animated",
                    offset: 0,
                    mobile: !0,
                    live: !0,
                    callback: null,
                    scrollContainer: null,
                    resetAnimation: !0
                }, this.animate = "requestAnimationFrame" in window ? function(e) {
                    return window.requestAnimationFrame(e)
                } : function(e) {
                    return e()
                }, this.vendors = ["moz", "webkit"], this.start = this.start.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.scrollHandler = this.scrollHandler.bind(this), this.scrollCallback = this.scrollCallback.bind(this), this.scrolled = !0, this.config = function(e, t) {
                    for (var i in t)
                        if (null == e[i]) {
                            var n = t[i];
                            e[i] = n
                        } return e
                }(t, this.defaults), null != t.scrollContainer && (this.config.scrollContainer = document.querySelector(t.scrollContainer)), this.animationNameCache = new c, this.wowEvent = function(e) {
                    var t = !(arguments.length <= 1 || void 0 === arguments[1]) && arguments[1],
                        i = !(arguments.length <= 2 || void 0 === arguments[2]) && arguments[2],
                        n = arguments.length <= 3 || void 0 === arguments[3] ? null : arguments[3],
                        r = void 0;
                    return null != document.createEvent ? (r = document.createEvent("CustomEvent")).initCustomEvent(e, t, i, n) : null != document.createEventObject ? (r = document.createEventObject()).eventType = e : r.eventName = e, r
                }(this.config.boxClass)
            }
            return l(e, [{
                key: "init",
                value: function() {
                    this.element = window.document.documentElement, n(document.readyState, ["interactive", "complete"]) ? this.start() : r(document, "DOMContentLoaded", this.start), this.finished = []
                }
            }, {
                key: "start",
                value: function() {
                    var e = this;
                    if (this.stopped = !1, this.boxes = [].slice.call(this.element.querySelectorAll("." + this.config.boxClass)), this.all = this.boxes.slice(0), this.boxes.length)
                        if (this.disabled()) this.resetStyle();
                        else
                            for (var t = 0; t < this.boxes.length; t++) {
                                var i = this.boxes[t];
                                this.applyStyle(i, !0)
                            }
                    this.disabled() || (r(this.config.scrollContainer || window, "scroll", this.scrollHandler), r(window, "resize", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live && new h((function(t) {
                        for (var i = 0; i < t.length; i++)
                            for (var n = t[i], r = 0; r < n.addedNodes.length; r++) {
                                var o = n.addedNodes[r];
                                e.doSync(o)
                            }
                    })).observe(document.body, {
                        childList: !0,
                        subtree: !0
                    })
                }
            }, {
                key: "stop",
                value: function() {
                    this.stopped = !0, o(this.config.scrollContainer || window, "scroll", this.scrollHandler), o(window, "resize", this.scrollHandler), null != this.interval && clearInterval(this.interval)
                }
            }, {
                key: "sync",
                value: function() {
                    h.notSupported && this.doSync(this.element)
                }
            }, {
                key: "doSync",
                value: function(e) {
                    if (null != e || (e = this.element), 1 === e.nodeType)
                        for (var t = (e = e.parentNode || e).querySelectorAll("." + this.config.boxClass), i = 0; i < t.length; i++) {
                            var r = t[i];
                            n(r, this.all) || (this.boxes.push(r), this.all.push(r), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(r, !0), this.scrolled = !0)
                        }
                }
            }, {
                key: "show",
                value: function(e) {
                    return this.applyStyle(e), e.className = e.className + " " + this.config.animateClass, null != this.config.callback && this.config.callback(e),
                        function(e, t) {
                            null != e.dispatchEvent ? e.dispatchEvent(t) : t in (null != e) ? e[t]() : "on" + t in (null != e) && e["on" + t]()
                        }(e, this.wowEvent), this.config.resetAnimation && (r(e, "animationend", this.resetAnimation), r(e, "oanimationend", this.resetAnimation), r(e, "webkitAnimationEnd", this.resetAnimation), r(e, "MSAnimationEnd", this.resetAnimation)), e
                }
            }, {
                key: "applyStyle",
                value: function(e, t) {
                    var i = this,
                        n = e.getAttribute("data-wow-duration"),
                        r = e.getAttribute("data-wow-delay"),
                        o = e.getAttribute("data-wow-iteration");
                    return this.animate((function() {
                        return i.customStyle(e, t, n, r, o)
                    }))
                }
            }, {
                key: "resetStyle",
                value: function() {
                    for (var e = 0; e < this.boxes.length; e++) this.boxes[e].style.visibility = "visible"
                }
            }, {
                key: "resetAnimation",
                value: function(e) {
                    if (e.type.toLowerCase().indexOf("animationend") >= 0) {
                        var t = e.target || e.srcElement;
                        t.className = t.className.replace(this.config.animateClass, "").trim()
                    }
                }
            }, {
                key: "customStyle",
                value: function(e, t, i, n, r) {
                    return t && this.cacheAnimationName(e), e.style.visibility = t ? "hidden" : "visible", i && this.vendorSet(e.style, {
                        animationDuration: i
                    }), n && this.vendorSet(e.style, {
                        animationDelay: n
                    }), r && this.vendorSet(e.style, {
                        animationIterationCount: r
                    }), this.vendorSet(e.style, {
                        animationName: t ? "none" : this.cachedAnimationName(e)
                    }), e
                }
            }, {
                key: "vendorSet",
                value: function(e, t) {
                    for (var i in t)
                        if (t.hasOwnProperty(i)) {
                            var n = t[i];
                            e["" + i] = n;
                            for (var r = 0; r < this.vendors.length; r++) e["" + this.vendors[r] + i.charAt(0).toUpperCase() + i.substr(1)] = n
                        }
                }
            }, {
                key: "vendorCSS",
                value: function(e, t) {
                    for (var i = u(e), n = i.getPropertyCSSValue(t), r = 0; r < this.vendors.length; r++) {
                        var o = this.vendors[r];
                        n = n || i.getPropertyCSSValue("-" + o + "-" + t)
                    }
                    return n
                }
            }, {
                key: "animationName",
                value: function(e) {
                    var t = void 0;
                    try {
                        t = this.vendorCSS(e, "animation-name").cssText
                    } catch (i) {
                        t = u(e).getPropertyValue("animation-name")
                    }
                    return "none" === t ? "" : t
                }
            }, {
                key: "cacheAnimationName",
                value: function(e) {
                    return this.animationNameCache.set(e, this.animationName(e))
                }
            }, {
                key: "cachedAnimationName",
                value: function(e) {
                    return this.animationNameCache.get(e)
                }
            }, {
                key: "scrollHandler",
                value: function() {
                    this.scrolled = !0
                }
            }, {
                key: "scrollCallback",
                value: function() {
                    if (this.scrolled) {
                        this.scrolled = !1;
                        for (var e = [], t = 0; t < this.boxes.length; t++) {
                            var i = this.boxes[t];
                            if (i) {
                                if (this.isVisible(i)) {
                                    this.show(i);
                                    continue
                                }
                                e.push(i)
                            }
                        }
                        this.boxes = e, this.boxes.length || this.config.live || this.stop()
                    }
                }
            }, {
                key: "offsetTop",
                value: function(e) {
                    for (; void 0 === e.offsetTop;) e = e.parentNode;
                    for (var t = e.offsetTop; e.offsetParent;) t += (e = e.offsetParent).offsetTop;
                    return t
                }
            }, {
                key: "isVisible",
                value: function(e) {
                    var t = e.getAttribute("data-wow-offset") || this.config.offset,
                        i = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset,
                        n = i + Math.min(this.element.clientHeight, "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight) - t,
                        r = this.offsetTop(e),
                        o = r + e.clientHeight;
                    return n >= r && o >= i
                }
            }, {
                key: "disabled",
                value: function() {
                    return !this.config.mobile && function(e) {
                        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(e)
                    }(navigator.userAgent)
                }
            }]), e
        }();
    t.default = d, e.exports = t.default
}));